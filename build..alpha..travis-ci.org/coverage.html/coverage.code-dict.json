{"/home/travis/build/npmtest/node-npmtest-gcloud/test.js":"/* istanbul instrument in package npmtest_gcloud */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-gcloud/lib.npmtest_gcloud.js":"/* istanbul instrument in package npmtest_gcloud */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_gcloud = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_gcloud = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-gcloud/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-gcloud && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_gcloud */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_gcloud\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_gcloud.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_gcloud.rollup.js'] =\n            local.assetsDict['/assets.npmtest_gcloud.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_gcloud.__dirname + '/lib.npmtest_gcloud.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/index.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module gcloud\n */\n\n'use strict';\n\nvar extend = require('extend');\n\n/**\n * The APIs exposed to the user.\n *\n * @type {object}\n * @private\n */\nvar apis = {\n  /**\n   * Analyze Big Data in the cloud with\n   * [Google BigQuery](https://cloud.google.com/bigquery). Run fast, SQL-like\n   * queries against multi-terabyte datasets in seconds. Scalable and easy to\n   * use, BigQuery gives you real-time insights about your data.\n   *\n   * @type {module:bigquery}\n   *\n   * @return {module:bigquery}\n   *\n   * @example\n   * var gcloud = require('gcloud');\n   * var bigquery = gcloud.bigquery({\n   *   projectId: 'grape-spaceship-123',\n   *   keyFilename: '/path/to/keyfile.json'\n   * });\n   */\n  bigquery: require('./bigquery'),\n\n  /**\n   * [Cloud Bigtable](https://cloud.google.com/bigtable/) is Google's NoSQL Big\n   * Data database service. It's the same database that powers many core Google\n   * services, including Search, Analytics, Maps, and Gmail.\n   *\n   * @type {module:bigtable}\n   *\n   * @return {module:bigtable}\n   *\n   * @example\n   * var gcloud = require('gcloud');\n   * var bigtable = gcloud.bigtable({\n   *   projectId: 'grape-spaceship-123',\n   *   keyFilename: '/path/to/keyfile.json',\n   *   zone: 'us-central1-b',\n   *   cluster: 'gcloud-node'\n   * });\n   */\n  bigtable: require('./bigtable'),\n\n  /**\n   * With [Compute Engine](https://cloud.google.com/compute/), you can run\n   * large-scale workloads on virtual machines hosted on Google's\n   * infrastructure. Choose a VM that fits your needs and gain the performance\n   * of Googleâ€™s worldwide fiber network.\n   *\n   * @type {module:compute}\n   *\n   * @return {module:compute}\n   *\n   * @example\n   * var gcloud = require('gcloud');\n   * var gce = gcloud.compute({\n   *   projectId: 'grape-spaceship-123',\n   *   keyFilename: '/path/to/keyfile.json'\n   * });\n   */\n  compute: require('./compute'),\n\n  /**\n   * [Google Cloud Datastore](https://developers.google.com/datastore/) is a\n   * fully managed, schemaless database for storing non-relational data. Use\n   * this object to create a Dataset to interact with your data, an \"Int\", and a\n   * \"Double\" representation.\n   *\n   * @type {module:datastore}\n   *\n   * @return {module:datastore}\n   *\n   * @example\n   * var gcloud = require('gcloud');\n   * var datastore = gcloud.datastore({\n   *   projectId: 'grape-spaceship-123',\n   *   keyFilename: '/path/to/keyfile.json'\n   * });\n   */\n  datastore: require('./datastore'),\n\n  /**\n   * [Google Cloud DNS](https://cloud.google.com/dns/what-is-cloud-dns) is a\n   * high-performance, resilient, global DNS service that provides a cost-\n   * effective way to make your applications and services available to your\n   * users. This programmable, authoritative DNS service can be used to easily\n   * publish and manage DNS records using the same infrastructure relied upon by\n   * Google.\n   *\n   * @type {module:dns}\n   *\n   * @return {module:dns}\n   *\n   * @example\n   * var gcloud = require('gcloud');\n   * var dns = gcloud.dns({\n   *   projectId: 'grape-spaceship-123',\n   *   keyFilename: '/path/to/keyfile.json'\n   * });\n   */\n  dns: require('./dns'),\n\n  /**\n   * The [Google Prediction API](https://cloud.google.com/prediction/docs/getting-started)\n   * provides pattern-matching and machine learning capabilities. Given a set of\n   * data examples to train against, you can create applications that can\n   * perform the following tasks:\n   *\n   *   - Given a user's past viewing habits, predict what other movies or\n   *   products a user might like.\n   *   - Categorize emails as spam or non-spam.\n   *   - Analyze posted comments about your product to determine whether they\n   *   have a positive or negative tone.\n   *   - Guess how much a user might spend on a given day, given his spending\n   *   history.\n   *\n   * @type {module:prediction}\n   *\n   * @return {module:prediction}\n   *\n   * @example\n   * var gcloud = require('gcloud');\n   * var dns = gcloud.prediction({\n   *   projectId: 'grape-spaceship-123',\n   *   keyFilename: '/path/to/keyfile.json'\n   * });\n   */\n  prediction: require('./prediction'),\n\n  /**\n   * [Google Cloud Logging](https://cloud.google.com/logging/docs) collects and\n   * stores logs from applications and services on the Google Cloud Platform:\n   *\n   *   - Export your logs to Google Cloud Storage, Google BigQuery, or Google\n   *     Cloud Pub/Sub.\n   *   - Integrate third-party logs from your virtual machine instances by\n   *     installing the logging agent, `google-fluentd`.\n   *\n   * <p class=\"notice\">\n   *   **This is a Beta release of Google Cloud Logging.** This API is not\n   *   covered by any SLA or deprecation policy and may be subject to backward-\n   *   incompatible changes.\n   * </p>\n   *\n   * @type {module:logging}\n   *\n   * @return {module:logging}\n   *\n   * @example\n   * var gcloud = require('gcloud');\n   * var logging = gcloud.logging({\n   *   projectId: 'grape-spaceship-123',\n   *   keyFilename: '/path/to/keyfile.json'\n   * });\n   */\n  logging: require('./logging'),\n\n  /**\n   * [Google Cloud Pub/Sub](https://developers.google.com/pubsub/overview) is a\n   * reliable, many-to-many, asynchronous messaging service from Google Cloud\n   * Platform.\n   *\n   * @type {module:pubsub}\n   *\n   * @return {module:pubsub}\n   *\n   * @example\n   * var gcloud = require('gcloud');\n   * var pubsub = gcloud.pubsub({\n   *   projectId: 'grape-spaceship-123',\n   *   keyFilename: '/path/to/keyfile.json'\n   * });\n   */\n  pubsub: require('./pubsub'),\n\n  /**\n   * [The Cloud Resource Manager](https://cloud.google.com/resource-manager/)\n   * provides methods that you can use to programmatically manage your projects\n   * in the Google Cloud Platform. With this API, you can do the following:\n   *\n   *   - Get a list of all projects associated with an account.\n   *   - Create new projects.\n   *   - Update existing projects.\n   *   - Delete projects.\n   *   - Recover projects.\n   *\n   * <p class=\"notice\">\n   *   **This is a Beta release of Cloud Resource Manager.** This feature is not\n   *   covered by any SLA or deprecation policy and may be subject to backward-\n   *   incompatible changes.\n   * </p>\n   *\n   * @type {module:resource}\n   *\n   * @return {module:resource}\n   *\n   * @example\n   * var gcloud = require('gcloud');\n   * var resource = gcloud.resource({\n   *   projectId: 'grape-spaceship-123',\n   *   keyFilename: '/path/to/keyfile.json'\n   * });\n   */\n  resource: require('./resource'),\n\n  /**\n   * Google Cloud Storage allows you to store data on Google infrastructure.\n   * Read [Google Cloud Storage API docs](https://developers.google.com/storage)\n   * for more information.\n   *\n   * @type {module:storage}\n   *\n   * @return {module:storage}\n   *\n   * @example\n   * var gcloud = require('gcloud');\n   * var gcs = gcloud.storage({\n   *   projectId: 'grape-spaceship-123',\n   *   keyFilename: '/path/to/keyfile.json'\n   * });\n   */\n  storage: require('./storage'),\n\n  /**\n   * With [Google Translate](https://cloud.google.com/translate), you can\n   * dynamically translate text between thousands of language pairs.\n   *\n   * The Google Translate API lets websites and programs integrate with Google\n   * Translate programmatically.\n   *\n   * Google Translate API is available as a paid service. See the\n   * [Pricing](https://cloud.google.com/translate/v2/pricing.html) and\n   * [FAQ](https://cloud.google.com/translate/v2/faq.html) pages for details.\n   *\n   * **An API key is required for Translate.** See\n   * [Identifying your application to Google](https://cloud.google.com/translate/v2/using_rest#auth).\n   *\n   * @type {module:translate}\n   *\n   * @return {module:translate}\n   *\n   * @example\n   * var gcloud = require('gcloud');\n   * var translate = gcloud.translate({\n   *   key: 'API Key'\n   * });\n   */\n  translate: require('./translate'),\n\n  /**\n   * The [Cloud Vision API](https://cloud.google.com/vision/docs) allows easy\n   * integration of vision detection features, including image labeling, face\n   * and landmark detection, optical character recognition (OCR), and tagging of\n   * explicit content.\n   *\n   * <p class=\"notice\">\n   *   **This is a Beta release of Google Cloud Vision.** This API is not\n   *   covered by any SLA or deprecation policy and may be subject to backward-\n   *   incompatible changes.\n   * </p>\n   *\n   * To learn more about the Vision API, see the\n   * [Getting Started guide](https://cloud.google.com/vision/docs/getting-started).\n   *\n   * @type {module:vision}\n   *\n   * @example\n   * var gcloud = require('gcloud')({\n   *   keyFilename: '/path/to/keyfile.json',\n   *   projectId: 'grape-spaceship-123'\n   * });\n   *\n   * var vision = gcloud.vision();\n   */\n  vision: require('./vision')\n};\n\n/*! Developer Documentation\n *\n * Previously we used gcloud to expose an object filled with factory patterns,\n * this allowed us to easily cascade global configurations to the individual\n * apis by storing them in a closure.\n *\n * The issue with the factory pattern approach was that we had to extend the\n * factory functions to expose any static members of the api class. Instead we\n * now store global configurations as a \"private\" member of the returned api\n * object as `config_`.\n *\n * Since our api constructors actually double up as factory patterns already,\n * we can determine when a particular api is being created and extend the\n * global configurations at that time.\n */\n/**\n * There are two key ways to use the `gcloud` module.\n *\n * 1. Provide connection & configuration details up-front.\n *\n * 2. Provide them at the time of instantiation of sub-modules, e.g. a Datastore\n * dataset, a Cloud Storage bucket, etc.\n *\n * ### Advanced Usage\n *\n * #### Interceptors\n *\n * All of the returned modules hold a special `interceptors` array you can use\n * to have control over the flow of the internal operations of this library. As\n * of now, we support a request interceptor, allowing you to tweak all of the\n * API request options before the HTTP request is sent.\n *\n * Note: If you are using the `maxApiCalls` option with a method, your request\n * interceptor will still be called, even if the `maxApiCalls` limit was\n * reached. The request to the API will still be prevented.\n *\n * See the example below for more.\n *\n * @alias module:gcloud\n * @constructor\n *\n * @param {object} config - Connection configuration options.\n * @param {string} config.projectId - The project ID from the Google Developer's\n *     Console. E.g. 'purple-grape-123'.\n * @param {string=} config.keyFilename - Full path to the a .json, .pem, or .p12\n *     key downloaded from the Google Developers Console. NOTE: .pem and .p12\n *     require you to specify `config.email` as well.\n * @param {string=} config.email - Account email address. Required when using a\n *     .pem or .p12 keyFilename.\n * @param {object=} config.credentials - Credentials object.\n * @param {string} config.credentials.client_email\n * @param {string} config.credentials.private_key\n * @param {boolean=} config.autoRetry - Automatically retry requests if the\n *     response is related to rate limits or certain intermittent server errors.\n *     We will exponentially backoff subsequent requests by default. (default:\n *     true)\n * @param {number=} config.maxRetries - Maximum number of automatic retries\n *     attempted before returning the error. (default: 3)\n *\n * @example\n * var gcloud = require('gcloud')({\n *   projectId: 'grape-spaceship-123',\n *   keyFilename: '/path/to/keyfile.json'\n * });\n *\n * //-\n * // From the same authentication credentials, you may now access your Google\n * // Cloud Storage buckets, for example.\n * //-\n * var gcs = gcloud.storage();\n * var bucket = gcs.bucket('photos');\n *\n * //-\n * // However, if you need to override the global credentials, you may provide\n * // new ones.\n * //-\n * var otherGcs = gcloud.storage({\n *   keyFilename: '/path/to/other/keyfile.json'\n * });\n * var otherBucket = otherGcs.bucket('other-photos');\n *\n * //-\n * // `gcs` and `otherGcs` will use their respective credentials for all future\n * // API requests.\n * //\n * // <h4>Interceptors</h4>\n * //\n * // Use a `request` interceptor to set a custom HTTP header on your requests.\n * //-\n * gcloud.interceptors.push({\n *   request: function(requestOptions) {\n *     requestOptions.headers = requestOptions.headers || {};\n *     requestOptions.headers['X-Cloud-Trace-Context'] = 'I will be overridden';\n *     return requestOptions;\n *   }\n * });\n *\n * //-\n * // You can also set an interceptor on the service level, like a Storage\n * // object.\n * //-\n * gcs.interceptors.push({\n *   request: function(requestOptions) {\n *     requestOptions.headers = requestOptions.headers || {};\n *     requestOptions.headers['X-Cloud-Trace-Context'] = 'I will be overridden';\n *     return requestOptions;\n *   }\n * });\n *\n * //-\n * // Additionally, set one on the service object level, such as a Bucket.\n * //-\n * bucket.interceptors.push({\n *   request: function(requestOptions) {\n *     requestOptions.headers = requestOptions.headers || {};\n *     requestOptions.headers['X-Cloud-Trace-Context'] = 'I win!';\n *     return requestOptions;\n *   }\n * });\n *\n * //-\n * // The following request will combine all of the headers, executed in the\n * // order from when they were assigned, respecting the hierarchy:\n * // global before service before service object.\n * //-\n * bucket.getMetadata(function() {\n *   // This HTTP request was sent with the 'I win!' header specified above.\n * });\n */\nfunction gcloud(config) {\n  config = extend(true, { interceptors_: [] }, config);\n\n  var gcloudExposedApi = {\n    config_: config,\n    interceptors: config.interceptors_\n  };\n\n  return Object.keys(apis).reduce(function(gcloudExposedApi, apiName) {\n    var Class = apis[apiName];\n\n    gcloudExposedApi[apiName] = Class;\n\n    return gcloudExposedApi;\n  }, gcloudExposedApi);\n}\n\nmodule.exports = extend(gcloud, apis);\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/bigquery/index.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module bigquery\n */\n\n'use strict';\n\nvar extend = require('extend');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:bigquery/dataset}\n * @private\n */\nvar Dataset = require('./dataset.js');\n\n/**\n * @type {module:bigquery/job}\n * @private\n */\nvar Job = require('./job.js');\n\n/**\n * @type {module:common/service}\n * @private\n */\nvar Service = require('../common/service.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:bigquery/table}\n * @private\n */\nvar Table = require('./table.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * The examples below will demonstrate the different usage patterns your app may\n * need to support to retrieve a BigQuery object.\n *\n * @alias module:bigquery\n * @constructor\n *\n * @classdesc\n * The object returned from `gcloud.bigquery` gives you complete access to and\n * control of your BigQuery datasets. You can work with existing ones, by using\n * the `dataset` method, or create new ones with `createDataset`.\n *\n * To learn more about BigQuery, see\n * [What is BigQuery?](https://cloud.google.com/bigquery/what-is-bigquery)\n *\n * @param {object} options - [Configuration object](#/docs).\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'my-project'\n * });\n *\n * var bigquery = gcloud.bigquery();\n *\n * //-\n * // In the following examples from this page and the other modules (Dataset,\n * // Table, etc.), we are going to be using a dataset from\n * // <a href=\"http://goo.gl/f2SXcb\">data.gov</a> of higher education\n * // institutions.\n * //\n * // We will create a table with the correct schema, import the public CSV\n * // file into that table, and query it for data.\n * //-\n */\nfunction BigQuery(options) {\n  if (!(this instanceof BigQuery)) {\n    options = util.normalizeArguments(this, options);\n    return new BigQuery(options);\n  }\n\n  var config = {\n    baseUrl: 'https://www.googleapis.com/bigquery/v2',\n    scopes: ['https://www.googleapis.com/auth/bigquery']\n  };\n\n  Service.call(this, config, options);\n}\n\nnodeutil.inherits(BigQuery, Service);\n\n/**\n * Create a dataset.\n *\n * @resource [Datasets: insert API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/datasets/insert}\n *\n * @param {string} id - ID of the dataset to create.\n * @param {object=} options - See a\n *     [Dataset resource](https://cloud.google.com/bigquery/docs/reference/v2/datasets#resource).\n * @param {function} callback  - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:bigquery/dataset} callback.dataset - The newly created dataset\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * bigquery.createDataset('my-dataset', function(err, dataset, apiResponse) {});\n */\nBigQuery.prototype.createDataset = function(id, options, callback) {\n  var that = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/datasets',\n    json: extend(true, {}, options, {\n      datasetReference: {\n        datasetId: id\n      }\n    })\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var dataset = that.dataset(id);\n    dataset.metadata = resp;\n\n    callback(null, dataset, resp);\n  });\n};\n\n/**\n * Create a reference to a dataset.\n *\n * @param {string} id - ID of the dataset.\n * @return {module:bigquery/dataset}\n *\n * @example\n * var dataset = bigquery.dataset('higher_education');\n */\nBigQuery.prototype.dataset = function(id) {\n  return new Dataset(this, id);\n};\n\n/**\n * List all or some of the datasets in your project.\n *\n * @resource [Datasets: list API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/datasets/list}\n *\n * @param {object=} query - Configuration object.\n * @param {boolean} query.all - List all datasets, including hidden ones.\n * @param {boolean} query.autoPaginate - Have pagination handled automatically.\n *     Default: true.\n * @param {number} query.maxApiCalls - Maximum number of API calls to make.\n * @param {number} query.maxResults - Maximum number of results to return.\n * @param {string} query.pageToken - Token returned from a previous call, to\n *     request the next page of results.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:bigquery/dataset[]} callback.datasets - The list of datasets\n *     in your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * bigquery.getDatasets(function(err, datasets) {\n *   if (!err) {\n *     // datasets is an array of Dataset objects.\n *   }\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * var callback = function(err, datasets, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     bigquery.getDatasets(nextQuery, callback);\n *   }\n * };\n *\n * bigquery.getDatasets({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the datasets from your project as a readable object stream.\n * //-\n * bigquery.getDatasets()\n *   .on('error', console.error)\n *   .on('data', function(dataset) {\n *     // dataset is a Dataset object.\n *   })\n *   .on('end', function() {\n *     // All datasets retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * bigquery.getDatasets()\n *   .on('data', function(dataset) {\n *     this.end();\n *   });\n */\nBigQuery.prototype.getDatasets = function(query, callback) {\n  var that = this;\n\n  if (is.fn(query)) {\n    callback = query;\n    query = {};\n  }\n\n  query = query || {};\n\n  this.request({\n    uri: '/datasets',\n    qs: query\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, query, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var datasets = (resp.datasets || []).map(function(dataset) {\n      var ds = that.dataset(dataset.datasetReference.datasetId);\n      ds.metadata = dataset;\n      return ds;\n    });\n\n    callback(null, datasets, nextQuery, resp);\n  });\n};\n\n/**\n * Get all of the jobs from your project.\n *\n * @resource [Jobs: list API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/list}\n *\n * @param {object=} options - Configuration object.\n * @param {boolean=} options.allUsers - Display jobs owned by all users in the\n *     project.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number=} options.maxResults - Maximum number of results to return.\n * @param {string=} options.pageToken - Token returned from a previous call, to\n *     request the next page of results.\n * @param {string=} options.projection - Restrict information returned to a set\n *     of selected fields. Acceptable values are \"full\", for all job data, and\n *     \"minimal\", to not include the job configuration.\n * @param {string=} options.stateFilter - Filter for job state. Acceptable\n *     values are \"done\", \"pending\", and \"running\".\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:bigquery/job[]} callback.jobs - The list of jobs in your\n *     project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * bigquery.getJobs(function(err, jobs) {\n *   if (!err) {\n *     // jobs is an array of Job objects.\n *   }\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * var callback = function(err, jobs, nextQuery, apiRespose) {\n *   if (nextQuery) {\n *     // More results exist.\n *     bigquery.getJobs(nextQuery, callback);\n *   }\n * };\n *\n * bigquery.getJobs({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the jobs from your project as a readable object stream.\n * //-\n * bigquery.getJobs()\n *   .on('error', console.error)\n *   .on('data', function(job) {\n *     // job is a Job object.\n *   })\n *   .on('end', function() {\n *     // All jobs retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * bigquery.getJobs()\n *   .on('data', function(job) {\n *     this.end();\n *   });\n */\nBigQuery.prototype.getJobs = function(options, callback) {\n  var that = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/jobs',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var jobs = (resp.jobs || []).map(function(jobObject) {\n      var job = that.job(jobObject.id);\n      job.metadata = jobObject;\n      return job;\n    });\n\n    callback(null, jobs, nextQuery, resp);\n  });\n};\n\n/**\n * Create a reference to an existing job.\n *\n * @param {string} id - ID of the job.\n * @return {module:bigquery/job}\n *\n * @example\n * var myExistingJob = bigquery.job('job-id');\n */\nBigQuery.prototype.job = function(id) {\n  return new Job(this, id);\n};\n\n/**\n * Run a query scoped to your project.\n *\n * If you provide a callback, this method returns the results from your query to\n * it. When querying large sets of data, it is possible your results won't be\n * returned all at once. In those cases, you will receive a third argument to\n * your callback that can be passed back to this method to return more results.\n *\n * See the examples below for such a workflow.\n *\n * This method also runs as a readable stream if you do not provide a callback.\n * In cases where more results exist, this will automatically run the subsequent\n * queries for you, pushing each row to the stream.\n *\n * @resource [Jobs: query API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/query}\n *\n * @param {string|object} options - A string SQL query or configuration object.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of results to read.\n * @param {string} options.query - A query string, following the BigQuery query\n *     syntax, of the query to execute.\n * @param {number} options.timeoutMs - How long to wait for the query to\n *     complete, in milliseconds, before returning. Default is to return\n *     immediately. If the timeout passes before the job completes, the request\n *     will fail with a `TIMEOUT` error.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {array} callback.rows - The list of results from your query.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var query = 'SELECT url FROM [publicdata:samples.github_nested] LIMIT 100';\n *\n * bigquery.query(query, function(err, rows) {\n *   if (!err) {\n *     // Handle results here.\n *   }\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * var callback = function(err, rows, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     bigquery.query(nextQuery, callback);\n *   }\n * };\n *\n * bigquery.query({\n *   query: query,\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // You can also use the `query` method as a readable object stream by\n * // omitting the callback.\n * //-\n * bigquery.query(query)\n *   .on('error', console.error)\n *   .on('data', function(row) {\n *     // row is a result from your query.\n *   })\n *   .on('end', function() {\n *     // All rows retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * bigquery.query(query)\n *   .on('data', function(row) {\n *     this.end();\n *   });\n */\nBigQuery.prototype.query = function(options, callback) {\n  var self = this;\n\n  if (is.string(options)) {\n    options = {\n      query: options\n    };\n  }\n\n  options = options || {};\n\n  var job = options.job;\n\n  var requestQuery = extend({}, options);\n  delete requestQuery.job;\n\n  if (job) {\n    // Get results of the query.\n    self.request({\n      uri: '/queries/' + job.id,\n      qs: requestQuery\n    }, responseHandler);\n  } else {\n    // Create a job.\n    self.request({\n      method: 'POST',\n      uri: '/queries',\n      json: options\n    }, responseHandler);\n  }\n\n  function responseHandler(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var rows = [];\n    if (resp.schema && resp.rows) {\n      rows = Table.mergeSchemaWithRows_(resp.schema, resp.rows);\n    }\n\n    var nextQuery = null;\n    if (resp.jobComplete === false) {\n      // Query is still running.\n      nextQuery = extend({}, options);\n    } else if (resp.pageToken) {\n      // More results exist.\n      nextQuery = extend({}, options, {\n        pageToken: resp.pageToken\n      });\n    }\n    if (nextQuery && !nextQuery.job && resp.jobReference.jobId) {\n      // Create a prepared Job to continue the query.\n      nextQuery.job = self.job(resp.jobReference.jobId);\n    }\n\n    callback(null, rows, nextQuery, resp);\n  }\n};\n\n/**\n * Run a query as a job. No results are immediately returned. Instead, your\n * callback will be executed with a {module:bigquery/job} object that you must\n * ping for the results. See the Job documentation for explanations of how to\n * check on the status of the job.\n *\n * @resource [Jobs: insert API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/insert}\n *\n * @param {object|string} options - The configuration object. This must be in\n *     the format of the [`configuration.query`](http://goo.gl/wRpHvR) property\n *     of a Jobs resource. If a string is provided, this is used as the query\n *     string, and all other options are defaulted.\n * @param {module:bigquery/table=} options.destination - The table to save the\n *     query's results to. If omitted, a new table will be created.\n * @param {string} options.query - A query string, following the BigQuery query\n *     syntax, of the query to execute.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:bigquery/job} callback.job - The newly created job for your\n       query.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @throws {Error} If a query is not specified.\n * @throws {Error} If a Table is not provided as a destination.\n *\n * @example\n * var query = 'SELECT url FROM [publicdata:samples.github_nested] LIMIT 100';\n *\n * //-\n * // You may pass only a query string, having a new table created to store the\n * // results of the query.\n * //-\n * bigquery.startQuery(query, function(err, job) {});\n *\n * //-\n * // You can also control the destination table by providing a\n * // {module:bigquery/table} object.\n * //-\n * bigquery.startQuery({\n *   destination: bigquery.dataset('higher_education').table('institutions'),\n *   query: query\n * }, function(err, job) {});\n *\n * //-\n * // After you have run `startQuery`, your query will execute in a job. Your\n * // callback is executed with a {module:bigquery/job} object so that you may\n * // check for the results.\n * //-\n * bigquery.startQuery(query, function(err, job) {\n *   if (!err) {\n *     job.getQueryResults(function(err, rows, apiResponse) {});\n *   }\n * });\n */\nBigQuery.prototype.startQuery = function(options, callback) {\n  var that = this;\n\n  if (is.string(options)) {\n    options = {\n      query: options\n    };\n  }\n\n  options = options || {};\n\n  if (!options.query) {\n    throw new Error('A SQL query string is required.');\n  }\n\n  var defaults = {};\n\n  if (options.destination) {\n    if (!(options.destination instanceof Table)) {\n      throw new Error('Destination must be a Table object.');\n    }\n    defaults.destinationTable = {\n      datasetId: options.destination.dataset.id,\n      projectId: options.destination.dataset.bigQuery.projectId,\n      tableId: options.destination.id\n    };\n    delete options.destination;\n  }\n\n  var body = {\n    configuration: {\n      query: extend(true, defaults, options)\n    }\n  };\n\n  this.request({\n    method: 'POST',\n    uri: '/jobs',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var job = that.job(resp.jobReference.jobId);\n    job.metadata = resp;\n\n    callback(null, job, resp);\n  });\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(BigQuery, ['getDatasets', 'getJobs', 'query']);\n\nmodule.exports = BigQuery;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/bigquery/dataset.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module bigquery/dataset\n */\n\n'use strict';\n\nvar extend = require('extend');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:bigquery/table}\n * @private\n */\nvar Table = require('./table.js');\n\n/*! Developer Documentation\n *\n * @param {module:bigquery} bigQuery - BigQuery instance.\n * @param {string} id - The ID of the Dataset.\n */\n/**\n * Interact with your BigQuery dataset. Create a Dataset instance with\n * {module:bigquery#createDataset} or {module:bigquery#dataset}.\n *\n * @alias module:bigquery/dataset\n * @constructor\n *\n * @example\n * var gcloud = require('gcloud');\n *\n * var bigquery = gcloud.bigquery({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n * var dataset = bigquery.dataset('institutions');\n */\nfunction Dataset(bigQuery, id) {\n  var methods = {\n    /**\n     * Create a dataset.\n     *\n     * @example\n     * dataset.create(function(err, dataset, apiResponse) {\n     *   if (!err) {\n     *     // The dataset was created successfully.\n     *   }\n     * });\n     */\n    create: true,\n\n    /**\n     * Check if the dataset exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the dataset exists or not.\n     *\n     * @example\n     * dataset.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a dataset if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * dataset.get(function(err, dataset, apiResponse) {\n     *   if (!err) {\n     *     // `dataset.metadata` has been populated.\n     *   }\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the metadata for the Dataset.\n     *\n     * @resource [Datasets: get API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/datasets/get}\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The dataset's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * dataset.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true,\n\n    /**\n     * Sets the metadata of the Dataset object.\n     *\n     * @resource [Datasets: patch API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/datasets/patch}\n     *\n     * @param {object} metadata - Metadata to save on the Dataset.\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * var metadata = {\n     *   description: 'Info for every institution in the 2013 IPEDS universe'\n     * };\n     *\n     * dataset.setMetadata(metadata, function(err, apiResponse) {});\n     */\n    setMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: bigQuery,\n    baseUrl: '/datasets',\n    id: id,\n    createMethod: bigQuery.createDataset.bind(bigQuery),\n    methods: methods\n  });\n\n  this.bigQuery = bigQuery;\n}\n\nnodeutil.inherits(Dataset, ServiceObject);\n\n/**\n * Create a table given a tableId or configuration object.\n *\n * @resource [Tables: insert API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/tables/insert}\n *\n * @param {string} id - Table id.\n * @param {object=} options - See a\n *     [Table resource](https://cloud.google.com/bigquery/docs/reference/v2/tables#resource).\n * @param {string|object} options.schema - A comma-separated list of name:type\n *     pairs. Valid types are \"string\", \"integer\", \"float\", \"boolean\", and\n *     \"timestamp\". If the type is omitted, it is assumed to be \"string\".\n *     Example: \"name:string, age:integer\". Schemas can also be specified as a\n *     JSON array of fields, which allows for nested and repeated fields. See\n *     a [Table resource](http://goo.gl/sl8Dmg) for more detailed information.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:bigquery/table} callback.table - The newly created table.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var tableId = 'institution_data';\n *\n * var options = {\n *   // From the data.gov CSV dataset (http://goo.gl/kSE7z6):\n *   schema: 'UNITID,INSTNM,ADDR,CITY,STABBR,ZIP,FIPS,OBEREG,CHFNM,...'\n * };\n *\n * dataset.createTable(tableId, options, function(err, table, apiResponse) {});\n */\nDataset.prototype.createTable = function(id, options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var body = extend(true, {}, options, {\n    tableReference: {\n      datasetId: this.id,\n      projectId: this.bigQuery.projectId,\n      tableId: id\n    }\n  });\n\n  if (is.string(options.schema)) {\n    body.schema = Table.createSchemaFromString_(options.schema);\n  }\n\n  if (is.array(options.schema)) {\n    body.schema = {\n      fields: options.schema\n    };\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/tables',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var table = self.table(resp.tableReference.tableId);\n    table.metadata = resp;\n\n    callback(null, table, resp);\n  });\n};\n\n/**\n * Delete the dataset.\n *\n * @resource [Datasets: delete API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/datasets/delete}\n *\n * @param {object=} options - The configuration object.\n * @param {boolean} options.force - Force delete dataset and all tables.\n *     Default: false.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // Delete the dataset, only if it does not have any tables.\n * //-\n * dataset.delete(function(err, apiResponse) {});\n *\n * //-\n * // Delete the dataset and any tables it contains.\n * //-\n * dataset.delete({ force: true }, function(err, apiResponse) {});\n */\nDataset.prototype.delete = function(options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  var query = {\n    deleteContents: !!options.force\n  };\n\n  this.request({\n    method: 'DELETE',\n    uri: '',\n    qs: query\n  }, callback);\n};\n\n/**\n * Get a list of tables.\n *\n * @resource [Tables: list API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/tables/list}\n *\n * @param {object=} query - Configuration object.\n * @param {boolean} query.autoPaginate - Have pagination handled automatically.\n *     Default: true.\n * @param {number} query.maxApiCalls - Maximum number of API calls to make.\n * @param {number} query.maxResults - Maximum number of results to return.\n * @param {string} query.pageToken - Token returned from a previous call, to\n *     request the next page of results.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:bigquery/table[]} callback.tables - The list of tables from\n *     your Dataset.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * dataset.getTables(function(err, tables, nextQuery, apiResponse) {\n *   // If `nextQuery` is non-null, there are more results to fetch.\n * });\n *\n * //-\n * // Get the tables as a readable object stream. `table` is a Table object\n * //-\n * dataset.getTables()\n *   .on('error', console.error)\n *   .on('data', function(table) {})\n *   .on('end', function() {\n *     // All tables have been retrieved\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * dataset.getTables()\n *   .on('data', function(table) {\n *     this.end();\n *   });\n */\nDataset.prototype.getTables = function(query, callback) {\n  var that = this;\n\n  if (is.fn(query)) {\n    callback = query;\n    query = {};\n  }\n\n  query = query || {};\n\n  this.request({\n    uri: '/tables',\n    qs: query\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, query, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var tables = (resp.tables || []).map(function(tableObject) {\n      var table = that.table(tableObject.tableReference.tableId);\n      table.metadata = tableObject;\n      return table;\n    });\n\n    callback(null, tables, nextQuery, resp);\n  });\n};\n\n/**\n * Run a query scoped to your dataset.\n *\n * See {module:bigquery#query} for full documentation of this method.\n */\nDataset.prototype.query = function(options, callback) {\n  if (is.string(options)) {\n    options = {\n      query: options\n    };\n  }\n\n  options = extend(true, {}, options, {\n    defaultDataset: {\n      datasetId: this.id\n    }\n  });\n\n  return this.bigQuery.query(options, callback);\n};\n\n/**\n * Create a Table object.\n *\n * @param {string} id - The ID of the table.\n * @return {module:bigquery/table}\n *\n * @example\n * var institutions = dataset.table('institution_data');\n */\nDataset.prototype.table = function(id) {\n  return new Table(this, id);\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(Dataset, ['getTables']);\n\nmodule.exports = Dataset;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/common/service-object.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module common/service-object\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar exec = require('methmeth');\nvar extend = require('extend');\nvar is = require('is');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('./util.js');\n\n/**\n * ServiceObject is a base class, meant to be inherited from by a \"service\n * object,\" like a BigQuery dataset or Storage bucket.\n *\n * Most of the time, these objects share common functionality; they can be\n * created or deleted, and you can get or set their metadata.\n *\n * By inheriting from this class, a service object will be extended with these\n * shared behaviors. Note that any method can be overridden when the service\n * object requires specific behavior.\n *\n * @constructor\n * @alias module:common/service-object\n *\n * @private\n *\n * @param {object} config - Configuration object.\n * @param {string} config.baseUrl - The base URL to make API requests to.\n * @param {string} config.createMethod - The method which creates this object.\n * @param {string} config.id - The identifier of the object. For example, the\n *     name of a Storage bucket or Pub/Sub topic.\n * @param {object=} config.methods - A map of each method name that should be\n *     inherited.\n * @param {object} config.methods[].reqOpts - Default request options for this\n *     particular method. A common use case is when `setMetadata` requires a\n *     `PUT` method to override the default `PATCH`.\n * @param {object} config.parent - The parent service instance. For example, an\n *     instance of Storage if the object is Bucket.\n */\nfunction ServiceObject(config) {\n  var self = this;\n\n  this.metadata = {};\n\n  this.baseUrl = config.baseUrl;\n  this.parent = config.parent; // Parent class.\n  this.id = config.id; // Name or ID (e.g. dataset ID, bucket name, etc.)\n  this.createMethod = config.createMethod;\n  this.methods = config.methods || {};\n  this.interceptors = [];\n\n  if (config.methods) {\n    var allMethodNames = Object.keys(ServiceObject.prototype);\n    allMethodNames\n      .filter(function(methodName) {\n        return (\n          // All ServiceObjects need `request`.\n          methodName !== 'request' &&\n\n          // The ServiceObject didn't redefine the method.\n          self[methodName] === ServiceObject.prototype[methodName] &&\n\n          // This method isn't wanted.\n          !config.methods[methodName]\n        );\n      })\n      .forEach(function(methodName) {\n        self[methodName] = undefined;\n      });\n  }\n}\n\n/**\n * Create the object.\n *\n * @param {object=} options - Configuration object.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.instance - The instance.\n * @param {object} callback.apiResponse - The full API response.\n */\nServiceObject.prototype.create = function(options, callback) {\n  var self = this;\n  var args = [this.id];\n\n  if (is.fn(options)) {\n    callback = options;\n  }\n\n  if (is.object(options)) {\n    args.push(options);\n  }\n\n  // Wrap the callback to return *this* instance of the object, not the newly-\n  // created one.\n  function onCreate(err, instance) {\n    var args = [].slice.call(arguments);\n\n    if (!err) {\n      self.metadata = instance.metadata;\n      args[1] = self; // replace the created `instance` with this one.\n    }\n\n    callback.apply(null, args);\n  }\n\n  args.push(onCreate);\n\n  this.createMethod.apply(null, args);\n};\n\n/**\n * Delete the object.\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.apiResponse - The full API response.\n */\nServiceObject.prototype.delete = function(callback) {\n  var methodConfig = this.methods.delete || {};\n  callback = callback || util.noop;\n\n  var reqOpts = extend({\n    method: 'DELETE',\n    uri: ''\n  }, methodConfig.reqOpts);\n\n  // The `request` method may have been overridden to hold any special behavior.\n  // Ensure we call the original `request` method.\n  ServiceObject.prototype.request.call(this, reqOpts, function(err, resp) {\n    callback(err, resp);\n  });\n};\n\n/**\n * Check if the object exists.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {boolean} callback.exists - Whether the object exists or not.\n */\nServiceObject.prototype.exists = function(callback) {\n  this.get(function(err) {\n    if (err) {\n      if (err.code === 404) {\n        callback(null, false);\n      } else {\n        callback(err);\n      }\n\n      return;\n    }\n\n    callback(null, true);\n  });\n};\n\n/**\n * Get the object if it exists. Optionally have the object created if an options\n * object is provided with `autoCreate: true`.\n *\n * @param {object=} config - The configuration object that will be used to\n *     create the object if necessary.\n * @param {boolean} config.autoCreate - Create the object if it doesn't already\n *     exist.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.instance - The instance.\n * @param {object} callback.apiResponse - The full API response.\n */\nServiceObject.prototype.get = function(config, callback) {\n  var self = this;\n\n  if (is.fn(config)) {\n    callback = config;\n    config = {};\n  }\n\n  config = config || {};\n\n  var autoCreate = config.autoCreate && is.fn(this.create);\n  delete config.autoCreate;\n\n  this.getMetadata(function(err, metadata) {\n    if (err) {\n      if (err.code === 404 && autoCreate) {\n        var args = [callback];\n\n        if (!is.empty(config)) {\n          args.unshift(config);\n        }\n\n        self.create.apply(self, args);\n        return;\n      }\n\n      callback(err, null, metadata);\n      return;\n    }\n\n    callback(null, self, metadata);\n  });\n};\n\n/**\n * Get the metadata of this object.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.metadata - The metadata for this object.\n * @param {object} callback.apiResponse - The full API response.\n */\nServiceObject.prototype.getMetadata = function(callback) {\n  var self = this;\n\n  var methodConfig = this.methods.getMetadata || {};\n\n  var reqOpts = extend({\n    uri: ''\n  }, methodConfig.reqOpts);\n\n  // The `request` method may have been overridden to hold any special behavior.\n  // Ensure we call the original `request` method.\n  ServiceObject.prototype.request.call(this, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    self.metadata = resp;\n\n    callback(null, self.metadata, resp);\n  });\n};\n\n/**\n * Set the metadata for this object.\n *\n * @param {object} metadata - The metadata to set on this object.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.instance - The instance.\n * @param {object} callback.apiResponse - The full API response.\n */\nServiceObject.prototype.setMetadata = function(metadata, callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  var methodConfig = this.methods.setMetadata || {};\n\n  var reqOpts = extend(true, {\n    method: 'PATCH',\n    uri: '',\n    json: metadata\n  }, methodConfig.reqOpts);\n\n  // The `request` method may have been overridden to hold any special behavior.\n  // Ensure we call the original `request` method.\n  ServiceObject.prototype.request.call(this, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, resp);\n      return;\n    }\n\n    self.metadata = resp;\n\n    callback(null, resp);\n  });\n};\n\n/**\n * Make an authenticated API request.\n *\n * @private\n *\n * @param {object} reqOpts - Request options that are passed to `request`.\n * @param {string} reqOpts.uri - A URI relative to the baseUrl.\n * @param {function} callback - The callback function passed to `request`.\n */\nServiceObject.prototype.request = function(reqOpts, callback) {\n  reqOpts = extend(true, {}, reqOpts);\n\n  var isAbsoluteUrl = reqOpts.uri.indexOf('http') === 0;\n\n  var uriComponents = [\n    this.baseUrl,\n    this.id,\n    reqOpts.uri\n  ];\n\n  if (isAbsoluteUrl) {\n    uriComponents.splice(0, uriComponents.indexOf(reqOpts.uri));\n  }\n\n  reqOpts.uri = uriComponents\n    .filter(exec('trim')) // Limit to non-empty strings.\n    .map(function(uriComponent) {\n      var trimSlashesRegex = /^\\/*|\\/*$/g;\n      return uriComponent.replace(trimSlashesRegex, '');\n    })\n    .join('/');\n\n  var childInterceptors = arrify(reqOpts.interceptors_);\n  var localInterceptors = [].slice.call(this.interceptors);\n\n  reqOpts.interceptors_ = childInterceptors.concat(localInterceptors);\n\n  return this.parent.request(reqOpts, callback);\n};\n\nmodule.exports = ServiceObject;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/common/util.js":"/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module common/util\n */\n\n'use strict';\n\nvar createErrorClass = require('create-error-class');\nvar duplexify = require('duplexify');\nvar ent = require('ent');\nvar extend = require('extend');\nvar format = require('string-format-obj');\nvar googleAuth = require('google-auto-auth');\nvar is = require('is');\nvar request = require('request').defaults({\n  timeout: 60000,\n  pool: {\n    maxSockets: Infinity\n  }\n});\nvar retryRequest = require('retry-request');\nvar streamEvents = require('stream-events');\nvar through = require('through2');\nvar uniq = require('array-uniq');\n\n/** @const {object} gcloud-node's package.json file. */\nvar PKG = require('../../package.json');\n\n/** @const {string} User agent. */\nvar USER_AGENT = 'gcloud-node/' + PKG.version;\n\nvar util = module.exports;\n\nvar errorMessage = format([\n  'Sorry, we cannot connect to Google Cloud Services without a project ID.',\n  'You may specify one with an environment variable named \"GCLOUD_PROJECT\".',\n  'See {baseUrl}/{path} for a detailed guide on creating an authenticated',\n  'connection.'\n].join(' '), {\n  baseUrl: 'https://googlecloudplatform.github.io/gcloud-node/#',\n  path: '/docs/guides/authentication'\n});\n\nvar missingProjectIdError = new Error(errorMessage);\n\nutil.missingProjectIdError = missingProjectIdError;\n\n/**\n * No op.\n *\n * @example\n * function doSomething(callback) {\n *   callback = callback || noop;\n * }\n */\nfunction noop() {}\n\nutil.noop = noop;\n\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\nvar ApiError = createErrorClass('ApiError', function(errorBody) {\n  this.code = errorBody.code;\n  this.errors = errorBody.errors;\n  this.response = errorBody.response;\n\n  try {\n    this.errors = JSON.parse(this.response.body).error.errors;\n  } catch (e) {}\n\n  var messages = [];\n\n  if (errorBody.message) {\n    messages.push(errorBody.message);\n  }\n\n  if (this.errors && this.errors.length === 1) {\n    messages.push(this.errors[0].message);\n  } else if (this.response && this.response.body) {\n    messages.push(ent.decode(errorBody.response.body.toString()));\n  } else if (!errorBody.message) {\n    messages.push('Error during request.');\n  }\n\n  this.message = uniq(messages).join(' - ');\n});\n\n/**\n * Wrap the ApiError constructor so context isn't lost.\n *\n * @param {object} errorBody - Error object.\n */\nutil.ApiError = function(errorBody) {\n  return new ApiError(errorBody);\n};\n\n/**\n * Uniformly process an API response.\n *\n * @param {*} err - Error value.\n * @param {*} resp - Response value.\n * @param {*} body - Body value.\n * @param {function} callback - The callback function.\n */\nfunction handleResp(err, resp, body, callback) {\n  callback = callback || noop;\n\n  var parsedResp = extend(\n    true,\n    { err: err || null },\n    resp && util.parseHttpRespMessage(resp),\n    body && util.parseHttpRespBody(body)\n  );\n\n  callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n}\n\nutil.handleResp = handleResp;\n\n/**\n * Sniff an incoming HTTP response message for errors.\n *\n * @param {object} httpRespMessage - An incoming HTTP response message from\n *     `request`.\n * @return {object} parsedHttpRespMessage - The parsed response.\n * @param {?error} parsedHttpRespMessage.err - An error detected.\n * @param {object} parsedHttpRespMessage.resp - The original response object.\n */\nfunction parseHttpRespMessage(httpRespMessage) {\n  var parsedHttpRespMessage = {\n    resp: httpRespMessage\n  };\n\n  if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n    // Unknown error. Format according to ApiError standard.\n    parsedHttpRespMessage.err = new util.ApiError({\n      errors: [],\n      code: httpRespMessage.statusCode,\n      message: httpRespMessage.statusMessage,\n      response: httpRespMessage\n    });\n  }\n\n  return parsedHttpRespMessage;\n}\n\nutil.parseHttpRespMessage = parseHttpRespMessage;\n\n/**\n * Parse the response body from an HTTP request.\n *\n * @param {object} body - The response body.\n * @return {object} parsedHttpRespMessage - The parsed response.\n * @param {?error} parsedHttpRespMessage.err - An error detected.\n * @param {object} parsedHttpRespMessage.body - The original body value provided\n *     will try to be JSON.parse'd. If it's successful, the parsed value will be\n *     returned here, otherwise the original value.\n */\nfunction parseHttpRespBody(body) {\n  var parsedHttpRespBody = {\n    body: body\n  };\n\n  if (is.string(body)) {\n    try {\n      parsedHttpRespBody.body = JSON.parse(body);\n    } catch(err) {}\n  }\n\n  if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n    // Error from JSON API.\n    parsedHttpRespBody.err = new util.ApiError(parsedHttpRespBody.body.error);\n  }\n\n  return parsedHttpRespBody;\n}\n\nutil.parseHttpRespBody = parseHttpRespBody;\n\n/**\n * Take a Duplexify stream, fetch an authenticated connection header, and create\n * an outgoing writable stream.\n *\n * @param {Duplexify} dup - Duplexify stream.\n * @param {object} options - Configuration object.\n * @param {module:common/connection} options.connection - A connection instance,\n *     used to get a token with and send the request through.\n * @param {object} options.metadata - Metadata to send at the head of the\n *     request.\n * @param {object} options.request - Request object, in the format of a standard\n *     Node.js http.request() object.\n * @param {string=} options.request.method - Default: \"POST\".\n * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n * @param {string=} options.streamContentType - Default:\n *     \"application/octet-stream\".\n * @param {function} onComplete - Callback, executed after the writable Request\n *     stream has completed.\n */\nfunction makeWritableStream(dup, options, onComplete) {\n  onComplete = onComplete || noop;\n  options = options || {};\n\n  var writeStream = through();\n  dup.setWritable(writeStream);\n\n  var defaultReqOpts = {\n    method: 'POST',\n    qs: {\n      uploadType: 'multipart'\n    }\n  };\n\n  var metadata = options.metadata || {};\n\n  var reqOpts = extend(true, defaultReqOpts, options.request, {\n    multipart: [\n      {\n        'Content-Type': 'application/json',\n        body: JSON.stringify(metadata)\n      },\n      {\n        'Content-Type': metadata.contentType || 'application/octet-stream',\n        body: writeStream\n      }\n    ]\n  });\n\n  options.makeAuthenticatedRequest(reqOpts, {\n    onAuthenticated: function(err, authenticatedReqOpts) {\n      if (err) {\n        dup.destroy(err);\n        return;\n      }\n\n      request(authenticatedReqOpts, function(err, resp, body) {\n        util.handleResp(err, resp, body, function(err, data) {\n          if (err) {\n            dup.destroy(err);\n            return;\n          }\n\n          dup.emit('response', resp);\n          onComplete(data);\n        });\n      });\n    }\n  });\n}\n\nutil.makeWritableStream = makeWritableStream;\n\n/**\n * Returns true if the API request should be retried, given the error that was\n * given the first time the request was attempted. This is used for rate limit\n * related errors as well as intermittent server errors.\n *\n * @param {error} err - The API error to check if it is appropriate to retry.\n * @return {boolean} True if the API request should be retried, false otherwise.\n */\nfunction shouldRetryRequest(err) {\n  if (err) {\n    if ([429, 500, 502, 503].indexOf(err.code) !== -1) {\n      return true;\n    }\n\n    if (err.errors) {\n      for (var i in err.errors) {\n        var reason = err.errors[i].reason;\n        if (reason === 'rateLimitExceeded') {\n          return true;\n        }\n        if (reason === 'userRateLimitExceeded') {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nutil.shouldRetryRequest = shouldRetryRequest;\n\n/**\n * Get a function for making authenticated requests.\n *\n * @param {object} config - Configuration object.\n * @param {boolean=} config.autoRetry - Automatically retry requests if the\n *     response is related to rate limits or certain intermittent server errors.\n *     We will exponentially backoff subsequent requests by default. (default:\n *     true)\n * @param {object=} config.credentials - Credentials object.\n * @param {boolean=} config.customEndpoint - If true, just return the provided\n *     request options. Default: false.\n * @param {string=} config.email - Account email address, required for PEM/P12\n *     usage.\n * @param {number=} config.maxRetries - Maximum number of automatic retries\n *     attempted before returning the error. (default: 3)\n * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n * @param {array} config.scopes - Array of scopes required for the API.\n */\nfunction makeAuthenticatedRequestFactory(config) {\n  config = config || {};\n\n  var authClient = googleAuth(config);\n\n  /**\n   * The returned function that will make an authenticated request.\n   *\n   * @param {type} reqOpts - Request options in the format `request` expects.\n   * @param {object|function} options - Configuration object or callback\n   *     function.\n   * @param {function=} options.onAuthenticated - If provided, a request will\n   *     not be made. Instead, this function is passed the error & authenticated\n   *     request options.\n   */\n  function makeAuthenticatedRequest(reqOpts, options) {\n    var stream;\n    var reqConfig = extend({}, config);\n    var activeRequest_;\n\n    if (!options) {\n      stream = duplexify();\n      reqConfig.stream = stream;\n    }\n\n    function onAuthenticated(err, authenticatedReqOpts) {\n      if (err) {\n        if (stream) {\n          stream.destroy(err);\n        } else {\n          (options.onAuthenticated || options)(err);\n        }\n\n        return;\n      }\n\n      authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts);\n\n      if (options && options.onAuthenticated) {\n        options.onAuthenticated(null, authenticatedReqOpts);\n      } else {\n        activeRequest_ =\n          util.makeRequest(authenticatedReqOpts, reqConfig, options);\n      }\n    }\n\n    if (reqConfig.customEndpoint) {\n      // Using a custom API override. Do not use `google-auto-auth` for\n      // authentication. (ex: connecting to a local Datastore server)\n      onAuthenticated(null, reqOpts);\n    } else {\n      authClient.authorizeRequest(reqOpts, onAuthenticated);\n    }\n\n    if (stream) {\n      return stream;\n    }\n\n    return {\n      abort: function() {\n        if (activeRequest_) {\n          activeRequest_.abort();\n          activeRequest_ = null;\n        }\n      }\n    };\n  }\n\n  makeAuthenticatedRequest.getCredentials =\n    authClient.getCredentials.bind(authClient);\n\n  makeAuthenticatedRequest.authClient = authClient;\n\n  return makeAuthenticatedRequest;\n}\n\nutil.makeAuthenticatedRequestFactory = makeAuthenticatedRequestFactory;\n\n/**\n * Make a request through the `retryRequest` module with built-in error handling\n * and exponential back off.\n *\n * @param {object} reqOpts - Request options in the format `request` expects.\n * @param {object=} config - Configuration object.\n * @param {boolean=} config.autoRetry - Automatically retry requests if the\n *     response is related to rate limits or certain intermittent server errors.\n *     We will exponentially backoff subsequent requests by default. (default:\n *     true)\n * @param {number=} config.maxRetries - Maximum number of automatic retries\n *     attempted before returning the error. (default: 3)\n * @param {function} callback - The callback function.\n */\nfunction makeRequest(reqOpts, config, callback) {\n  if (is.fn(config)) {\n    callback = config;\n    config = {};\n  }\n\n  config = config || {};\n\n  var options = {\n    request: request,\n\n    retries: config.autoRetry !== false ? config.maxRetries || 3 : 0,\n\n    shouldRetryFn: function(httpRespMessage) {\n      var err = util.parseHttpRespMessage(httpRespMessage).err;\n      return err && util.shouldRetryRequest(err);\n    }\n  };\n\n  if (config.stream) {\n    var dup = config.stream;\n    var requestStream;\n    var isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n\n    if (isGetRequest) {\n      requestStream = retryRequest(reqOpts, options);\n      dup.setReadable(requestStream);\n    } else {\n      // Streaming writable HTTP requests cannot be retried.\n      requestStream = request(reqOpts);\n      dup.setWritable(requestStream);\n    }\n\n    // Replay the Request events back to the stream.\n    requestStream.on('error', dup.destroy.bind(dup))\n      .on('response', dup.emit.bind(dup, 'response'))\n      .on('complete', dup.emit.bind(dup, 'complete'));\n\n    dup.abort = requestStream.abort;\n  } else {\n    return retryRequest(reqOpts, options, function(err, response, body) {\n      util.handleResp(err, response, body, callback);\n    });\n  }\n}\n\nutil.makeRequest = makeRequest;\n\n/**\n * Decorate the options about to be made in a request.\n *\n * @param {object} reqOpts - The options to be passed to `request`.\n * @return {object} reqOpts - The decorated reqOpts.\n */\nfunction decorateRequest(reqOpts) {\n  reqOpts.headers = reqOpts.headers || {};\n  reqOpts.headers['User-Agent'] = USER_AGENT;\n\n  if (is.object(reqOpts.qs)) {\n    delete reqOpts.qs.autoPaginate;\n    delete reqOpts.qs.autoPaginateVal;\n  }\n\n  if (is.object(reqOpts.json)) {\n    delete reqOpts.json.autoPaginate;\n    delete reqOpts.json.autoPaginateVal;\n  }\n\n  return reqOpts;\n}\n\nutil.decorateRequest = decorateRequest;\n\n/**\n * Extend a global configuration object with user options provided at the time\n * of sub-module instantiation.\n *\n * Connection details currently come in two ways: `credentials` or\n * `keyFilename`. Because of this, we have a special exception when overriding a\n * global configuration object. If a user provides either to the global\n * configuration, then provides another at submodule instantiation-time, the\n * latter is preferred.\n *\n * @param  {object} globalConfig - The global configuration object.\n * @param  {object=} overrides - The instantiation-time configuration object.\n * @return {object}\n */\nfunction extendGlobalConfig(globalConfig, overrides) {\n  globalConfig = globalConfig || {};\n  overrides = overrides || {};\n\n  var defaultConfig = {};\n\n  if (process.env.GCLOUD_PROJECT) {\n    defaultConfig.projectId = process.env.GCLOUD_PROJECT;\n  }\n\n  var options = extend({}, globalConfig);\n\n  var hasGlobalConnection = options.credentials || options.keyFilename;\n  var isOverridingConnection = overrides.credentials || overrides.keyFilename;\n\n  if (hasGlobalConnection && isOverridingConnection) {\n    delete options.credentials;\n    delete options.keyFilename;\n  }\n\n  var extendedConfig = extend(true, defaultConfig, options, overrides);\n\n  // Preserve the original (not cloned) interceptors.\n  extendedConfig.interceptors_ = globalConfig.interceptors_;\n\n  return extendedConfig;\n}\n\nutil.extendGlobalConfig = extendGlobalConfig;\n\n/**\n * Merge and validate API configurations.\n *\n * @throws {Error} If a projectId is not specified.\n *\n * @param {object} globalContext - gcloud-level context.\n * @param {object} globalContext.config_ - gcloud-level configuration.\n * @param {object} localConfig - Service-level configurations.\n * @param {object=} options - Configuration object.\n * @param {boolean} options.projectIdRequired - Whether to throw if a project ID\n *     is required, but not provided by the user. (Default: true)\n * @return {object} config - Merged and validated configuration.\n */\nfunction normalizeArguments(globalContext, localConfig, options) {\n  options = options || {};\n\n  var config = util.extendGlobalConfig(globalContext.config_, localConfig);\n\n  if (options.projectIdRequired !== false && !config.projectId) {\n    throw util.missingProjectIdError;\n  }\n\n  return config;\n}\n\nutil.normalizeArguments = normalizeArguments;\n\n/**\n * Limit requests according to a `maxApiCalls` limit.\n *\n * @param {function} makeRequestFn - The function that will be called.\n * @param {object=} options - Configuration object.\n * @param {number} options.maxApiCalls - The maximum number of API calls to\n *     make.\n */\nfunction createLimiter(makeRequestFn, options) {\n  var stream = streamEvents(through.obj());\n\n  var requestsMade = 0;\n  var requestsToMake = -1;\n\n  options = options || {};\n\n  if (is.number(options.maxApiCalls)) {\n    requestsToMake = options.maxApiCalls;\n  }\n\n  return {\n    makeRequest: function() {\n      requestsMade++;\n\n      if (requestsToMake >= 0 && requestsMade > requestsToMake) {\n        stream.push(null);\n        return;\n      }\n\n      makeRequestFn.apply(null, arguments);\n\n      return stream;\n    },\n\n    stream: stream\n  };\n}\n\nutil.createLimiter = createLimiter;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/common/stream-router.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module common/stream-router\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar concat = require('concat-stream');\nvar extend = require('extend');\nvar is = require('is');\nvar split = require('split-array-stream');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('./util.js');\n\n/*! Developer Documentation\n *\n * streamRouter is used to extend `nextQuery`+callback methods with stream\n * functionality.\n *\n * Before:\n *\n *   search.query('done=true', function(err, results, nextQuery) {});\n *\n * After:\n *\n *   search.query('done=true').on('data', function(result) {});\n *\n * Methods to extend should be written to accept callbacks and return a\n * `nextQuery`. All stream logic is handled in `streamRouter.router_`.\n */\nvar streamRouter = {};\n\n/**\n * Cache the original method, then overwrite it on the Class's prototype.\n *\n * @param {function} Class - The parent class of the methods to extend.\n * @param {array|string} methodNames - Name(s) of the methods to extend.\n */\nstreamRouter.extend = function(Class, methodNames) {\n  methodNames = arrify(methodNames);\n\n  methodNames.forEach(function(methodName) {\n    var originalMethod = Class.prototype[methodName];\n\n    Class.prototype[methodName] = function() {\n      var parsedArguments = streamRouter.parseArguments_(arguments);\n      return streamRouter.router_(parsedArguments, originalMethod.bind(this));\n    };\n  });\n};\n\n/**\n * Parse a pseudo-array `arguments` for a query and callback.\n *\n * @param {array} args - The original `arguments` pseduo-array that the original\n *     method received.\n */\nstreamRouter.parseArguments_ = function(args) {\n  var query;\n  var autoPaginate = true;\n  var maxApiCalls = -1;\n  var maxResults = -1;\n  var callback;\n\n  var firstArgument = args[0];\n  var lastArgument = args[args.length - 1];\n\n  if (is.fn(firstArgument)) {\n    callback = firstArgument;\n  } else {\n    query = firstArgument;\n  }\n\n  if (is.fn(lastArgument)) {\n    callback = lastArgument;\n  }\n\n  if (is.object(query)) {\n    query = extend(true, {}, query);\n\n    // Check if the user only asked for a certain amount of results.\n    if (is.number(query.maxResults)) {\n      // `maxResults` is used API-wide.\n      maxResults = query.maxResults;\n    } else if (is.number(query.pageSize)) {\n      // `pageSize` is Pub/Sub's `maxResults`.\n      maxResults = query.pageSize;\n    }\n\n    if (is.number(query.maxApiCalls)) {\n      maxApiCalls = query.maxApiCalls;\n      delete query.maxApiCalls;\n    }\n\n    if (callback &&\n        (maxResults !== -1 || // The user specified a limit.\n        query.autoPaginate === false)) {\n      autoPaginate = false;\n    }\n  }\n\n  return {\n    query: query || {},\n    autoPaginate: autoPaginate,\n    maxApiCalls: maxApiCalls,\n    maxResults: maxResults,\n    callback: callback\n  };\n};\n\n/**\n * The router accepts a query and callback that were passed to the overwritten\n * method. If there's a callback, simply pass the query and/or callback through\n * to the original method. If there isn't a callback. stream mode is activated.\n *\n * @param {array} parsedArguments - Parsed arguments from the original method\n *     call.\n * @param {object=|string=} parsedArguments.query - Query object. This is most\n *     commonly an object, but to make the API more simple, it can also be a\n *     string in some places.\n * @param {function=} parsedArguments.callback - Callback function.\n * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n * @param {number} parsedArguments.maxResults - Maximum results to return.\n * @param {function} originalMethod - The cached method that accepts a callback\n *     and returns `nextQuery` to receive more results.\n * @return {undefined|stream}\n */\nstreamRouter.router_ = function(parsedArguments, originalMethod) {\n  var query = parsedArguments.query;\n  var callback = parsedArguments.callback;\n  var autoPaginate = parsedArguments.autoPaginate;\n\n  if (callback) {\n    if (autoPaginate) {\n      this.runAsStream_(parsedArguments, originalMethod)\n        .on('error', callback)\n        .pipe(concat(function(results) {\n          callback(null, results);\n        }));\n    } else {\n      originalMethod(query, callback);\n    }\n  } else {\n    return this.runAsStream_(parsedArguments, originalMethod);\n  }\n};\n\n/**\n * This method simply calls the nextQuery recursively, emitting results to a\n * stream. The stream ends when `nextQuery` is null.\n *\n * `maxResults` will act as a cap for how many results are fetched and emitted\n * to the stream.\n *\n * @param {object=|string=} parsedArguments.query - Query object. This is most\n *     commonly an object, but to make the API more simple, it can also be a\n *     string in some places.\n * @param {function=} parsedArguments.callback - Callback function.\n * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n * @param {number} parsedArguments.maxResults - Maximum results to return.\n * @param {function} originalMethod - The cached method that accepts a callback\n *     and returns `nextQuery` to receive more results.\n * @return {stream} - Readable object stream.\n */\nstreamRouter.runAsStream_ = function(parsedArguments, originalMethod) {\n  var query = parsedArguments.query;\n  var resultsToSend = parsedArguments.maxResults;\n\n  var limiter = util.createLimiter(makeRequest, {\n    maxApiCalls: parsedArguments.maxApiCalls\n  });\n\n  var stream = limiter.stream;\n\n  stream.once('reading', function() {\n    makeRequest(query);\n  });\n\n  function makeRequest(query) {\n    originalMethod(query, onResultSet);\n  }\n\n  function onResultSet(err, results, nextQuery) {\n    if (err) {\n      stream.destroy(err);\n      return;\n    }\n\n    if (resultsToSend >= 0 && results.length > resultsToSend) {\n      results = results.splice(0, resultsToSend);\n    }\n\n    resultsToSend -= results.length;\n\n    split(results, stream, function(streamEnded) {\n      if (streamEnded) {\n        return;\n      }\n\n      if (nextQuery && resultsToSend !== 0) {\n        limiter.makeRequest(nextQuery);\n        return;\n      }\n\n      stream.push(null);\n    });\n  }\n\n  return limiter.stream;\n};\n\nmodule.exports = streamRouter;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/bigquery/table.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module bigquery/table\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar duplexify = require('duplexify');\nvar extend = require('extend');\nvar format = require('string-format-obj');\nvar fs = require('fs');\nvar is = require('is');\nvar nodeutil = require('util');\nvar path = require('path');\nvar streamEvents = require('stream-events');\n\n/**\n * @type {module:storage/file}\n * @private\n */\nvar File = require('../storage/file.js');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * The file formats accepted by BigQuery.\n *\n * @type {object}\n * @private\n */\nvar FORMATS = {\n  avro: 'AVRO',\n  csv: 'CSV',\n  json: 'NEWLINE_DELIMITED_JSON'\n};\n\n/*! Developer Documentation\n *\n * @param {module:bigquery/dataset} dataset - Dataset instance.\n * @param {string} id - The ID of the table.\n *\n * @example\n * var bigquery = gcloud.bigquery({ projectId: 'grape-spaceship-123' });\n * var Dataset = require('gcloud/lib/bigquery/dataset');\n * var dataset = new Dataset(bigquery, 'dataset-id');\n * var Table = require('gcloud/lib/bigquery/table');\n * var table = new Table(dataset, 'table-id');\n */\n/**\n * Table objects are returned by methods such as\n * {module:bigquery/dataset#table}, {module:bigquery/dataset#createTable}, and\n * {module:bigquery/dataset#getTables}.\n *\n * @alias module:bigquery/table\n * @constructor\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var bigquery = gcloud.bigquery();\n *\n * var dataset = bigquery.dataset('my-dataset');\n *\n * var table = dataset.table('my-table');\n */\nfunction Table(dataset, id) {\n  var methods = {\n    /**\n     * Create a table.\n     *\n     * @param {object=} options - See {module:bigquery/dataset#createTable}.\n     *\n     * @example\n     * table.create(function(err, table, apiResponse) {\n     *   if (!err) {\n     *     // The table was created successfully.\n     *   }\n     * });\n     */\n    create: true,\n\n    /**\n     * Delete a table and all its data.\n     *\n     * @resource [Tables: delete API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/tables/delete}\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * table.delete(function(err, apiResponse) {});\n     */\n    delete: true,\n\n    /**\n     * Check if the table exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the table exists or not.\n     *\n     * @example\n     * table.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a table if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * table.get(function(err, table, apiResponse) {\n     *   // `table.metadata` has been populated.\n     * });\n     */\n    get: true,\n\n    /**\n     * Return the metadata associated with the Table.\n     *\n     * @resource [Tables: get API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/tables/get}\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The metadata of the Table.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * table.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: dataset,\n    baseUrl: '/tables',\n    id: id,\n    createMethod: dataset.createTable.bind(dataset),\n    methods: methods\n  });\n\n  this.bigQuery = dataset.bigQuery;\n  this.dataset = dataset;\n}\n\nnodeutil.inherits(Table, ServiceObject);\n\n/**\n * Convert a comma-separated name:type string to a table schema object.\n *\n * @static\n * @private\n *\n * @param {string} str - Comma-separated schema string.\n * @return {object} Table schema in the format the API expects.\n */\nTable.createSchemaFromString_ = function(str) {\n  return str.split(/\\s*,\\s*/).reduce(function(acc, pair) {\n    acc.fields.push({\n      name: pair.split(':')[0],\n      type: (pair.split(':')[1] || 'STRING').toUpperCase()\n    });\n\n    return acc;\n  }, {\n    fields: []\n  });\n};\n\n/**\n * Merge a rowset returned from the API with a table schema.\n *\n * @static\n * @private\n *\n * @param {object} schema\n * @param {array} rows\n * @return {array} Fields using their matching names from the table's schema.\n */\nTable.mergeSchemaWithRows_ = function(schema, rows) {\n  return rows.map(mergeSchema).map(flattenRows);\n\n  function mergeSchema(row) {\n    return row.f.map(function(field, index) {\n      var schemaField = schema.fields[index];\n      var value = field.v;\n\n      switch (schemaField.type) {\n        case 'BOOLEAN': {\n          value = value === 'true';\n          break;\n        }\n        case 'FLOAT': {\n          if (!is.nil(value)) {\n            value = parseFloat(value);\n          }\n          break;\n        }\n        case 'INTEGER': {\n          if (!is.nil(value)) {\n            value = parseInt(value, 10);\n          }\n          break;\n        }\n        case 'TIMESTAMP': {\n          value = new Date(value * 1000);\n          break;\n        }\n      }\n\n      var fieldObject = {};\n      fieldObject[schemaField.name] = value;\n      return fieldObject;\n    });\n  }\n\n  function flattenRows(rows) {\n    return rows.reduce(function(acc, row) {\n      var key = Object.keys(row)[0];\n      acc[key] = row[key];\n      return acc;\n    }, {});\n  }\n};\n\n/**\n * Copy data from one table to another, optionally creating that table.\n *\n * @resource [Jobs: insert API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/insert}\n *\n * @param {module:bigquery/table} destination - The destination table.\n * @param {object=} metadata - Metadata to set with the copy operation. The\n *     metadata object should be in the format of the\n *     [`configuration.copy`](http://goo.gl/dKWIyS) property of a Jobs resource.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:bigquery/job} callback.job - The job used to copy your table.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @throws {Error} If a destination other than a Table object is provided.\n *\n * @example\n * var yourTable = dataset.table('your-table');\n * table.copy(yourTable, function(err, job, apiResponse) {\n *   // `job` is a Job object that can be used to check the status of the\n *   // request.\n * });\n *\n * //-\n * // See the [`configuration.copy`](http://goo.gl/dKWIyS) object for all\n * // available options.\n * //-\n * var metadata = {\n *   createDisposition: 'CREATE_NEVER',\n *   writeDisposition: 'WRITE_TRUNCATE'\n * };\n *\n * table.copy(yourTable, metadata, function(err, job, apiResponse) {});\n */\nTable.prototype.copy = function(destination, metadata, callback) {\n  var self = this;\n\n  if (!(destination instanceof Table)) {\n    throw new Error('Destination must be a Table object.');\n  }\n\n  if (is.fn(metadata)) {\n    callback = metadata;\n    metadata = {};\n  }\n\n  var body = {\n    configuration: {\n      copy: extend(true, metadata || {}, {\n        destinationTable: {\n          datasetId: destination.dataset.id,\n          projectId: destination.bigQuery.projectId,\n          tableId: destination.id\n        },\n        sourceTable: {\n          datasetId: this.dataset.id,\n          projectId: this.bigQuery.projectId,\n          tableId: this.id\n        }\n      })\n    }\n  };\n\n  this.bigQuery.request({\n    method: 'POST',\n    uri: '/jobs',\n    json: body,\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var job = self.bigQuery.job(resp.jobReference.jobId);\n    job.metadata = resp;\n\n    callback(null, job, resp);\n  });\n};\n\n/**\n * Create a readable stream of the rows of data in your table. This method is\n * simply a wrapper around {module:bigquery/table#getRows}.\n *\n * @resource [Tabledata: list API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/tabledata/list}\n *\n * @return {ReadableStream}\n *\n * @example\n * var through2 = require('through2');\n * var fs = require('fs');\n *\n * table.createReadStream()\n *   .pipe(through2.obj(function(row, enc, next) {\n *     this.push(JSON.stringify(row) + '\\n');\n *   }))\n *   .pipe(fs.createWriteStream('./test/testdata/testfile.json'));\n */\nTable.prototype.createReadStream = function() {\n  return this.getRows();\n};\n\n/**\n * Load data into your table from a readable stream of JSON, CSV, or\n * AVRO data.\n *\n * @resource [Jobs: insert API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/insert}\n *\n * @param {string|object=} metadata - Metadata to set with the load operation.\n *     The metadata object should be in the format of the\n *     [`configuration.load`](http://goo.gl/BVcXk4) property of a Jobs resource.\n *     If a string is given, it will be used as the filetype.\n * @return {WritableStream}\n *\n * @throws {Error} If source format isn't recognized.\n *\n * @example\n * //-\n * // Load data from a CSV file.\n * //-\n * var request = require('request');\n *\n * var csvUrl = 'http://goo.gl/kSE7z6';\n *\n * var metadata = {\n *   allowJaggedRows: true,\n *   skipLeadingRows: 1\n * };\n *\n * request.get(csvUrl)\n *   .pipe(table.createWriteStream(metadata))\n *   .on('complete', function(job) {\n *     // `job` is a Job object that can be used to check the status of the\n *     // request.\n *   });\n *\n * //-\n * // Load data from a JSON file.\n * //-\n * var fs = require('fs');\n *\n * fs.createReadStream('./test/testdata/testfile.json')\n *   .pipe(table.createWriteStream('json'))\n *   .on('complete', function(job) {});\n */\nTable.prototype.createWriteStream = function(metadata) {\n  var self = this;\n\n  metadata = metadata || {};\n\n  var fileTypes = Object.keys(FORMATS).map(function(key) {\n    return FORMATS[key];\n  });\n\n  if (is.string(metadata)) {\n    metadata = {\n      sourceFormat: FORMATS[metadata.toLowerCase()]\n    };\n  }\n\n  if (is.string(metadata.schema)) {\n    metadata.schema = Table.createSchemaFromString_(metadata.schema);\n  }\n\n  extend(true, metadata, {\n    destinationTable: {\n      projectId: self.bigQuery.projectId,\n      datasetId: self.dataset.id,\n      tableId: self.id\n    }\n  });\n\n  if (metadata.hasOwnProperty('sourceFormat') &&\n      fileTypes.indexOf(metadata.sourceFormat) < 0) {\n    throw new Error('Source format not recognized: ' + metadata.sourceFormat);\n  }\n\n  var dup = streamEvents(duplexify());\n\n  dup.once('writing', function() {\n    util.makeWritableStream(dup, {\n      makeAuthenticatedRequest: self.bigQuery.makeAuthenticatedRequest,\n      metadata: {\n        configuration: {\n          load: metadata\n        }\n      },\n      request: {\n        uri: format('{base}/{projectId}/jobs', {\n          base: 'https://www.googleapis.com/upload/bigquery/v2/projects',\n          projectId: self.bigQuery.projectId\n        })\n      }\n    }, function(data) {\n      var job = self.bigQuery.job(data.jobReference.jobId);\n      job.metadata = data;\n\n      dup.emit('complete', job);\n    });\n  });\n\n  return dup;\n};\n\n/**\n * Export table to Google Cloud Storage.\n *\n * @resource [Jobs: insert API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/insert}\n *\n * @param {module:storage/file} destination - Where the file should be exported\n *     to.\n * @param {object=} options - The configuration object.\n * @param {string} options.format - The format to export the data in. Allowed\n *     options are \"CSV\", \"JSON\", or \"AVRO\". Default: \"CSV\".\n * @param {boolean} options.gzip - Specify if you would like the file compressed\n *     with GZIP. Default: false.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:bigquery/job} callback.job - The job used to export the table.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @throws {Error} If destination isn't a File object.\n * @throws {Error} If destination format isn't recongized.\n *\n * @example\n * var gcs = gcloud.storage({\n *   projectId: 'grape-spaceship-123'\n * });\n * var exportedFile = gcs.bucket('institutions').file('2014.csv');\n *\n * //-\n * // To use the default options, just pass a {module:storage/file} object.\n * //\n * // Note: The exported format type will be inferred by the file's extension.\n * // If you wish to override this, or provide an array of destination files,\n * // you must provide an `options` object.\n * //-\n * table.export(exportedFile, function(err, job, apiResponse) {\n *   // `job` is a Job object that can be used to check the status of the\n *   // request.\n * });\n *\n * //-\n * // If you need more customization, pass an `options` object.\n * //-\n * var options = {\n *   format: 'json',\n *   gzip: true\n * };\n *\n * table.export(exportedFile, options, function(err, job, apiResponse) {});\n *\n * //-\n * // You can also specify multiple destination files.\n * //-\n * table.export([\n *   gcs.bucket('institutions').file('2014.json'),\n *   gcs.bucket('institutions-copy').file('2014.json')\n * ], options, function(err, job, apiResponse) {});\n */\nTable.prototype.export = function(destination, options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  extend(true, options, {\n    destinationUris: arrify(destination).map(function(dest) {\n      if (!(dest instanceof File)) {\n        throw new Error('Destination must be a File object.');\n      }\n\n      // If no explicit format was provided, attempt to find a match from the\n      // file's extension. If no match, don't set, and default upstream to CSV.\n      var format = path.extname(dest.name).substr(1).toLowerCase();\n      if (!options.destinationFormat && !options.format && FORMATS[format]) {\n        options.destinationFormat = FORMATS[format];\n      }\n\n      return 'gs://' + dest.bucket.name + '/' + dest.name;\n    })\n  });\n\n  if (options.format) {\n    options.format = options.format.toLowerCase();\n\n    if (FORMATS[options.format]) {\n      options.destinationFormat = FORMATS[options.format];\n      delete options.format;\n    } else {\n      throw new Error('Destination format not recognized: ' + options.format);\n    }\n  }\n\n  if (options.gzip) {\n    options.compression = 'GZIP';\n    delete options.gzip;\n  }\n\n  var body = {\n    configuration: {\n      extract: extend(true, options, {\n        sourceTable: {\n          datasetId: this.dataset.id,\n          projectId: this.bigQuery.projectId,\n          tableId: this.id\n        }\n      })\n    }\n  };\n\n  this.bigQuery.request({\n    method: 'POST',\n    uri: '/jobs',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var job = self.bigQuery.job(resp.jobReference.jobId);\n    job.metadata = resp;\n\n    callback(null, job, resp);\n  });\n};\n\n/**\n * Retrieves table data from a specified set of rows. The rows are returned to\n * your callback as an array of objects matching your table's schema.\n *\n * @resource [Tabledata: list API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/tabledata/list}\n *\n * @param {object=} options - The configuration object.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of results to return.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {array} callback.rows - The table data from specified set of rows.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * table.getRows(function(err, rows) {\n *   if (!err) {\n *     // Handle results here.\n *   }\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * var callback = function(err, rows, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     table.getRows(nextQuery, callback);\n *   }\n * };\n *\n * table.getRows({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the rows as a readable object stream.\n * //-\n * table.getRows(options)\n *   .on('error', console.error)\n *   .on('data', function(row) {})\n *   .on('end', function() {\n *     // All rows have been retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * table.getRows()\n *   .on('data', function(row) {\n *     this.end();\n *   });\n */\nTable.prototype.getRows = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  callback = callback || util.noop;\n\n  this.request({\n    uri: '/data',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      onComplete(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.pageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.pageToken\n      });\n    }\n\n    if (resp.rows && resp.rows.length > 0 && !self.metadata.schema) {\n      // We don't know the schema for this table yet. Do a quick stat.\n      self.getMetadata(function(err, metadata, apiResponse) {\n        if (err) {\n          onComplete(err, null, null, apiResponse);\n          return;\n        }\n\n        onComplete(null, resp.rows, nextQuery, resp);\n      });\n\n      return;\n    }\n\n    onComplete(null, resp.rows, nextQuery, resp);\n  });\n\n  function onComplete(err, rows, nextQuery, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    rows = Table.mergeSchemaWithRows_(self.metadata.schema, rows || []);\n\n    callback(null, rows, nextQuery, resp);\n  }\n};\n\n/**\n * Load data from a local file or Storage file ({module:storage/file}).\n *\n * By loading data this way, you create a load job that will run your data load\n * asynchronously. If you would like instantaneous access to your data, insert\n * it using {module:bigquery/table#insert}.\n *\n * Note: The file type will be inferred by the given file's extension. If you\n * wish to override this, you must provide `metadata.format`.\n *\n * @resource [Jobs: insert API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/insert}\n *\n * @param {string|module:storage/file} source - The source file to import.\n * @param {object=} metadata - Metadata to set with the load operation. The\n *     metadata object should be in the format of the\n *     [`configuration.load`](http://goo.gl/BVcXk4) property of a Jobs resource.\n * @param {string} metadata.format - The format the data being imported is in.\n *     Allowed options are \"CSV\", \"JSON\", or \"AVRO\".\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:bigquery/job} callback.job - The job used to import your data.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @throws {Error} If the source isn't a string file name or a File instance.\n *\n * @example\n * //-\n * // Load data from a local file.\n * //-\n * table.import('./institutions.csv', function(err, job, apiResponse) {\n *   // `job` is a Job object that can be used to check the status of the\n *   // request.\n * });\n *\n * //-\n * // You may also pass in metadata in the format of a Jobs resource. See\n * // (http://goo.gl/BVcXk4) for a full list of supported values.\n * //-\n * var metadata = {\n *   encoding: 'ISO-8859-1',\n *   sourceFormat: 'NEWLINE_DELIMITED_JSON'\n * };\n *\n * table.import('./my-data.csv', metadata, function(err, job, apiResponse) {});\n *\n * //-\n * // Load data from a file in your Cloud Storage bucket.\n * //-\n * var data = gcs.bucket('institutions').file('data.csv');\n * table.import(data, function(err, job, apiResponse) {});\n *\n * //-\n * // Load data from multiple files in your Cloud Storage bucket(s).\n * //-\n * table.import([\n *   gcs.bucket('institutions').file('2011.csv'),\n *   gcs.bucket('institutions').file('2012.csv')\n * ], function(err, job, apiResponse) {});\n */\nTable.prototype.import = function(source, metadata, callback) {\n  var self = this;\n\n  if (is.fn(metadata)) {\n    callback = metadata;\n    metadata = {};\n  }\n\n  callback = callback || util.noop;\n  metadata = metadata || {};\n\n  var format = metadata.sourceFormat || metadata.format;\n  if (format) {\n    metadata.sourceFormat = FORMATS[format.toLowerCase()];\n    delete metadata.format;\n  }\n\n  if (is.string(source)) {\n    // A path to a file was given. If a sourceFormat wasn't specified, try to\n    // find a match from the file's extension.\n    var detectedFormat = FORMATS[path.extname(source).substr(1).toLowerCase()];\n    if (!metadata.sourceFormat && detectedFormat) {\n      metadata.sourceFormat = detectedFormat;\n    }\n\n    // Read the file into a new write stream.\n    return fs.createReadStream(source)\n      .pipe(this.createWriteStream(metadata))\n      .on('error', callback)\n      .on('complete', function(resp) {\n        // TODO(ryanseys): Does this have to create a job object?\n        callback(null, resp, resp);\n      });\n  }\n\n  var body = {\n    configuration: {\n      load: {\n        destinationTable: {\n          projectId: this.bigQuery.projectId,\n          datasetId: this.dataset.id,\n          tableId: this.id\n        }\n      }\n    }\n  };\n\n  extend(true, body.configuration.load, metadata, {\n    sourceUris: arrify(source).map(function(src) {\n      if (!(src instanceof File)) {\n        throw new Error('Source must be a File object.');\n      }\n\n      // If no explicit format was provided, attempt to find a match from\n      // the file's extension. If no match, don't set, and default upstream\n      // to CSV.\n      var format = FORMATS[path.extname(src.name).substr(1).toLowerCase()];\n      if (!metadata.sourceFormat && format) {\n        body.configuration.load.sourceFormat = format;\n      }\n\n      return 'gs://' + src.bucket.name + '/' + src.name;\n    })\n  });\n\n  this.bigQuery.request({\n    method: 'POST',\n    uri: '/jobs',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var job = self.bigQuery.job(resp.jobReference.jobId);\n    job.metadata = resp;\n\n    callback(null, job, resp);\n  });\n};\n\n/**\n * Stream data into BigQuery one record at a time without running a load job.\n *\n * There are more strict quota limits using this method so it is highly\n * recommended that you load data into BigQuery using\n * {module:bigquery/table#import} instead.\n *\n * @resource [Tabledata: insertAll API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/tabledata/insertAll}\n *\n * @param {object|object[]} rows - The rows to insert into the table.\n * @param {object=} options - Configuration object.\n * @param {boolean} options.ignoreUnknownValues - Accept rows that contain\n *     values that do not match the schema. The unknown values are ignored.\n *     Default: `false`.\n * @param {boolean} options.raw - If `true`, the `rows` argument is expected to\n *     be formatted as according to the\n *     [specification](https://cloud.google.com/bigquery/docs/reference/v2/tabledata/insertAll).\n * @param {boolean} options.skipInvalidRows - Insert all valid rows of a\n *     request, even if invalid rows exist. Default: `false`.\n * @param {string} options.templateSuffix - Treat the destination table as a\n *     base template, and insert the rows into an instance table named\n *     \"{destination}{templateSuffix}\". BigQuery will manage creation of\n *     the instance table, using the schema of the base template table. See\n *     [Automatic table creation using template tables](https://cloud.google.com/bigquery/streaming-data-into-bigquery#template-tables)\n *     for considerations when working with templates tables.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {array} callback.insertErrors - A list of errors for insert failures.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // Insert a single row.\n * //-\n * table.insert({\n *   INSTNM: 'Motion Picture Institute of Michigan',\n *   CITY: 'Troy',\n *   STABBR: 'MI'\n * }, insertHandler);\n *\n * //-\n * // Insert multiple rows at a time.\n * //-\n * var rows = [\n *   {\n *     INSTNM: 'Motion Picture Institute of Michigan',\n *     CITY: 'Troy',\n *     STABBR: 'MI'\n *   },\n *   // ...\n * ];\n *\n * table.insert(rows, insertHandler);\n *\n * //-\n * // Insert a row as according to the <a href=\"https://cloud.google.com/bigquery/docs/reference/v2/tabledata/insertAll\">\n * // specification</a>.\n * //-\n * var row = {\n *   insertId: '1',\n *   json: {\n *     INSTNM: 'Motion Picture Institute of Michigan',\n *     CITY: 'Troy',\n *     STABBR: 'MI'\n *   }\n * };\n *\n * var options = {\n *   raw: true\n * };\n *\n * table.insert(row, options, insertHandler);\n *\n * //-\n * // Handling the response.\n * //-\n * function insertHandler(err, insertErrors, apiResponse) {\n *   // err (object):\n *   //   An API error occurred.\n *\n *   // insertErrors (object[]):\n *   //   If populated, some rows failed to insert, while others may have\n *   //   succeeded.\n *   //\n *   // insertErrors[].row (original individual row object passed to `insert`)\n *   // insertErrors[].errors[].reason\n *   // insertErrors[].errors[].message\n *\n *   // See https://developers.google.com/bigquery/troubleshooting-errors for\n *   // recommendations on handling errors.\n * }\n */\nTable.prototype.insert = function(rows, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var json = extend(true, options, {\n    rows: arrify(rows)\n  });\n\n  if (!options.raw) {\n    json.rows = arrify(rows).map(function(row) {\n      return {\n        json: row\n      };\n    });\n  }\n\n  delete options.raw;\n\n  this.request({\n    method: 'POST',\n    uri: '/insertAll',\n    json: json\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var failedToInsert = (resp.insertErrors || []).map(function(insertError) {\n      return {\n        errors: insertError.errors.map(function(error) {\n          return {\n            message: error.message,\n            reason: error.reason\n          };\n        }),\n        row: json.rows[insertError.index].json\n      };\n    });\n\n    callback(null, failedToInsert, resp);\n  });\n};\n\n/**\n * Run a query scoped to your dataset.\n *\n * See {module:bigquery#query} for full documentation of this method.\n */\nTable.prototype.query = function(query, callback) {\n  return this.dataset.query(query, callback);\n};\n\n/**\n * Set the metadata on the table.\n *\n * @resource [Tables: update API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/tables/update}\n *\n * @param {object} metadata - The metadata key/value object to set.\n * @param {string} metadata.description - A user-friendly description of the\n *     table.\n * @param {string} metadata.name - A descriptive name for the table.\n * @param {string|object} metadata.schema - A comma-separated list of name:type\n *     pairs. Valid types are \"string\", \"integer\", \"float\", \"boolean\", and\n *     \"timestamp\". If the type is omitted, it is assumed to be \"string\".\n *     Example: \"name:string, age:integer\". Schemas can also be specified as a\n *     JSON array of fields, which allows for nested and repeated fields. See\n *     a [Table resource](http://goo.gl/sl8Dmg) for more detailed information.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n  * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var metadata = {\n *   name: 'My recipes',\n *   description: 'A table for storing my recipes.',\n *   schema: 'name:string, servings:integer, cookingTime:float, quick:boolean'\n * };\n *\n * table.setMetadata(metadata, function(err, metadata, apiResponse) {});\n */\nTable.prototype.setMetadata = function(metadata, callback) {\n  var self = this;\n\n  if (metadata.name) {\n    metadata.friendlyName = metadata.name;\n    delete metadata.name;\n  }\n\n  if (is.string(metadata.schema)) {\n    metadata.schema = Table.createSchemaFromString_(metadata.schema);\n  }\n\n  this.request({\n    method: 'PUT',\n    uri: '',\n    json: metadata\n  }, function(err, resp) {\n    if (err) {\n      callback(err, resp);\n      return;\n    }\n\n    self.metadata = resp;\n\n    callback(null, resp);\n  });\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(Table, ['getRows']);\n\nmodule.exports = Table;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/storage/file.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module storage/file\n */\n\n'use strict';\n\nvar concat = require('concat-stream');\nvar createErrorClass = require('create-error-class');\nvar crypto = require('crypto');\nvar duplexify = require('duplexify');\nvar extend = require('extend');\nvar format = require('string-format-obj');\nvar fs = require('fs');\nvar hashStreamValidation = require('hash-stream-validation');\nvar is = require('is');\nvar nodeutil = require('util');\nvar once = require('once');\nvar pumpify = require('pumpify');\nvar resumableUpload = require('gcs-resumable-upload');\nvar streamEvents = require('stream-events');\nvar through = require('through2');\nvar zlib = require('zlib');\n\n/**\n * @type {module:storage/acl}\n * @private\n */\nvar Acl = require('./acl.js');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * Custom error type for errors related to getting signed errors and policies.\n *\n * @private\n *\n * @param {string} message - Custom error message.\n * @return {Error}\n */\nvar SigningError = createErrorClass('SigningError', function(message) {\n  this.message = message;\n});\n\n/**\n * @const {string}\n * @private\n */\nvar STORAGE_DOWNLOAD_BASE_URL = 'https://storage.googleapis.com';\n\n/**\n * @const {string}\n * @private\n */\nvar STORAGE_UPLOAD_BASE_URL = 'https://www.googleapis.com/upload/storage/v1/b';\n\n/**\n * @const {RegExp}\n * @private\n */\nvar GS_URL_REGEXP = /^gs\\:\\/\\/([a-z0-9_\\.\\-]+)\\/(.+)$/;\n\n/*! Developer Documentation\n *\n * @param {module:storage/bucket} bucket - The Bucket instance this file is\n *     attached to.\n * @param {string} name - The name of the remote file.\n * @param {object=} options - Configuration object.\n * @param {string} options.encryptionKey - A custom encryption key.\n * @param {number} options.generation - Generation to scope the file to.\n */\n/**\n * A File object is created from your Bucket object using\n * {module:storage/bucket#file}.\n *\n * @alias module:storage/file\n * @constructor\n *\n * @example\n * var gcloud = require('gcloud');\n *\n * var gcs = gcloud.storage({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var myBucket = gcs.bucket('my-bucket');\n *\n * var file = myBucket.file('my-file');\n */\nfunction File(bucket, name, options) {\n  options = options || {};\n\n  this.bucket = bucket;\n  this.storage = bucket.parent;\n\n  Object.defineProperty(this, 'name', {\n    enumerable: true,\n    value: name\n  });\n\n  var generation = parseInt(options.generation, 10);\n  var requestQueryObject = {};\n\n  if (!isNaN(generation)) {\n    requestQueryObject.generation = generation;\n    this.generation = generation;\n  }\n\n  var methods = {\n    /**\n     * Delete the file.\n     *\n     * @resource [Objects: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/delete}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * file.delete(function(err, apiResponse) {});\n     */\n    delete: {\n      reqOpts: {\n        qs: requestQueryObject\n      }\n    },\n\n    /**\n     * Check if the file exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the file exists or not.\n     *\n     * @example\n     * file.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a file object and its metadata if it exists.\n     *\n     * @example\n     * file.get(function(err, file, apiResponse) {\n     *   // file.metadata` has been populated.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the file's metadata.\n     *\n     * @resource [Objects: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The File's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * file.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: {\n      reqOpts: {\n        qs: requestQueryObject\n      }\n    },\n\n    /**\n     * Merge the given metadata with the current remote file's metadata. This\n     * will set metadata if it was previously unset or update previously set\n     * metadata. To unset previously set metadata, set its value to null.\n     *\n     * You can set custom key/value pairs in the metadata key of the given\n     * object, however the other properties outside of this object must adhere\n     * to the [official API documentation](https://goo.gl/BOnnCK).\n     *\n     * See the examples below for more information.\n     *\n     * @resource [Objects: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/patch}\n     *\n     * @param {object} metadata - The metadata you wish to update.\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * file.setMetadata({\n     *   contentType: 'application/x-font-ttf',\n     *   metadata: {\n     *     my: 'custom',\n     *     properties: 'go here'\n     *   }\n     * }, function(err, apiResponse) {});\n     *\n     * // Assuming current metadata = { hello: 'world', unsetMe: 'will do' }\n     * file.setMetadata({\n     *   metadata: {\n     *     abc: '123', // will be set.\n     *     unsetMe: null, // will be unset (deleted).\n     *     hello: 'goodbye' // will be updated from 'hello' to 'goodbye'.\n     *   }\n     * }, function(err, apiResponse) {\n     *   // metadata should now be { abc: '123', hello: 'goodbye' }\n     * });\n     */\n    setMetadata: {\n      reqOpts: {\n        qs: requestQueryObject\n      }\n    }\n  };\n\n  ServiceObject.call(this, {\n    parent: bucket,\n    baseUrl: '/o',\n    id: encodeURIComponent(name),\n    methods: methods\n  });\n\n  if (options.encryptionKey) {\n    this.setEncryptionKey(options.encryptionKey);\n  }\n\n  /**\n   * Google Cloud Storage uses access control lists (ACLs) to manage object and\n   * bucket access. ACLs are the mechanism you use to share objects with other\n   * users and allow other users to access your buckets and objects.\n   *\n   * An ACL consists of one or more entries, where each entry grants permissions\n   * to an entity. Permissions define the actions that can be performed against\n   * an object or bucket (for example, `READ` or `WRITE`); the entity defines\n   * who the permission applies to (for example, a specific user or group of\n   * users).\n   *\n   * The `acl` object on a File instance provides methods to get you a list of\n   * the ACLs defined on your bucket, as well as set, update, and delete them.\n   *\n   * @resource [About Access Control lists]{@link http://goo.gl/6qBBPO}\n   *\n   * @mixes module:storage/acl\n   *\n   * @example\n   * //-\n   * // Make a file publicly readable.\n   * //-\n   * file.acl.add({\n   *   entity: 'allUsers',\n   *   role: gcs.acl.READER_ROLE\n   * }, function(err, aclObject) {});\n   */\n  this.acl = new Acl({\n    request: this.request.bind(this),\n    pathPrefix: '/acl'\n  });\n}\n\nnodeutil.inherits(File, ServiceObject);\n\n/**\n * Copy this file to another file. By default, this will copy the file to the\n * same bucket, but you can choose to copy it to another Bucket by providing\n * a Bucket or File object or a URL starting with \"gs://\".\n *\n * @resource [Objects: copy API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/copy}\n *\n * @throws {Error} If the destination file is not provided.\n *\n * @param {string|module:storage/bucket|module:storage/file} destination -\n *     Destination file.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:storage/file} callback.copiedFile - The copied File.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // You can pass in a variety of types for the destination.\n * //\n * // For all of the below examples, assume we are working with the following\n * // Bucket and File objects.\n * //-\n * var bucket = gcs.bucket('my-bucket');\n * var file = bucket.file('my-image.png');\n *\n * //-\n * // If you pass in a string for the destination, the file is copied to its\n * // current bucket, under the new name provided.\n * //-\n * file.copy('my-image-copy.png', function(err, copiedFile, apiResponse) {\n *   // `my-bucket` now contains:\n *   // - \"my-image.png\"\n *   // - \"my-image-copy.png\"\n *\n *   // `copiedFile` is an instance of a File object that refers to your new\n *   // file.\n * });\n *\n * //-\n * // If you pass in a string starting with \"gs://\" for the destination, the\n * // file is copied to the other bucket and under the new name provided.\n * //-\n * var newLocation = 'gs://another-bucket/my-image-copy.png';\n * file.copy(newLocation, function(err, copiedFile, apiResponse) {\n *   // `my-bucket` still contains:\n *   // - \"my-image.png\"\n *   //\n *   // `another-bucket` now contains:\n *   // - \"my-image-copy.png\"\n *\n *   // `copiedFile` is an instance of a File object that refers to your new\n *   // file.\n * });\n *\n * //-\n * // If you pass in a Bucket object, the file will be copied to that bucket\n * // using the same name.\n * //-\n * var anotherBucket = gcs.bucket('another-bucket');\n * file.copy(anotherBucket, function(err, copiedFile, apiResponse) {\n *   // `my-bucket` still contains:\n *   // - \"my-image.png\"\n *   //\n *   // `another-bucket` now contains:\n *   // - \"my-image.png\"\n *\n *   // `copiedFile` is an instance of a File object that refers to your new\n *   // file.\n * });\n *\n * //-\n * // If you pass in a File object, you have complete control over the new\n * // bucket and filename.\n * //-\n * var anotherFile = anotherBucket.file('my-awesome-image.png');\n * file.copy(anotherFile, function(err, copiedFile, apiResponse) {\n *   // `my-bucket` still contains:\n *   // - \"my-image.png\"\n *   //\n *   // `another-bucket` now contains:\n *   // - \"my-awesome-image.png\"\n *\n *   // Note:\n *   // The `copiedFile` parameter is equal to `anotherFile`.\n * });\n */\nFile.prototype.copy = function(destination, callback) {\n  var noDestinationError = new Error('Destination file should have a name.');\n\n  if (!destination) {\n    throw noDestinationError;\n  }\n\n  callback = callback || util.noop;\n\n  var destBucket;\n  var destName;\n  var newFile;\n\n  if (is.string(destination)) {\n    var parsedDestination = GS_URL_REGEXP.exec(destination);\n    if (parsedDestination !== null && parsedDestination.length === 3) {\n      destBucket = this.storage.bucket(parsedDestination[1]);\n      destName = parsedDestination[2];\n    } else {\n      destBucket = this.bucket;\n      destName = destination;\n    }\n  } else if (destination.constructor &&\n        destination.constructor.name === 'Bucket') {\n    destBucket = destination;\n    destName = this.name;\n  } else if (destination instanceof File) {\n    destBucket = destination.bucket;\n    destName = destination.name;\n    newFile = destination;\n  } else {\n    throw noDestinationError;\n  }\n\n  var query = {};\n  if (is.defined(this.generation)) {\n    query.sourceGeneration = this.generation;\n  }\n\n  newFile = newFile || destBucket.file(destName);\n\n  this.request({\n    method: 'POST',\n    uri: format('/copyTo/b/{bucketName}/o/{fileName}', {\n      bucketName: destBucket.name,\n      fileName: encodeURIComponent(destName)\n    }),\n    qs: query\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    callback(null, newFile, resp);\n  });\n};\n\n/**\n * Create a readable stream to read the contents of the remote file. It can be\n * piped to a writable stream or listened to for 'data' events to read a file's\n * contents.\n *\n * In the unlikely event there is a mismatch between what you downloaded and the\n * version in your Bucket, your error handler will receive an error with code\n * \"CONTENT_DOWNLOAD_MISMATCH\". If you receive this error, the best recourse is\n * to try downloading the file again.\n *\n * For faster crc32c computation, you must manually install\n * [`fast-crc32c`](http://www.gitnpm.com/fast-crc32c):\n *\n *     $ npm install --save fast-crc32c\n *\n * NOTE: Readable streams will emit the `end` event when the file is fully\n * downloaded.\n *\n * @param {object=} options - Configuration object.\n * @param {string|boolean} options.validation - Possible values: `\"md5\"`,\n *     `\"crc32c\"`, or `false`. By default, data integrity is validated with an\n *     MD5 checksum for maximum reliability, falling back to CRC32c when an MD5\n *     hash wasn't returned from the API. CRC32c will provide better performance\n *     with less reliability. You may also choose to skip validation completely,\n *     however this is **not recommended**.\n * @param {number} options.start - A byte offset to begin the file's download\n *     from. Default is 0. NOTE: Byte ranges are inclusive; that is,\n *     `options.start = 0` and `options.end = 999` represent the first 1000\n *     bytes in a file or object. NOTE: when specifying a byte range, data\n *     integrity is not available.\n * @param {number} options.end - A byte offset to stop reading the file at.\n *     NOTE: Byte ranges are inclusive; that is, `options.start = 0` and\n *     `options.end = 999` represent the first 1000 bytes in a file or object.\n *     NOTE: when specifying a byte range, data integrity is not available.\n * @return {ReadableStream}\n *\n * @example\n * //-\n * // <h4>Downloading a File</h4>\n * //\n * // The example below demonstrates how we can reference a remote file, then\n * // pipe its contents to a local file. This is effectively creating a local\n * // backup of your remote data.\n * //-\n * var fs = require('fs');\n * var remoteFile = bucket.file('image.png');\n * var localFilename = '/Users/stephen/Photos/image.png';\n *\n * remoteFile.createReadStream()\n *   .on('error', function(err) {})\n *   .on('response', function(response) {\n *     // Server connected and responded with the specified status and headers.\n *    })\n *   .on('end', function() {\n *     // The file is fully downloaded.\n *   })\n *   .pipe(fs.createWriteStream(localFilename));\n *\n * //-\n * // To limit the downloaded data to only a byte range, pass an options object.\n * //-\n * var logFile = myBucket.file('access_log');\n * logFile.createReadStream({\n *     start: 10000,\n *     end: 20000\n *   })\n *   .on('error', function(err) {})\n *   .pipe(fs.createWriteStream('/Users/stephen/logfile.txt'));\n *\n * //-\n * // To read a tail byte range, specify only `options.end` as a negative\n * // number.\n * //-\n * var logFile = myBucket.file('access_log');\n * logFile.createReadStream({\n *     end: -100\n *   })\n *   .on('error', function(err) {})\n *   .pipe(fs.createWriteStream('/Users/stephen/logfile.txt'));\n */\nFile.prototype.createReadStream = function(options) {\n  options = options || {};\n\n  var self = this;\n  var rangeRequest = is.number(options.start) || is.number(options.end);\n  var tailRequest = options.end < 0;\n  var throughStream = streamEvents(through());\n\n  var crc32c = options.validation !== false;\n  var md5 = options.validation !== false;\n\n  if (is.string(options.validation)) {\n    options.validation = options.validation.toLowerCase();\n    crc32c = options.validation === 'crc32c';\n    md5 = options.validation === 'md5';\n  }\n\n  if (rangeRequest) {\n    if (is.string(options.validation) || options.validation === true) {\n      throw new Error('Cannot use validation with file ranges (start/end).');\n    }\n    // Range requests can't receive data integrity checks.\n    crc32c = false;\n    md5 = false;\n  }\n\n  // Authenticate the request, then pipe the remote API request to the stream\n  // returned to the user.\n  function makeRequest() {\n    var reqOpts = {\n      uri: format('{downloadBaseUrl}/{bucketName}/{fileName}', {\n        downloadBaseUrl: STORAGE_DOWNLOAD_BASE_URL,\n        bucketName: self.bucket.name,\n        fileName: encodeURIComponent(self.name)\n      }),\n      gzip: true\n    };\n\n    if (self.generation) {\n      reqOpts.qs = {\n        generation: self.generation\n      };\n    }\n\n    if (rangeRequest) {\n      var start = is.number(options.start) ? options.start : '0';\n      var end = is.number(options.end) ? options.end : '';\n\n      reqOpts.headers = {\n        Range: 'bytes=' + (tailRequest ? end : start + '-' + end)\n      };\n    }\n\n    var requestStream = self.request(reqOpts);\n    var validateStream;\n\n    // We listen to the response event from the request stream so that we can...\n    //\n    //   1) Intercept any data from going to the user if an error occurred.\n    //   2) Calculate the hashes from the http.IncomingMessage response stream,\n    //      which will return the bytes from the source without decompressing\n    //      gzip'd content. The request stream will do the decompression so the\n    //      user receives the expected content.\n    function onResponse(err, body, res) {\n      if (err) {\n        requestStream.unpipe(throughStream);\n        return;\n      }\n\n      if (!rangeRequest) {\n        validateStream = hashStreamValidation({\n          crc32c: crc32c,\n          md5: md5\n        });\n\n        res.pipe(validateStream).on('data', util.noop);\n      }\n    }\n\n    // This is hooked to the `complete` event from the request stream. This is\n    // our chance to validate the data and let the user know if anything went\n    // wrong.\n    function onComplete(err, body, res) {\n      if (err) {\n        throughStream.destroy(err);\n        return;\n      }\n\n      if (rangeRequest) {\n        return;\n      }\n\n      var hashes = {};\n      res.headers['x-goog-hash'].split(',').forEach(function(hash) {\n        var hashType = hash.split('=')[0].trim();\n        hashes[hashType] = hash.substr(hash.indexOf('=') + 1);\n      });\n\n      // If we're doing validation, assume the worst-- a data integrity\n      // mismatch. If not, these tests won't be performed, and we can assume the\n      // best.\n      var failed = crc32c || md5;\n\n      if (crc32c && hashes.crc32c) {\n        // We must remove the first four bytes from the returned checksum.\n        // http://stackoverflow.com/questions/25096737/\n        //   base64-encoding-of-crc32c-long-value\n        failed = !validateStream.test('crc32c', hashes.crc32c.substr(4));\n      }\n\n      if (md5 && hashes.md5) {\n        failed = !validateStream.test('md5', hashes.md5);\n      }\n\n      if (failed) {\n        var mismatchError = new Error([\n          'The downloaded data did not match the data from the server.',\n          'To be sure the content is the same, you should download the',\n          'file again.'\n        ].join(' '));\n        mismatchError.code = 'CONTENT_DOWNLOAD_MISMATCH';\n\n        throughStream.destroy(mismatchError);\n      }\n    }\n\n    requestStream\n      .on('error', function(err) {\n        throughStream.destroy(err);\n      })\n      .on('response', function(res) {\n        throughStream.emit('response', res);\n        util.handleResp(null, res, null, onResponse);\n      })\n      .on('complete', function(res) {\n        util.handleResp(null, res, null, onComplete);\n      })\n      .pipe(throughStream)\n      .on('error', function() {\n        // An error can occur before the request stream has been created (during\n        // authentication).\n        if (requestStream.abort) {\n          requestStream.abort();\n        }\n\n        requestStream.destroy();\n      });\n  }\n\n  throughStream.on('reading', makeRequest);\n\n  return throughStream;\n};\n\n/**\n * Create a unique resumable upload session URI. This is the first step when\n * performing a resumable upload.\n *\n * See the [Resumable upload guide](https://cloud.google.com/storage/docs/json_api/v1/how-tos/upload#resumable)\n * for more on how the entire process works.\n *\n * <h4>Note</h4>\n *\n * If you are just looking to perform a resumable upload without worrying about\n * any of the details, see {module:storage/createWriteStream}. Resumable uploads\n * are performed by default.\n *\n * @resource [Resumable upload guide]{@link https://cloud.google.com/storage/docs/json_api/v1/how-tos/upload#resumable}\n *\n * @param {object=} options - Configuration object.\n * @param {object} options.metadata - Metadata to set on the file.\n * @param {string} options.origin - Origin header to set for the upload.\n * @param {string} options.predefinedAcl - Apply a predefined set of access\n *     controls to this object.\n *\n *     Acceptable values are:\n *     - **`authenticatedRead`** - Object owner gets `OWNER` access, and\n *       `allAuthenticatedUsers` get `READER` access.\n *\n *     - **`bucketOwnerFullControl`** - Object owner gets `OWNER` access, and\n *       project team owners get `OWNER` access.\n *\n *     - **`bucketOwnerRead`** - Object owner gets `OWNER` access, and project\n *       team owners get `READER` access.\n *\n *     - **`private`** - Object owner gets `OWNER` access.\n *\n *     - **`projectPrivate`** - Object owner gets `OWNER` access, and project\n *       team members get access according to their roles.\n *\n *     - **`publicRead`** - Object owner gets `OWNER` access, and `allUsers` get\n *       `READER` access.\n * @param {boolean} options.private - Make the uploaded file private. (Alias for\n *     `options.predefinedAcl = 'private'`)\n * @param {boolean} options.public - Make the uploaded file public. (Alias for\n *     `options.predefinedAcl = 'publicRead'`)\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {string} callback.uri - The resumable upload's unique session URI.\n *\n * @example\n * file.createResumableUpload(function(err, uri) {\n *   if (!err) {\n *     // `uri` can be used to PUT data to.\n *   }\n * });\n */\nFile.prototype.createResumableUpload = function(options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  resumableUpload.createURI({\n    authClient: this.bucket.storage.authClient,\n    bucket: this.bucket.name,\n    file: this.name,\n    generation: this.generation,\n    metadata: options.metadata,\n    origin: options.origin,\n    predefinedAcl: options.predefinedAcl,\n    private: options.private,\n    public: options.public\n  }, callback);\n};\n\n/**\n * Create a writable stream to overwrite the contents of the file in your\n * bucket.\n *\n * A File object can also be used to create files for the first time.\n *\n * Resumable uploads are automatically enabled and must be shut off explicitly\n * by setting `options.resumable` to `false`.\n *\n * For faster crc32c computation, you must manually install\n * [`fast-crc32c`](http://www.gitnpm.com/fast-crc32c):\n *\n *     $ npm install --save fast-crc32c\n *\n * NOTE: Writable streams will emit the `finish` event when the file is fully\n * uploaded.\n *\n * @resource [Upload Options (Simple or Resumable)]{@link https://cloud.google.com/storage/docs/json_api/v1/how-tos/upload#uploads}\n * @resource [Objects: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/insert}\n *\n * @param {object=} options - Configuration object.\n * @param {boolean} options.gzip - Automatically gzip the file. This will set\n *     `options.metadata.contentEncoding` to `gzip`.\n * @param {object=} options.metadata - See the examples below or\n *     [Objects: insert request body](https://cloud.google.com/storage/docs/json_api/v1/objects/insert#request_properties_JSON)\n *     for more details.\n * @param {string} options.offset - The starting byte of the upload stream, for\n *     resuming an interrupted upload. Defaults to 0.\n * @param {string} options.predefinedAcl - Apply a predefined set of access\n *     controls to this object.\n *\n *     Acceptable values are:\n *     - **`authenticatedRead`** - Object owner gets `OWNER` access, and\n *       `allAuthenticatedUsers` get `READER` access.\n *\n *     - **`bucketOwnerFullControl`** - Object owner gets `OWNER` access, and\n *       project team owners get `OWNER` access.\n *\n *     - **`bucketOwnerRead`** - Object owner gets `OWNER` access, and project\n *       team owners get `READER` access.\n *\n *     - **`private`** - Object owner gets `OWNER` access.\n *\n *     - **`projectPrivate`** - Object owner gets `OWNER` access, and project\n *       team members get access according to their roles.\n *\n *     - **`publicRead`** - Object owner gets `OWNER` access, and `allUsers` get\n *       `READER` access.\n * @param {boolean} options.private - Make the uploaded file private. (Alias for\n *     `options.predefinedAcl = 'private'`)\n * @param {boolean} options.public - Make the uploaded file public. (Alias for\n *     `options.predefinedAcl = 'publicRead'`)\n * @param {boolean} options.resumable - Force a resumable upload. NOTE: When\n *     working with streams, the file format and size is unknown until it's\n *     completely consumed. Because of this, it's best for you to be explicit\n *     for what makes sense given your input.\n * @param {string} options.uri - The URI for an already-created resumable\n *     upload. See {module:storage/file#createResumableUpload}.\n * @param {string|boolean} options.validation - Possible values: `\"md5\"`,\n *     `\"crc32c\"`, or `false`. By default, data integrity is validated with an\n *     MD5 checksum for maximum reliability. CRC32c will provide better\n *     performance with less reliability. You may also choose to skip validation\n *     completely, however this is **not recommended**.\n * @return {WritableStream}\n *\n * @example\n * var fs = require('fs');\n *\n * //-\n * // <h4>Uploading a File</h4>\n * //\n * // Now, consider a case where we want to upload a file to your bucket. You\n * // have the option of using {module:storage/bucket#upload}, but that is just\n * // a convenience method which will do the following.\n * //-\n * fs.createReadStream('/Users/stephen/Photos/birthday-at-the-zoo/panda.jpg')\n *   .pipe(file.createWriteStream())\n *   .on('error', function(err) {})\n *   .on('finish', function() {\n *     // The file upload is complete.\n *   });\n *\n * //-\n * // <h4>Uploading a File with gzip compression</h4>\n * //-\n * fs.createReadStream('/Users/stephen/site/index.html')\n *   .pipe(file.createWriteStream({ gzip: true }))\n *   .on('error', function(err) {})\n *   .on('finish', function() {\n *     // The file upload is complete.\n *   });\n *\n * //-\n * // Downloading the file with `createReadStream` will automatically decode the\n * // file.\n * //-\n *\n * //-\n * // <h4>Uploading a File with Metadata</h4>\n * //\n * // One last case you may run into is when you want to upload a file to your\n * // bucket and set its metadata at the same time. Like above, you can use\n * // {module:storage/bucket#upload} to do this, which is just a wrapper around\n * // the following.\n * //-\n * fs.createReadStream('/Users/stephen/Photos/birthday-at-the-zoo/panda.jpg')\n *   .pipe(file.createWriteStream({\n *     metadata: {\n *       contentType: 'image/jpeg',\n *       metadata: {\n *         custom: 'metadata'\n *       }\n *     }\n *   }))\n *   .on('error', function(err) {})\n *   .on('finish', function() {\n *     // The file upload is complete.\n *   });\n */\nFile.prototype.createWriteStream = function(options) {\n  options = options || {};\n\n  var self = this;\n\n  options = extend({ metadata: {} }, options);\n\n  var gzip = options.gzip;\n\n  if (gzip) {\n    options.metadata.contentEncoding = 'gzip';\n  }\n\n  var crc32c = options.validation !== false;\n  var md5 = options.validation !== false;\n\n  if (is.string(options.validation)) {\n    options.validation = options.validation.toLowerCase();\n    crc32c = options.validation === 'crc32c';\n    md5 = options.validation === 'md5';\n  }\n\n  // Collect data as it comes in to store in a hash. This is compared to the\n  // checksum value on the returned metadata from the API.\n  var validateStream = hashStreamValidation({\n    crc32c: crc32c,\n    md5: md5\n  });\n\n  var fileWriteStream = duplexify();\n\n  var stream = streamEvents(pumpify([\n    gzip ? zlib.createGzip() : through(),\n    validateStream,\n    fileWriteStream\n  ]));\n\n  // Wait until we've received data to determine what upload technique to use.\n  stream.on('writing', function() {\n    if (options.resumable === false) {\n      self.startSimpleUpload_(fileWriteStream, options);\n    } else {\n      self.startResumableUpload_(fileWriteStream, options);\n    }\n  });\n\n  fileWriteStream.on('response', stream.emit.bind(stream, 'response'));\n\n  // This is to preserve the `finish` event. We wait until the request stream\n  // emits \"complete\", as that is when we do validation of the data. After that\n  // is successful, we can allow the stream to naturally finish.\n  //\n  // Reference for tracking when we can use a non-hack solution:\n  // https://github.com/nodejs/node/pull/2314\n  fileWriteStream.on('prefinish', function() {\n    stream.cork();\n  });\n\n  // Compare our hashed version vs the completed upload's version.\n  fileWriteStream.on('complete', function() {\n    var metadata = self.metadata;\n\n    // If we're doing validation, assume the worst-- a data integrity mismatch.\n    // If not, these tests won't be performed, and we can assume the best.\n    var failed = crc32c || md5;\n\n    if (crc32c && metadata.crc32c) {\n      // We must remove the first four bytes from the returned checksum.\n      // http://stackoverflow.com/questions/25096737/\n      //   base64-encoding-of-crc32c-long-value\n      failed = !validateStream.test('crc32c', metadata.crc32c.substr(4));\n    }\n\n    if (md5 && metadata.md5Hash) {\n      failed = !validateStream.test('md5', metadata.md5Hash);\n    }\n\n    if (failed) {\n      self.delete(function(err) {\n        var code;\n        var message;\n\n        if (err) {\n          code = 'FILE_NO_UPLOAD_DELETE';\n          message = [\n            'The uploaded data did not match the data from the server. As a',\n            'precaution, we attempted to delete the file, but it was not',\n            'successful. To be sure the content is the same, you should try',\n            'removing the file manually, then uploading the file again.',\n            '\\n\\nThe delete attempt failed with this message:',\n            '\\n\\n  ' + err.message\n          ].join(' ');\n        } else {\n          code = 'FILE_NO_UPLOAD';\n          message = [\n            'The uploaded data did not match the data from the server. As a',\n            'precaution, the file has been deleted. To be sure the content',\n            'is the same, you should try uploading the file again.'\n          ].join(' ');\n        }\n\n        var error = new Error(message);\n        error.code = code;\n        error.errors = [err];\n\n        fileWriteStream.destroy(error);\n      });\n\n      return;\n    }\n\n    stream.uncork();\n  });\n\n  return stream;\n};\n\n/**\n * Convenience method to download a file into memory or to a local destination.\n *\n * @param {object=} options - Optional configuration. The arguments match those\n *     passed to {module:storage/file#createReadStream}.\n * @param {string} options.destination - Local file path to write the file's\n *     contents to.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {buffer} callback.contents - The contents of a File.\n *\n * @example\n * //-\n * // Download a file into memory. The contents will be available as the second\n * // argument in the demonstration below, `contents`.\n * //-\n * file.download(function(err, contents) {});\n *\n * //-\n * // Download a file to a local destination.\n * //-\n * file.download({\n *   destination: '/Users/stephen/Desktop/file-backup.txt'\n * }, function(err) {});\n */\nFile.prototype.download = function(options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  callback = once(callback);\n\n  var destination = options.destination;\n  delete options.destination;\n\n  var fileStream = this.createReadStream(options);\n\n  if (destination) {\n    fileStream\n      .on('error', callback)\n      .pipe(fs.createWriteStream(destination))\n      .on('error', callback)\n      .on('finish', callback);\n  } else {\n    fileStream\n      .on('error', callback)\n      .pipe(concat(callback.bind(null, null)));\n  }\n};\n\n/**\n * The Storage API allows you to use a custom key for server-side encryption.\n *\n * @resource [Customer-supplied Encryption Keys]{@link https://cloud.google.com/storage/docs/encryption#customer-supplied}\n *\n * @param {string|buffer} encryptionKey - An AES-256 encryption key.\n * @return {module:storage/file}\n *\n * @example\n * var crypto = require('crypto');\n * var encryptionKey = crypto.randomBytes(32);\n *\n * var fileWithCustomEncryption = myBucket.file('my-file');\n * fileWithCustomEncryption.setEncryptionKey(encryptionKey);\n *\n * var fileWithoutCustomEncryption = myBucket.file('my-file');\n *\n * fileWithCustomEncryption.save('data', function(err) {\n *   // Try to download with the File object that hasn't had\n *   // `setEncryptionKey()` called:\n *   fileWithoutCustomEncryption.download(function(err) {\n *     // We will receive an error:\n *     //   err.message === 'Bad Request'\n *\n *     // Try again with the File object we called `setEncryptionKey()` on:\n *     fileWithCustomEncryption.download(function(err, contents) {\n *       // contents.toString() === 'data'\n *     });\n *   });\n * });\n */\nFile.prototype.setEncryptionKey = function(encryptionKey) {\n  this.encryptionKey = encryptionKey;\n\n  encryptionKey = new Buffer(encryptionKey).toString('base64');\n  var hash = crypto.createHash('sha256')\n    .update(encryptionKey, 'base64')\n    .digest('base64');\n\n  this.interceptors.push({\n    request: function(reqOpts) {\n      reqOpts.headers = reqOpts.headers || {};\n      reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n      reqOpts.headers['x-goog-encryption-key'] = encryptionKey;\n      reqOpts.headers['x-goog-encryption-key-sha256'] = hash;\n      return reqOpts;\n    }\n  });\n};\n\n/**\n * Get a signed policy document to allow a user to upload data with a POST\n * request.\n *\n * @resource [Policy Document Reference]{@link https://cloud.google.com/storage/docs/reference-methods#policydocument}\n *\n * @throws {Error} If an expiration timestamp from the past is given.\n * @throws {Error} If options.equals has an array with less or more than two\n *     members.\n * @throws {Error} If options.startsWith has an array with less or more than two\n *     members.\n *\n * @param {object} options - Configuration object.\n * @param {array|array[]=} options.equals - Array of request parameters and\n *     their expected value (e.g. [['$<field>', '<value>']]). Values are\n *     translated into equality constraints in the conditions field of the\n *     policy document (e.g. ['eq', '$<field>', '<value>']). If only one\n *     equality condition is to be specified, options.equals can be a one-\n *     dimensional array (e.g. ['$<field>', '<value>']).\n * @param {*} options.expires - A timestamp when this policy will expire. Any\n *     value given is passed to `new Date()`.\n * @param {array|array[]=} options.startsWith - Array of request parameters and\n *     their expected prefixes (e.g. [['$<field>', '<value>']). Values are\n *     translated into starts-with constraints in the conditions field of the\n *     policy document (e.g. ['starts-with', '$<field>', '<value>']). If only\n *     one prefix condition is to be specified, options.startsWith can be a one-\n *     dimensional array (e.g. ['$<field>', '<value>']).\n * @param {string=} options.acl - ACL for the object from possibly predefined\n *     ACLs.\n * @param {string=} options.successRedirect - The URL to which the user client\n *     is redirected if the upload is successful.\n * @param {string=} options.successStatus - The status of the Google Storage\n *     response if the upload is successful (must be string).\n * @param {object=} options.contentLengthRange\n * @param {number} options.contentLengthRange.min - Minimum value for the\n *     request's content length.\n * @param {number} options.contentLengthRange.max - Maximum value for the\n *     request's content length.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object} callback.policy - The document policy.\n *\n * @example\n * var options = {\n *   equals: ['$Content-Type', 'image/jpeg'],\n *   expires: '10-25-2022',\n *   contentLengthRange: {\n *     min: 0,\n *     max: 1024\n *   }\n * };\n *\n * file.getSignedPolicy(options, function(err, policy) {\n *   // policy.string: the policy document in plain text.\n *   // policy.base64: the policy document in base64.\n *   // policy.signature: the policy signature in base64.\n * });\n */\nFile.prototype.getSignedPolicy = function(options, callback) {\n  var expires = new Date(options.expires);\n\n  if (expires < Date.now()) {\n    throw new Error('An expiration date cannot be in the past.');\n  }\n\n  options = extend({}, options);\n\n  var conditions = [\n    ['eq', '$key', this.name],\n    {\n      bucket: this.bucket.name\n    }\n  ];\n\n  if (is.array(options.equals)) {\n    if (!is.array(options.equals[0])) {\n      options.equals = [options.equals];\n    }\n    options.equals.forEach(function(condition) {\n      if (!is.array(condition) || condition.length !== 2) {\n        throw new Error('Equals condition must be an array of 2 elements.');\n      }\n      conditions.push(['eq', condition[0], condition[1]]);\n    });\n  }\n\n  if (is.array(options.startsWith)) {\n    if (!is.array(options.startsWith[0])) {\n      options.startsWith = [options.startsWith];\n    }\n    options.startsWith.forEach(function(condition) {\n      if (!is.array(condition) || condition.length !== 2) {\n        throw new Error('StartsWith condition must be an array of 2 elements.');\n      }\n      conditions.push(['starts-with', condition[0], condition[1]]);\n    });\n  }\n\n  if (options.acl) {\n    conditions.push({\n      acl: options.acl\n    });\n  }\n\n  if (options.successRedirect) {\n    conditions.push({\n      success_action_redirect: options.successRedirect\n    });\n  }\n\n  if (options.successStatus) {\n    conditions.push({\n      success_action_status: options.successStatus\n    });\n  }\n\n  if (options.contentLengthRange) {\n    var min = options.contentLengthRange.min;\n    var max = options.contentLengthRange.max;\n    if (!is.number(min) || !is.number(max)) {\n      throw new Error('ContentLengthRange must have numeric min & max fields.');\n    }\n    conditions.push(['content-length-range', min, max]);\n  }\n\n  var policy = {\n    expiration: expires.toISOString(),\n    conditions: conditions\n  };\n\n  this.storage.getCredentials(function(err, credentials) {\n    if (err) {\n      callback(new SigningError(err.message));\n      return;\n    }\n\n    if (!credentials.private_key) {\n      var errorMessage = [\n        'Could not find a `private_key`.',\n        'Please verify you are authorized with this property available.'\n      ].join(' ');\n\n      callback(new SigningError(errorMessage));\n      return;\n    }\n\n    var sign = crypto.createSign('RSA-SHA256');\n    var policyString = JSON.stringify(policy);\n    var policyBase64 = new Buffer(policyString).toString('base64');\n\n    sign.update(policyBase64);\n\n    var signature = sign.sign(credentials.private_key, 'base64');\n\n    callback(null, {\n      string: policyString,\n      base64: policyBase64,\n      signature: signature\n    });\n  });\n};\n\n/**\n * Get a signed URL to allow limited time access to the file.\n *\n * @resource [Signed URLs Reference]{@link https://cloud.google.com/storage/docs/access-control#Signed-URLs}\n *\n * @throws {Error} if an expiration timestamp from the past is given.\n *\n * @param {object} config - Configuration object.\n * @param {string} config.action - \"read\" (HTTP: GET), \"write\" (HTTP: PUT), or\n *     \"delete\" (HTTP: DELETE).\n * @param {string=} config.cname - The cname for this bucket, i.e.,\n *     \"https://cdn.example.com\".\n * @param {string=} config.contentMd5 - The MD5 digest value in base64. If you\n *     provide this, the client must provide this HTTP header with this same\n *     value in its request.\n * @param {string=} config.contentType - If you provide this value, the client\n *     must provide this HTTP header set to the same value.\n * @param {*} config.expires - A timestamp when this link will expire. Any value\n *     given is passed to `new Date()`.\n * @param {object=} config.extensionHeaders - If these headers are used, the\n *     server will check to make sure that the client provides matching values.\n * @param {string=} config.promptSaveAs - The filename to prompt the user to\n *     save the file as when the signed url is accessed. This is ignored if\n *     `config.responseDisposition` is set.\n * @param {string=} config.responseDisposition - The\n *     [response-content-disposition parameter](http://goo.gl/yMWxQV) of the\n *     signed url.\n * @param {string=} config.responseType - The response-content-type parameter\n *     of the signed url.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {string} callback.url - The signed URL.\n *\n * @example\n * //-\n * // Generate a URL that allows temporary access to download your file.\n * //-\n * var request = require('request');\n *\n * file.getSignedUrl({\n *   action: 'read',\n *   expires: '03-17-2025'\n * }, function(err, url) {\n *   if (err) {\n *     console.error(err);\n *     return;\n *   }\n *\n *   // The file is now available to read from this URL.\n *   request(url, function(err, resp) {\n *     // resp.statusCode = 200\n *   });\n * });\n *\n * //-\n * // Generate a URL to allow write permissions. This means anyone with this URL\n * // can send a POST request with new data that will overwrite the file.\n * //-\n * file.getSignedUrl({\n *   action: 'write',\n *   expires: '03-17-2025'\n * }, function(err, url) {\n *   if (err) {\n *     console.error(err);\n *     return;\n *   }\n *\n *   // The file is now available to be written to.\n *   var writeStream = request.put(url);\n *   writeStream.end('New data');\n *\n *   writeStream.on('complete', function(resp) {\n *     // Confirm the new content was saved.\n *     file.download(function(err, fileContents) {\n *       console.log('Contents:', fileContents.toString());\n *       // Contents: New data\n *     });\n *   });\n * });\n */\nFile.prototype.getSignedUrl = function(config, callback) {\n  var self = this;\n  var expires = new Date(config.expires);\n  var expiresInSeconds = Math.round(expires / 1000); // The API expects seconds.\n\n  if (expires < Date.now()) {\n    throw new Error('An expiration date cannot be in the past.');\n  }\n\n  config = extend({}, config);\n\n  config.action = {\n    read: 'GET',\n    write: 'PUT',\n    delete: 'DELETE'\n  }[config.action];\n\n  var name = encodeURIComponent(this.name);\n  var host = config.cname || STORAGE_DOWNLOAD_BASE_URL + '/' + self.bucket.name;\n  config.resource = '/' + this.bucket.name + '/' + name;\n\n  this.storage.getCredentials(function(err, credentials) {\n    if (err) {\n      callback(new SigningError(err.message));\n      return;\n    }\n\n    if (!credentials.private_key || !credentials.client_email) {\n      var errorMessage = [\n        'Could not find a `private_key` or `client_email`.',\n        'Please verify you are authorized with these credentials available.'\n      ].join(' ');\n\n      callback(new SigningError(errorMessage));\n      return;\n    }\n\n    var extensionHeadersString = '';\n\n    if (config.extensionHeaders) {\n      for (var headerName in config.extensionHeaders) {\n        extensionHeadersString += format('{name}:{value}\\n', {\n          name: headerName,\n          value: config.extensionHeaders[headerName],\n        });\n      }\n    }\n\n    var sign = crypto.createSign('RSA-SHA256');\n    sign.update([\n      config.action,\n      (config.contentMd5 || ''),\n      (config.contentType || ''),\n      expiresInSeconds,\n      extensionHeadersString + config.resource\n    ].join('\\n'));\n    var signature = sign.sign(credentials.private_key, 'base64');\n\n    var responseContentType;\n    if (is.string(config.responseType)) {\n      responseContentType =\n        '&response-content-type=' +\n        encodeURIComponent(config.responseType);\n    }\n\n    var responseContentDisposition;\n    if (is.string(config.promptSaveAs)) {\n      responseContentDisposition =\n        '&response-content-disposition=attachment; filename=\"' +\n        encodeURIComponent(config.promptSaveAs) + '\"';\n    }\n    if (is.string(config.responseDisposition)) {\n      responseContentDisposition =\n        '&response-content-disposition=' +\n        encodeURIComponent(config.responseDisposition);\n    }\n\n    var signedUrl = format('{host}/{name}{id}{exp}{sig}{type}{disp}{gen}', {\n      host: host.replace(/\\/*$/, ''), // Remove trailing slashes.\n      name: name,\n      id: '?GoogleAccessId=' + credentials.client_email,\n      exp: '&Expires=' + expiresInSeconds,\n      sig: '&Signature=' + encodeURIComponent(signature),\n      type: responseContentType || '',\n      disp: responseContentDisposition || '',\n      gen: self.generation ? '&generation=' + self.generation : ''\n    });\n\n    callback(null, signedUrl);\n  });\n};\n\n/**\n * Make a file private to the project and remove all other permissions.\n * Set `options.strict` to true to make the file private to only the owner.\n *\n * @resource [Objects: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/patch}\n *\n * @param {object=} options - The configuration object.\n * @param {boolean=} options.strict - If true, set the file to be private to\n *     only the owner user. Otherwise, it will be private to the project.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n *\n * @example\n * //-\n * // Set the file private so only project maintainers can see and modify it.\n * //-\n * file.makePrivate(function(err) {});\n *\n * //-\n * // Set the file private so only the owner can see and modify it.\n * //-\n * file.makePrivate({ strict: true }, function(err) {});\n */\nFile.prototype.makePrivate = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var query = {\n    predefinedAcl: options.strict ? 'private' : 'projectPrivate'\n  };\n\n  // You aren't allowed to set both predefinedAcl & acl properties on a file, so\n  // acl must explicitly be nullified, destroying all previous acls on the file.\n  var metadata = {\n    acl: null\n  };\n\n  callback = callback || util.noop;\n\n  this.request({\n    method: 'PATCH',\n    uri: '',\n    qs: query,\n    json: metadata\n  }, function(err, resp) {\n    if (err) {\n      callback(err, resp);\n      return;\n    }\n\n    self.metadata = resp;\n\n    callback(null, resp);\n  });\n};\n\n/**\n * Set a file to be publicly readable and maintain all previous permissions.\n *\n * @resource [ObjectAccessControls: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objectAccessControls/insert}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * file.makePublic(function(err, apiResponse) {});\n */\nFile.prototype.makePublic = function(callback) {\n  callback = callback || util.noop;\n\n  this.acl.add({\n    entity: 'allUsers',\n    role: 'READER'\n  }, function(err, resp) {\n    callback(err, resp);\n  });\n};\n\n/**\n * Move this file to another location. By default, this will move the file to\n * the same bucket, but you can choose to move it to another Bucket by providing\n * a Bucket or File object or a URL beginning with \"gs://\".\n *\n * **Warning**:\n * There is currently no atomic `move` method in the Google Cloud Storage API,\n * so this method is a composition of {module:storage/file#copy} (to the new\n * location) and {module:storage/file#delete} (from the old location). While\n * unlikely, it is possible that an error returned to your callback could be\n * triggered from either one of these API calls failing, which could leave a\n * duplicate file lingering.\n *\n * @resource [Objects: copy API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/copy}\n *\n * @throws {Error} If the destination file is not provided.\n *\n * @param {string|module:storage/bucket|module:storage/file} destination -\n *     Destination file.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:storage/file} callback.destinationFile - The destination File.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // You can pass in a variety of types for the destination.\n * //\n * // For all of the below examples, assume we are working with the following\n * // Bucket and File objects.\n * //-\n * var bucket = gcs.bucket('my-bucket');\n * var file = bucket.file('my-image.png');\n *\n * //-\n * // If you pass in a string for the destination, the file is moved to its\n * // current bucket, under the new name provided.\n * //-\n * file.move('my-image-new.png', function(err, destinationFile, apiResponse) {\n *   // `my-bucket` no longer contains:\n *   // - \"my-image.png\"\n *   // but contains instead:\n *   // - \"my-image-new.png\"\n *\n *   // `destinationFile` is an instance of a File object that refers to your\n *   // new file.\n * });\n *\n * //-\n * // If you pass in a string starting with \"gs://\" for the destination, the\n * // file is copied to the other bucket and under the new name provided.\n * //-\n * var newLocation = 'gs://another-bucket/my-image-new.png';\n * file.move(newLocation, function(err, destinationFile, apiResponse) {\n *   // `my-bucket` no longer contains:\n *   // - \"my-image.png\"\n *   //\n *   // `another-bucket` now contains:\n *   // - \"my-image-new.png\"\n *\n *   // `destinationFile` is an instance of a File object that refers to your\n *   // new file.\n * });\n *\n * //-\n * // If you pass in a Bucket object, the file will be moved to that bucket\n * // using the same name.\n * //-\n * var anotherBucket = gcs.bucket('another-bucket');\n *\n * file.move(anotherBucket, function(err, destinationFile, apiResponse) {\n *   // `my-bucket` no longer contains:\n *   // - \"my-image.png\"\n *   //\n *   // `another-bucket` now contains:\n *   // - \"my-image.png\"\n *\n *   // `destinationFile` is an instance of a File object that refers to your\n *   // new file.\n * });\n *\n * //-\n * // If you pass in a File object, you have complete control over the new\n * // bucket and filename.\n * //-\n * var anotherFile = anotherBucket.file('my-awesome-image.png');\n *\n * file.move(anotherFile, function(err, destinationFile, apiResponse) {\n *   // `my-bucket` no longer contains:\n *   // - \"my-image.png\"\n *   //\n *   // `another-bucket` now contains:\n *   // - \"my-awesome-image.png\"\n *\n *   // Note:\n *   // The `destinationFile` parameter is equal to `anotherFile`.\n * });\n */\nFile.prototype.move = function(destination, callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  this.copy(destination, function(err, destinationFile, apiResponse) {\n    if (err) {\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    self.delete(function(err, apiResponse) {\n      callback(err, destinationFile, apiResponse);\n    });\n  });\n};\n\n/**\n * Write arbitrary data to a file.\n *\n * *This is a convenience method which wraps\n * {module:storage/file#createWriteStream}.*\n *\n * @param {*} data - The data to write to a file.\n * @param {object=} options - See {module:storage/file#createWriteStream}'s\n *     `options` parameter.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n *\n * @example\n * file.save('This is the contents of the file.', function(err) {\n *   if (!err) {\n *     // File written successfully.\n *   }\n * });\n */\nFile.prototype.save = function(data, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.createWriteStream(options)\n    .on('error', callback)\n    .on('finish', callback)\n    .end(data);\n};\n\n/**\n * This creates a gcs-resumable-upload upload stream.\n *\n * @resource [gcs-resumable-upload]{@link https://github.com/stephenplusplus/gcs-resumable-upload}\n *\n * @param {Duplexify} stream - Duplexify stream of data to pipe to the file.\n * @param {object=} options - Configuration object.\n *\n * @private\n */\nFile.prototype.startResumableUpload_ = function(dup, options) {\n  var self = this;\n\n  options = extend({\n    metadata: {}\n  }, options);\n\n  var uploadStream = resumableUpload({\n    authClient: this.storage.authClient,\n    bucket: this.bucket.name,\n    file: this.name,\n    generation: this.generation,\n    key: this.encryptionKey,\n    metadata: options.metadata,\n    offset: options.offset,\n    predefinedAcl: options.predefinedAcl,\n    private: options.private,\n    public: options.public,\n    uri: options.uri\n  });\n\n  uploadStream\n    .on('response', function(resp) {\n      dup.emit('response', resp);\n    })\n    .on('metadata', function(metadata) {\n      self.metadata = metadata;\n    })\n    .on('finish', function() {\n      dup.emit('complete');\n    });\n\n  dup.setWritable(uploadStream);\n};\n\n/**\n * Takes a readable stream and pipes it to a remote file. Unlike\n * `startResumableUpload_`, which uses the resumable upload technique, this\n * method uses a simple upload (all or nothing).\n *\n * @param {Duplexify} dup - Duplexify stream of data to pipe to the file.\n * @param {object=} options - Configuration object.\n *\n * @private\n */\nFile.prototype.startSimpleUpload_ = function(dup, options) {\n  var self = this;\n\n  options = extend({\n    metadata: {}\n  }, options);\n\n  var reqOpts = {\n    qs: {\n      name: self.name\n    },\n    uri: format('{uploadBaseUrl}/{bucket}/o', {\n      uploadBaseUrl: STORAGE_UPLOAD_BASE_URL,\n      bucket: self.bucket.name\n    })\n  };\n\n  if (is.defined(this.generation)) {\n    reqOpts.qs.ifGenerationMatch = this.generation;\n  }\n\n  if (options.predefinedAcl) {\n    reqOpts.qs.predefinedAcl = options.predefinedAcl;\n  } else if (options.private) {\n    reqOpts.qs.predefinedAcl = 'private';\n  } else if (options.public) {\n    reqOpts.qs.predefinedAcl = 'publicRead';\n  }\n\n  util.makeWritableStream(dup, {\n    makeAuthenticatedRequest: function(reqOpts) {\n      self.request(reqOpts, function(err, body, resp) {\n        if (err) {\n          dup.destroy(err);\n          return;\n        }\n\n        self.metadata = body;\n        dup.emit('response', resp);\n        dup.emit('complete');\n      });\n    },\n    metadata: options.metadata,\n    request: reqOpts\n  });\n};\n\nmodule.exports = File;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/storage/acl.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module storage/acl\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * Google Cloud Storage uses access control lists (ACLs) to manage object and\n * bucket access. ACLs are the mechanism you use to share objects with other\n * users and allow other users to access your buckets and objects.\n *\n * An ACL consists of one or more entries, where each entry grants permissions\n * to an entity. Permissions define the actions that can be performed against an\n * object or bucket (for example, `READ` or `WRITE`); the entity defines who the\n * permission applies to (for example, a specific user or group of users).\n *\n * Where an `entity` value is accepted, we follow the format the Cloud Storage\n * API expects.\n *\n * Refer to\n * https://cloud.google.com/storage/docs/json_api/v1/defaultObjectAccessControls\n * for the most up-to-date values.\n *\n *   - `user-userId`\n *   - `user-email`\n *   - `group-groupId`\n *   - `group-email`\n *   - `domain-domain`\n *   - `project-team-projectId`\n *   - `allUsers`\n *   - `allAuthenticatedUsers`\n *\n * Examples:\n *\n *   - The user \"liz@example.com\" would be `user-liz@example.com`.\n *   - The group \"example@googlegroups.com\" would be\n *     `group-example@googlegroups.com`.\n *   - To refer to all members of the Google Apps for Business domain\n *     \"example.com\", the entity would be `domain-example.com`.\n *\n * For more detailed information, see\n * [About Access Control Lists](http://goo.gl/6qBBPO).\n *\n * @constructor\n * @alias module:storage/acl\n */\nfunction Acl(options) {\n  AclRoleAccessorMethods.call(this);\n\n  this.pathPrefix = options.pathPrefix;\n  this.request_ = options.request;\n}\n\n/**\n * An object of convenience methods to add or delete owner ACL permissions for a\n * given entity.\n *\n * The supported methods include:\n *\n *   - `myFile.acl.owners.addAllAuthenticatedUsers`\n *   - `myFile.acl.owners.deleteAllAuthenticatedUsers`\n *   - `myFile.acl.owners.addAllUsers`\n *   - `myFile.acl.owners.deleteAllUsers`\n *   - `myFile.acl.owners.addDomain`\n *   - `myFile.acl.owners.deleteDomain`\n *   - `myFile.acl.owners.addGroup`\n *   - `myFile.acl.owners.deleteGroup`\n *   - `myFile.acl.owners.addProject`\n *   - `myFile.acl.owners.deleteProject`\n *   - `myFile.acl.owners.addUser`\n *   - `myFile.acl.owners.deleteUser`\n *\n * @return {object}\n *\n * @example\n * var gcs = gcloud.storage({\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * //-\n * // Add a user as an owner of a file.\n * //-\n * var myBucket = gcs.bucket('my-bucket');\n * var myFile = myBucket.file('my-file');\n * myFile.acl.owners.addUser('email@example.com', function(err, aclObject) {});\n *\n * //-\n * // For reference, the above command is the same as running the following.\n * //-\n * myFile.acl.add({\n *   entity: 'user-email@example.com',\n *   role: gcs.acl.OWNER_ROLE\n * }, function(err, aclObject) {});\n */\nAcl.prototype.owners = {};\n\n/**\n * An object of convenience methods to add or delete reader ACL permissions for\n * a given entity.\n *\n * The supported methods include:\n *\n *   - `myFile.acl.readers.addAllAuthenticatedUsers`\n *   - `myFile.acl.readers.deleteAllAuthenticatedUsers`\n *   - `myFile.acl.readers.addAllUsers`\n *   - `myFile.acl.readers.deleteAllUsers`\n *   - `myFile.acl.readers.addDomain`\n *   - `myFile.acl.readers.deleteDomain`\n *   - `myFile.acl.readers.addGroup`\n *   - `myFile.acl.readers.deleteGroup`\n *   - `myFile.acl.readers.addProject`\n *   - `myFile.acl.readers.deleteProject`\n *   - `myFile.acl.readers.addUser`\n *   - `myFile.acl.readers.deleteUser`\n *\n * @return {object}\n *\n * @example\n * //-\n * // Add a user as a reader of a file.\n * //-\n * myFile.acl.readers.addUser('email@example.com', function(err, aclObject) {});\n *\n * //-\n * // For reference, the above command is the same as running the following.\n * //-\n * myFile.acl.add({\n *   entity: 'user-email@example.com',\n *   role: gcs.acl.READER_ROLE\n * }, function(err, aclObject) {});\n */\nAcl.prototype.readers = {};\n\n/**\n * An object of convenience methods to add or delete writer ACL permissions for\n * a given entity.\n *\n * The supported methods include:\n *\n *   - `myFile.acl.writers.addAllAuthenticatedUsers`\n *   - `myFile.acl.writers.deleteAllAuthenticatedUsers`\n *   - `myFile.acl.writers.addAllUsers`\n *   - `myFile.acl.writers.deleteAllUsers`\n *   - `myFile.acl.writers.addDomain`\n *   - `myFile.acl.writers.deleteDomain`\n *   - `myFile.acl.writers.addGroup`\n *   - `myFile.acl.writers.deleteGroup`\n *   - `myFile.acl.writers.addProject`\n *   - `myFile.acl.writers.deleteProject`\n *   - `myFile.acl.writers.addUser`\n *   - `myFile.acl.writers.deleteUser`\n *\n * @return {object}\n *\n * @example\n * //-\n * // Add a user as a writer of a file.\n * //-\n * myFile.acl.writers.addUser('email@example.com', function(err, aclObject) {});\n *\n * //-\n * // For reference, the above command is the same as running the following.\n * //-\n * myFile.acl.add({\n *   entity: 'user-email@example.com',\n *   role: gcs.acl.WRITER_ROLE\n * }, function(err, aclObject) {});\n */\nAcl.prototype.writers = {};\n\nnodeutil.inherits(Acl, AclRoleAccessorMethods);\n\n/**\n * Add access controls on a {module:storage/bucket} or {module:storage/file}.\n *\n * @resource [BucketAccessControls: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/bucketAccessControls/insert}\n * @resource [ObjectAccessControls: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objectAccessControls/insert}\n *\n * @param {object} options - Configuration object.\n * @param {string} options.entity - Whose permissions will be added.\n * @param {string} options.role - Permissions allowed for the defined entity.\n *     See {module:storage#acl}.\n * @param {int=} options.generation - **File Objects Only** Select a specific\n *     revision of this file (as opposed to the latest version, the default).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object} callback.aclObject - The Acl Object.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * myBucket.acl.add({\n *   entity: 'user-useremail@example.com',\n *   role: gcs.acl.OWNER_ROLE\n * }, function(err, aclObject, apiResponse) {});\n *\n * //-\n * // For file ACL operations, you can also specify a `generation` property.\n * // Here is how you would grant ownership permissions to a user on a specific\n * // revision of a file.\n * //-\n * myFile.acl.add({\n *   entity: 'user-useremail@example.com',\n *   role: gcs.acl.OWNER_ROLE,\n *   generation: 1\n * }, function(err, aclObject, apiResponse) {});\n */\nAcl.prototype.add = function(options, callback) {\n  var self = this;\n\n  var query = {};\n\n  if (options.generation) {\n    query.generation = options.generation;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '',\n    qs: query,\n    json: {\n      entity: options.entity,\n      role: options.role.toUpperCase()\n    }\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    callback(null, self.makeAclObject_(resp), resp);\n  });\n};\n\n/**\n * Delete access controls on a {module:storage/bucket} or {module:storage/file}.\n *\n * @resource [BucketAccessControls: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/bucketAccessControls/delete}\n * @resource [ObjectAccessControls: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objectAccessControls/delete}\n *\n * @param {object=} options - Configuration object.\n * @param {string} options.entity - Whose permissions will be revoked.\n * @param {int=} options.generation - **File Objects Only** Select a specific\n *     revision of this file (as opposed to the latest version, the default).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * myBucket.acl.delete({\n *   entity: 'user-useremail@example.com'\n * }, function(err, apiResponse) {});\n *\n * //-\n * // For file ACL operations, you can also specify a `generation` property.\n * //-\n * myFile.acl.delete({\n *   entity: 'user-useremail@example.com',\n *   generation: 1\n * }, function(err, apiResponse) {});\n */\nAcl.prototype.delete = function(options, callback) {\n  var query = {};\n\n  if (options.generation) {\n    query.generation = options.generation;\n  }\n\n  this.request({\n    method: 'DELETE',\n    uri: '/' + encodeURIComponent(options.entity),\n    qs: query\n  }, function(err, resp) {\n    callback(err, resp);\n  });\n};\n\n/**\n * Get access controls on a {module:storage/bucket} or {module:storage/file}. If\n * an entity is omitted, you will receive an array of all applicable access\n * controls.\n *\n * @resource [BucketAccessControls: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/bucketAccessControls/get}\n * @resource [ObjectAccessControls: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objectAccessControls/get}\n *\n * @param {object|function} options - Configuration object. If you want to\n *     receive a list of all access controls, pass the callback function as the\n *     only argument.\n * @param {string=} options.entity - Whose permissions will be fetched.\n * @param {int=} options.generation - **File Objects Only** Select a specific\n *     revision of this file (as opposed to the latest version, the default).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object|array} callback.aclObject - Single or Array of Acl Objects.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * myBucket.acl.get({\n *   entity: 'user-useremail@example.com'\n * }, function(err, aclObject, apiResponse) {});\n *\n * //-\n * // Get all access controls.\n * //-\n * myBucket.acl.get(function(err, aclObjects, apiResponse) {\n *   // aclObjects = [\n *   //   {\n *   //     entity: 'user-useremail@example.com',\n *   //     role: 'owner'\n *   //   }\n *   // ]\n * });\n *\n * //-\n * // For file ACL operations, you can also specify a `generation` property.\n * //-\n * myFile.acl.get({\n *   entity: 'user-useremail@example.com',\n *   generation: 1\n * }, function(err, aclObject, apiResponse) {});\n */\nAcl.prototype.get = function(options, callback) {\n  var self = this;\n  var path = '';\n  var query = {};\n\n  if (is.fn(options)) {\n    callback = options;\n    options = null;\n  } else {\n    path = '/' + encodeURIComponent(options.entity);\n\n    if (options.generation) {\n      query.generation = options.generation;\n    }\n  }\n\n  this.request({\n    uri: path,\n    qs: query,\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var results;\n\n    if (resp.items) {\n      results = arrify(resp.items).map(self.makeAclObject_);\n    } else {\n      results = self.makeAclObject_(resp);\n    }\n\n    callback(null, results, resp);\n  });\n};\n\n/**\n * Update access controls on a {module:storage/bucket} or {module:storage/file}.\n *\n * @resource [BucketAccessControls: update API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/bucketAccessControls/update}\n * @resource [ObjectAccessControls: update API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objectAccessControls/update}\n *\n * @param {object=} options - Configuration object.\n * @param {string} options.entity - Whose permissions will be updated.\n * @param {string} options.role - Permissions allowed for the defined entity.\n *     See {module:storage#acl}.\n * @param {int=} options.generation - **File Objects Only** Select a specific\n *     revision of this file (as opposed to the latest version, the default).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object} callback.aclObject - The updated Acl Object.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var gcs = gcloud.storage({\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * myBucket.acl.update({\n *   entity: 'user-useremail@example.com',\n *   role: gcs.acl.WRITER_ROLE\n * }, function(err, aclObject, apiResponse) {});\n *\n * //-\n * // For file ACL operations, you can also specify a `generation` property.\n * //-\n * myFile.acl.update({\n *   entity: 'user-useremail@example.com',\n *   role: gcs.acl.WRITER_ROLE,\n *   generation: 1\n * }, function(err, aclObject, apiResponse) {});\n */\nAcl.prototype.update = function(options, callback) {\n  var self = this;\n\n  var query = {};\n\n  if (options.generation) {\n    query.generation = options.generation;\n  }\n\n  this.request({\n    method: 'PUT',\n    uri: '/' + encodeURIComponent(options.entity),\n    qs: query,\n    json: {\n      role: options.role.toUpperCase()\n    }\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    callback(null, self.makeAclObject_(resp), resp);\n  });\n};\n\n/**\n * Transform API responses to a consistent object format.\n *\n * @private\n */\nAcl.prototype.makeAclObject_ = function(accessControlObject) {\n  var obj = {\n    entity: accessControlObject.entity,\n    role: accessControlObject.role\n  };\n\n  if (accessControlObject.projectTeam) {\n    obj.projectTeam = accessControlObject.projectTeam;\n  }\n\n  return obj;\n};\n\n/**\n * Patch requests up to the bucket's request object.\n *\n * @private\n *\n * @param {string} method - Action.\n * @param {string} path - Request path.\n * @param {*} query - Request query object.\n * @param {*} body - Request body contents.\n * @param {function} callback - The callback function.\n */\nAcl.prototype.request = function(reqOpts, callback) {\n  reqOpts.uri = this.pathPrefix + reqOpts.uri;\n  this.request_(reqOpts, callback);\n};\n\nmodule.exports = Acl;\n\n/**\n * Attach functionality to a {module:storage/acl} instance. This will add an\n * object for each role group (owners, readers, and writers), with each object\n * containing methods to add or delete a type of entity.\n *\n * As an example, here are a few methods that are created.\n *\n *   myBucket.acl.readers.deleteGroup('groupId', function(err) {});\n *\n *   myBucket.acl.owners.addUser('email@example.com', function(err, acl) {});\n *\n *   myBucket.acl.writers.addDomain('example.com', function(err, acl) {});\n *\n * @private\n */\nfunction AclRoleAccessorMethods() {\n  AclRoleAccessorMethods.roles.forEach(this._assignAccessMethods.bind(this));\n}\n\nAclRoleAccessorMethods.accessMethods = [\n  'add',\n  'delete'\n];\n\nAclRoleAccessorMethods.entities = [\n  // Special entity groups that do not require further specification.\n  'allAuthenticatedUsers',\n  'allUsers',\n\n  // Entity groups that require specification, e.g. `user-email@example.com`.\n  'domain-',\n  'group-',\n  'project-',\n  'user-'\n];\n\nAclRoleAccessorMethods.roles = [\n  'OWNER',\n  'READER',\n  'WRITER'\n];\n\nAclRoleAccessorMethods.prototype._assignAccessMethods = function(role) {\n  var self = this;\n\n  var accessMethods = AclRoleAccessorMethods.accessMethods;\n  var entities = AclRoleAccessorMethods.entities;\n  var roleGroup = role.toLowerCase() + 's';\n\n  this[roleGroup] = entities.reduce(function(acc, entity) {\n    var isPrefix = entity.charAt(entity.length - 1) === '-';\n\n    accessMethods.forEach(function(accessMethod) {\n      var method = accessMethod + entity[0].toUpperCase() + entity.substr(1);\n\n      if (isPrefix) {\n        method = method.replace('-', '');\n      }\n\n      // Wrap the parent accessor method (e.g. `add` or `delete`) to avoid the\n      // more complex API of specifying an `entity` and `role`.\n      acc[method] = function(entityId, callback) {\n        var apiEntity;\n\n        if (isPrefix) {\n          apiEntity = entity + entityId;\n        } else {\n          // If the entity is not a prefix, it is a special entity group that\n          // does not require further details. The accessor methods only accept\n          // a callback.\n          apiEntity = entity;\n          callback = entityId;\n        }\n\n        self[accessMethod]({\n          entity: apiEntity,\n          role: role\n        }, callback);\n      };\n    });\n\n    return acc;\n  }, {});\n};\n\nmodule.exports.AclRoleAccessorMethods = AclRoleAccessorMethods;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/bigquery/job.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module bigquery/job\n */\n\n'use strict';\n\nvar events = require('events');\nvar is = require('is');\nvar modelo = require('modelo');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:bigquery} bigQuery - BigQuery instance.\n * @param {string} id - The ID of the job.\n *\n * @example\n * var bigquery = gcloud.bigquery({ projectId: 'grape-spaceship-123' });\n * var Job = require('gcloud/lib/bigquery/job');\n * var job = new Job(bigquery, 'job-id');\n */\n/**\n * Job objects are returned from various places in the BigQuery API:\n *\n * - {module:bigquery#getJobs}\n * - {module:bigquery#job}\n * - {module:bigquery#query}\n * - {module:bigquery#startJob}\n * - {module:bigquery/table#copy}\n * - {module:bigquery/table#createWriteStream}\n * - {module:bigquery/table#export}\n * - {module:bigquery/table#import}\n *\n * They can be used to check the status of a running job or fetching the results\n * of a previously-executed one.\n *\n * @alias module:bigquery/job\n * @constructor\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var bigquery = gcloud.bigquery();\n *\n * var job = bigquery.job('job-id');\n *\n * //-\n * // All jobs are event emitters. The status of each job is polled\n * // continuously, starting only after you register a \"complete\" listener.\n * //-\n * job.on('complete', function(metadata) {\n *   // The job is complete.\n * });\n *\n * //-\n * // Be sure to register an error handler as well to catch any issues which\n * // impeded the job.\n * //-\n * job.on('error', function(err) {\n *   // An error occurred during the job.\n * });\n *\n * //-\n * // To force the Job object to stop polling for updates, simply remove any\n * // \"complete\" listeners you've registered.\n * //\n * // The easiest way to do this is with `removeAllListeners()`.\n * //-\n * job.removeAllListeners();\n */\nfunction Job(bigQuery, id) {\n  var methods = {\n    /**\n     * Check if the job exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the job exists or not.\n     *\n     * @example\n     * job.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a job if it exists.\n     *\n     * @example\n     * job.get(function(err, job, apiResponse) {\n     *   if (!err) {\n     *     // `job.metadata` has been populated.\n     *   }\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the metadata of the job. This will mostly be useful for checking the\n     * status of a previously-run job.\n     *\n     * @resource [Jobs: get API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/get}\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The metadata of the job.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * var job = bigquery.job('id');\n     * job.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: bigQuery,\n    baseUrl: '/jobs',\n    id: id,\n    methods: methods\n  });\n\n  events.EventEmitter.call(this);\n\n  this.bigQuery = bigQuery;\n\n  // The API endpoint for cancel is:    .../bigquery/v2/project/projectId/...\n  // The rest of the API endpoints are: .../bigquery/v2/projects/projectId/...\n  // Reference: https://github.com/GoogleCloudPlatform/gcloud-node/issues/1027\n  this.interceptors.push({\n    request: function(reqOpts) {\n      if (reqOpts.uri.indexOf('/cancel') > -1) {\n        reqOpts.uri = reqOpts.uri.replace('/projects/', '/project/');\n      }\n      return reqOpts;\n    }\n  });\n\n  this.completeListeners = 0;\n  this.hasActiveListeners = false;\n\n  this.listenForEvents_();\n}\n\nmodelo.inherits(Job, ServiceObject, events.EventEmitter);\n\n/**\n * Cancel a job. Use {module:bigquery/job#getMetadata} to see if the cancel\n * completes successfully. See an example implementation below.\n *\n * @resource [Jobs: get API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/cancel}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * job.cancel(function(err, apiResponse) {\n *   // Check to see if the job completes successfully.\n *   job.on('error', function(err) {});\n *   job.on('complete', function(metadata) {});\n * });\n */\nJob.prototype.cancel = function(callback) {\n  callback = callback || util.noop;\n\n  this.request({\n    method: 'POST',\n    uri: '/cancel'\n  }, function(err, resp) {\n    callback(err, resp);\n  });\n};\n\n/**\n * Get the results of a job.\n *\n * @resource [Jobs: getQueryResults API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/getQueryResults}\n *\n * @param {object=} options - Configuration object.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of results to read.\n * @param {string} options.pageToken - Page token, returned by a previous call,\n *     to request the next page of results. Note: This is automatically added to\n *     the `nextQuery` argument of your callback.\n * @param {number} options.startIndex - Zero-based index of the starting row.\n * @param {number} options.timeoutMs - How long to wait for the query to\n *     complete, in milliseconds, before returning. Default is to return\n *     immediately. If the timeout passes before the job completes, the request\n *     will fail with a `TIMEOUT` error.\n * @param {function=} callback - The callback function. If you intend to\n *     continuously run this query until all results are in as part of a stream,\n *     do not pass a callback.\n * @param {?error} callback.err - An error returned while making this request\n * @param {array} callback.rows - The results of a job.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // Get all of the results of a query.\n * //-\n * job.getQueryResults(function(err, rows) {\n *   if (!err) {\n *     // rows is an array of results.\n *   }\n * });\n *\n * //-\n * // Customize the results you want to fetch.\n * //-\n * job.getQueryResults({\n *   maxResults: 100\n * }, function(err, rows) {});\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * var callback = function(err, rows, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     job.getQueryResults(nextQuery, callback);\n *   }\n * };\n *\n * job.getQueryResults({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Consume the results from the query as a readable object stream.\n * //-\n * var through2 = require('through2');\n * var fs = require('fs');\n *\n * job.getQueryResults()\n *   .pipe(through2.obj(function (row, enc, next) {\n *     this.push(JSON.stringify(row) + '\\n');\n *     next();\n *   }))\n *   .pipe(fs.createWriteStream('./test/testdata/testfile.json'));\n */\nJob.prototype.getQueryResults = function(options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  options.job = this;\n  return this.bigQuery.query(options, callback);\n};\n\n/**\n * Begin listening for events on the job. This method keeps track of how many\n * \"complete\" listeners are registered and removed, making sure polling is\n * handled automatically.\n *\n * As long as there is one active \"complete\" listener, the connection is open.\n * When there are no more listeners, the polling stops.\n *\n * @private\n */\nJob.prototype.listenForEvents_ = function() {\n  var self = this;\n\n  this.on('newListener', function(event) {\n    if (event === 'complete') {\n      self.completeListeners++;\n\n      if (!self.hasActiveListeners) {\n        self.hasActiveListeners = true;\n        self.startPolling_();\n      }\n    }\n  });\n\n  this.on('removeListener', function(event) {\n    if (event === 'complete' && --self.completeListeners === 0) {\n      self.hasActiveListeners = false;\n    }\n  });\n};\n\n/**\n * Poll `getMetadata` to check the operation's status. This runs a loop to ping\n * the API on an interval.\n *\n * Note: This method is automatically called once a \"complete\" event handler is\n * registered on the operation.\n *\n * @private\n */\nJob.prototype.startPolling_ = function() {\n  var self = this;\n\n  if (!this.hasActiveListeners) {\n    return;\n  }\n\n  this.getMetadata(function(err, metadata, apiResponse) {\n    if (apiResponse.status && apiResponse.status.errors) {\n      err = util.ApiError(apiResponse.status);\n    }\n\n    if (err) {\n      self.emit('error', err);\n      return;\n    }\n\n    if (metadata.status.state !== 'DONE') {\n      setTimeout(self.startPolling_.bind(self), 500);\n      return;\n    }\n\n    self.emit('complete', metadata);\n  });\n};\n\nmodule.exports = Job;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/common/service.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module common/service\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar extend = require('extend');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('./util.js');\n\n/**\n * Service is a base class, meant to be inherited from by a \"service,\" like\n * BigQuery or Storage.\n *\n * This handles making authenticated requests by exposing a `makeReq_` function.\n *\n * @constructor\n * @alias module:common/service\n *\n * @param {object} config - Configuration object.\n * @param {string} config.baseUrl - The base URL to make API requests to.\n * @param {string[]} config.scopes - The scopes required for the request.\n * @param {object} options - [Configuration object](#/docs).\n */\nfunction Service(config, options) {\n  var reqCfg = extend({}, config, {\n    credentials: options.credentials,\n    keyFile: options.keyFilename,\n    email: options.email\n  });\n\n  this.makeAuthenticatedRequest = util.makeAuthenticatedRequestFactory(reqCfg);\n\n  this.authClient = this.makeAuthenticatedRequest.authClient;\n  this.baseUrl = config.baseUrl;\n  this.getCredentials = this.makeAuthenticatedRequest.getCredentials;\n  this.globalInterceptors = arrify(options.interceptors_);\n  this.interceptors = [];\n  this.projectId = options.projectId;\n  this.projectIdRequired = config.projectIdRequired !== false;\n}\n\n/**\n * Make an authenticated API request.\n *\n * @private\n *\n * @param {object} reqOpts - Request options that are passed to `request`.\n * @param {string} reqOpts.uri - A URI relative to the baseUrl.\n * @param {function} callback - The callback function passed to `request`.\n */\nService.prototype.request = function(reqOpts, callback) {\n  reqOpts = extend(true, {}, reqOpts);\n\n  var isAbsoluteUrl = reqOpts.uri.indexOf('http') === 0;\n\n  var uriComponents = [\n    this.baseUrl\n  ];\n\n  if (this.projectIdRequired) {\n    uriComponents.push('projects');\n    uriComponents.push(this.projectId);\n  }\n\n  uriComponents.push(reqOpts.uri);\n\n  if (isAbsoluteUrl) {\n    uriComponents.splice(0, uriComponents.indexOf(reqOpts.uri));\n  }\n\n  reqOpts.uri = uriComponents\n    .map(function(uriComponent) {\n      var trimSlashesRegex = /^\\/*|\\/*$/g;\n      return uriComponent.replace(trimSlashesRegex, '');\n    })\n    .join('/')\n    // Some URIs have colon separators.\n    // Bad: https://.../projects/:list\n    // Good: https://.../projects:list\n    .replace(/\\/:/g, ':');\n\n  // Interceptors should be called in the order they were assigned.\n  var combinedInterceptors = [].slice.call(this.globalInterceptors)\n    .concat(this.interceptors)\n    .concat(arrify(reqOpts.interceptors_));\n\n  var interceptor;\n\n  while ((interceptor = combinedInterceptors.shift()) && interceptor.request) {\n    reqOpts = interceptor.request(reqOpts);\n  }\n\n  delete reqOpts.interceptors_;\n\n  return this.makeAuthenticatedRequest(reqOpts, callback);\n};\n\nmodule.exports = Service;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/bigtable/index.js":"/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module bigtable\n */\n\n'use strict';\n\nvar googleProtoFiles = require('google-proto-files');\nvar is = require('is');\nvar nodeutil = require('util');\nvar format = require('string-format-obj');\nvar extend = require('extend');\n\n/**\n * @type {module:bigtable/table}\n * @private\n */\nvar Table = require('./table.js');\n\n/**\n * @type {module:common/grpcService}\n * @private\n */\nvar GrpcService = require('../common/grpc-service.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * Interact with\n * [Google Cloud Bigtable](https://cloud.google.com/bigtable/).\n *\n * @constructor\n * @alias module:bigtable\n *\n * @classdesc\n * The `gcloud.bigtable` object allows you interact with Google Cloud Bigtable.\n *\n * To learn more about Bigtable, read the\n * [Google Cloud Bigtable Concepts Overview](https://cloud.google.com/bigtable/docs/concepts)\n *\n * @resource [Creating a Cloud Bigtable Cluster]{@link https://cloud.google.com/bigtable/docs/creating-compute-instance}\n *\n * @param {object=} options - [Configuration object](#/docs).\n * @param {string} options.cluster - The cluster name that hosts your tables.\n * @param {string|module:compute/zone} options.zone - The zone in which your\n *     cluster resides.\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'my-project'\n * });\n *\n * var bigtable = gcloud.bigtable({\n *   zone: 'us-central1-b',\n *   cluster: 'gcloud-node'\n * });\n *\n * //-\n * // <h3>Creating a Cluster</h3>\n * //\n * // Before you create your table, you first need to create a Bigtable Cluster\n * // for the table to be served from. This can be done from either the\n * // Google Cloud Platform Console or the `gcloud` cli tool. Please refer to\n * // the <a href=\"https://cloud.google.com/bigtable/docs/creating-compute-instance\">\n * // official Bigtable documentation</a> for more information.\n * //-\n *\n * //-\n * // <h3>Creating Tables</h3>\n * //\n * // After creating your cluster and enabling the Bigtable APIs, you are now\n * // ready to create your table with {module:bigtable#createTable}.\n * //-\n * bigtable.createTable('prezzy', function(err, table) {\n *   // `table` is your newly created Table object.\n * });\n *\n * //-\n * // <h3>Creating Column Families</h3>\n * //\n * // Column families are used to group together various pieces of data within\n * // your table. You can think of column families as a mechanism to categorize\n * // all of your data.\n * //\n * // We can create a column family with {module:bigtable/table#createFamily}.\n * //-\n * var table = bigtable.table('prezzy');\n *\n * table.createFamily('follows', function(err, family) {\n *   // `family` is your newly created Family object.\n * });\n *\n * //-\n * // <h3>Creating Rows</h3>\n * //\n * // New rows can be created within your table using\n * // {module:bigtable/table#insert}. You must provide a unique key for each row\n * // to be inserted, this key can then be used to retrieve your row at a later\n * // time.\n * //\n * // With Bigtable, all columns have a unique id composed of a column family\n * // and a column qualifier. In the example below `follows` is the column\n * // family and `tjefferson` is the column qualifier. Together they could be\n * // referred to as `follows:tjefferson`.\n * //-\n * var rows = [\n *   {\n *     key: 'wmckinley',\n *     data: {\n *       follows: {\n *         tjefferson: 1\n *       }\n *     }\n *   }\n * ];\n *\n * table.insert(rows, function(err) {\n *   if (!err) {\n *     // Your rows were successfully inserted.\n *   }\n * });\n *\n * //-\n * // <h3>Retrieving Rows</h3>\n * //\n * // If you're anticipating a large number of rows to be returned, we suggest\n * // using the {module:bigtable/table#getRows} streaming API.\n * //-\n * table.getRows()\n *   .on('error', console.error)\n *   .on('data', function(row) {\n *     // `row` is a Row object.\n *   });\n *\n * //-\n * // If you're not anticpating a large number of results, a callback mode\n * // is also available.\n * //-\n * var callback = function(err, rows) {\n *   // `rows` is an array of Row objects.\n * };\n *\n * table.getRows(callback);\n *\n * //-\n * // A range of rows can be retrieved by providing `start` and `end` row keys.\n * //-\n * var options = {\n *   start: 'gwashington',\n *   end: 'wmckinley'\n * };\n *\n * table.getRows(options, callback);\n *\n * //-\n * // Retrieve an individual row with {module:bigtable/row#get}.\n * //-\n * var row = table.row('alincoln');\n *\n * row.get(function(err) {\n *   // `row.data` is now populated.\n * });\n *\n * //-\n * // <h3>Accessing Row Data</h3>\n * //\n * // When retrieving rows, upon success the `row.data` property will be\n * // populated by an object. That object will contain additional objects\n * // for each family in your table that the row has data for.\n * //\n * // By default, when retrieving rows, each column qualifier will provide you\n * // with all previous versions of the data. So your `row.data` object could\n * // resemble the following.\n * //-\n * console.log(row.data);\n * // {\n * //   follows: {\n * //     wmckinley: [\n * //       {\n * //         value: 1,\n * //         timestamp: 1466017315951\n * //       }, {\n * //         value: 2,\n * //         timestamp: 1458619200000\n * //       }\n * //     ]\n * //   }\n * // }\n *\n * //-\n * // The `timestamp` field can be used to order cells from newest to oldest.\n * // If you only wish to retrieve the most recent version of the data, you\n * // can specify the number of cells with a {module:bigtable/filter} object.\n * //-\n * var filter = [\n *   {\n *     column: {\n *       cellLimit: 1\n *     }\n *   }\n * ];\n *\n * table.getRows({\n *   filter: filter\n * }, callback);\n *\n * //-\n * // <h3>Deleting Row Data</h3>\n * //\n * // We can delete all of an individual row's cells using\n * // {module:bigtable/row#delete}.\n * //-\n * var callback = function(err) {\n *   if (!err) {\n *     // All cells for this row were deleted successfully.\n *   }\n * };\n *\n * row.delete(callback);\n *\n * //-\n * // To delete a specific set of cells, we can provide an array of\n * // column families and qualifiers.\n * //-\n * var cells = [\n *   'follows:gwashington',\n *   'traits'\n * ];\n *\n * row.delete(cells, callback);\n *\n * //-\n * // <h3>Deleting Rows</h3>\n * //\n * // If you wish to delete multiple rows entirely, we can do so with\n * // {module:bigtable/table#deleteRows}. You can provide this method with a\n * // row key prefix.\n * //-\n * var options = {\n *   prefix: 'gwash'\n * };\n *\n * table.deleteRows(options, function(err) {\n *   if (!err) {\n *     // Rows were deleted successfully.\n *   }\n * });\n *\n * //-\n * // If you omit the prefix, you can delete all rows in your table.\n * //-\n * table.deleteRows(function(err) {\n *   if (!err) {\n *     // All rows were deleted successfully.\n *   }\n * });\n */\nfunction Bigtable(options) {\n  if (!(this instanceof Bigtable)) {\n    options = util.normalizeArguments(this, options);\n    return new Bigtable(options);\n  }\n\n  options = extend({}, options, {\n    zone: options.zone.name || options.zone\n  });\n\n  this.clusterName = format(\n    'projects/{projectId}/zones/{zone}/clusters/{cluster}',\n    options\n  );\n\n  var config = {\n    baseUrl: 'bigtable.googleapis.com',\n    service: 'bigtable',\n    apiVersion: 'v1',\n    protoServices: {\n      BigtableService: googleProtoFiles.bigtable.v1,\n      BigtableTableService: {\n        path: googleProtoFiles.bigtable.admin,\n        service: 'bigtable.admin.table'\n      }\n    },\n    scopes: [\n      'https://www.googleapis.com/auth/bigtable.admin',\n      'https://www.googleapis.com/auth/bigtable.data'\n    ]\n  };\n\n  GrpcService.call(this, config, options);\n}\n\nnodeutil.inherits(Bigtable, GrpcService);\n\n/**\n * Formats the full table name into a user friendly version.\n *\n * @private\n *\n * @param {string} name - The formatted Table name.\n * @return {string}\n *\n * @example\n * Bigtable.formatTableName_('projects/p/zones/z/clusters/c/tables/my-table');\n * // => 'my-table'\n */\nBigtable.formatTableName_ = function(name) {\n  if (name.indexOf('/') === -1) {\n    return name;\n  }\n\n  var parts = name.split('/');\n  return parts[parts.length - 1];\n};\n\n/**\n * Create a table on your Bigtable cluster.\n *\n * @resource [Designing Your Schema]{@link https://cloud.google.com/bigtable/docs/schema-design}\n * @resource [Splitting Keys]{@link https://cloud.google.com/bigtable/docs/managing-tables#splits}\n *\n * @param {string} name - The name of the table.\n * @param {object=} options - Table creation options.\n * @param {string} options.operation - Operation used for table that has already\n *    been queued to be created.\n * @param {string[]} options.splits - Initial\n *    [split keys](https://cloud.google.com/bigtable/docs/managing-tables#splits).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:bigtable/table} callback.table - The newly created table.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var callback = function(err, table, apiResponse) {\n *   // `table` is a Table object.\n * };\n *\n * bigtable.createTable('prezzy', callback);\n *\n * //-\n * // Pre-split the table based on the row key to spread the load across\n * // multiple Cloud Bigtable nodes.\n * //-\n * var options = {\n *   splits: ['10', '20']\n * };\n *\n * bigtable.createTable('prezzy', options, callback);\n */\nBigtable.prototype.createTable = function(name, options, callback) {\n  var self = this;\n\n  options = options || {};\n\n  if (is.function(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var protoOpts = {\n    service: 'BigtableTableService',\n    method: 'createTable'\n  };\n\n  var reqOpts = {\n    name: this.clusterName,\n    tableId: name,\n    table: {\n      // The granularity at which timestamps are stored in the table.\n      // Currently only milliseconds is supported, so it's not configurable.\n      granularity: 0\n    }\n  };\n\n  if (options.operation) {\n    reqOpts.table.currentOperation = options.operation;\n  }\n\n  if (options.splits) {\n    reqOpts.initialSplitKeys = options.splits;\n  }\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var table = self.table(resp.name);\n    table.metadata = resp;\n\n    callback(null, table, resp);\n  });\n};\n\n/**\n * Get Table objects for all the tables in your Bigtable cluster.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:bigtable/table[]} callback.tables - List of all Tables.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * bigtable.getTables(function(err, tables) {\n *   if (!err) {\n *     // `tables` is an array of Table objects.\n *   }\n * });\n */\nBigtable.prototype.getTables = function(callback) {\n  var self = this;\n\n  var protoOpts = {\n    service: 'BigtableTableService',\n    method: 'listTables'\n  };\n\n  var reqOpts = {\n    name: this.clusterName\n  };\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var tables = resp.tables.map(function(metadata) {\n      var name = Bigtable.formatTableName_(metadata.name);\n      var table = self.table(name);\n\n      table.metadata = metadata;\n      return table;\n    });\n\n    callback(null, tables, resp);\n  });\n};\n\n/**\n * Get a reference to a Bigtable table.\n *\n * @param {string} name - The name of the table.\n * @return {module:bigtable/table}\n *\n * @example\n * var table = bigtable.table('presidents');\n */\nBigtable.prototype.table = function(name) {\n  return new Table(this, name);\n};\n\nmodule.exports = Bigtable;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/bigtable/table.js":"/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module bigtable/table\n */\n\n'use strict';\n\nvar nodeutil = require('util');\nvar arrify = require('arrify');\nvar is = require('is');\nvar propAssign = require('prop-assign');\nvar through = require('through2');\nvar concat = require('concat-stream');\nvar pumpify = require('pumpify');\nvar flatten = require('lodash.flatten');\n\n/**\n * @type {module:bigtable/family}\n * @private\n */\nvar Family = require('./family.js');\n\n/**\n * @type {module:bigtable/row}\n * @private\n */\nvar Row = require('./row.js');\n\n/**\n * @type {module:bigtable/filter}\n * @private\n */\nvar Filter = require('./filter.js');\n\n/**\n * @type {module:bigtable/mutation}\n * @private\n */\nvar Mutation = require('./mutation.js');\n\n/**\n * @type {module:common/grpcServiceObject}\n * @private\n */\nvar GrpcServiceObject = require('../common/grpc-service-object.js');\n\n/**\n * Create a Table object to interact with a Google Cloud Bigtable table.\n *\n * @constructor\n * @alias module:bigtable/table\n *\n * @param {string} name - Name of the table.\n *\n * @example\n * var gcloud = require('gcloud');\n *\n * var bigtable = gcloud.bigtable({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123',\n *   cluster: 'gcloud-node',\n *   zone: 'us-central1-b'\n * });\n *\n * var table = bigtable.table('prezzy');\n */\nfunction Table(bigtable, name) {\n  var id = Table.formatName_(bigtable.clusterName, name);\n\n  var methods = {\n\n    /**\n     * Create a table.\n     *\n     * @param {object=} options - See {module:bigtable#createTable}.\n     *\n     * @example\n     * table.create(function(err, table, apiResponse) {\n     *   if (!err) {\n     *     // The table was created successfully.\n     *   }\n     * });\n     */\n    create: true,\n\n    /**\n     * Delete the table.\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * table.delete(function(err, apiResponse) {});\n     */\n    delete: {\n      protoOpts: {\n        service: 'BigtableTableService',\n        method: 'deleteTable'\n      },\n      reqOpts: {\n        name: id\n      }\n    },\n\n    /**\n     * Check if a table exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the table exists or not.\n     *\n     * @example\n     * table.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a table if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * table.get(function(err, table, apiResponse) {\n     *   // The `table` data has been populated.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the table's metadata.\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The table's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * table.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: {\n      protoOpts: {\n        service: 'BigtableTableService',\n        method: 'getTable'\n      },\n      reqOpts: {\n        name: id\n      }\n    }\n  };\n\n  var config = {\n    parent: bigtable,\n    id: id,\n    methods: methods,\n    createMethod: function(_, options, callback) {\n      bigtable.createTable(name, options, callback);\n    }\n  };\n\n  GrpcServiceObject.call(this, config);\n}\n\nnodeutil.inherits(Table, GrpcServiceObject);\n\n/**\n * Formats the table name to include the Bigtable cluster.\n *\n * @private\n *\n * @param {string} clusterName - The formatted cluster name.\n * @param {string} name - The table name.\n *\n * @example\n * Table.formatName_(\n *   'projects/my-project/zones/my-zone/clusters/my-cluster',\n *   'my-table'\n * );\n * // 'projects/my-project/zones/my-zone/clusters/my-cluster/tables/my-table'\n */\nTable.formatName_ = function(clusterName, name) {\n  if (name.indexOf('/') > -1) {\n    return name;\n  }\n\n  return clusterName + '/tables/' + name;\n};\n\n/**\n * Formats a row range into the desired proto format.\n *\n * @private\n *\n * @param {object} range - The range object.\n * @param {string} range.start - The lower bound for the range.\n * @param {string} range.end - The upper bound for the range.\n * @return {object}\n *\n * @example\n * Table.formatRowRange_({\n *   start: 'gwashington',\n *   end: 'alincoln'\n * });\n * // {\n * //   startKey: new Buffer('gwashington'),\n * //   endKey: new Buffer('alincoln')\n * // }\n */\nTable.formatRowRange_ = function(range) {\n  var rowRange = {};\n\n  if (range.start) {\n    rowRange.startKey = Mutation.convertToBytes(range.start);\n  }\n\n  if (range.end) {\n    rowRange.endKey = Mutation.convertToBytes(range.end);\n  }\n\n  return rowRange;\n};\n\n/**\n * Create a column family.\n *\n * Optionally you can send garbage collection rules and expressions when\n * creating a family. Garbage collection executes opportunistically in the\n * background, so it's possible for reads to return a cell even if it\n * matches the active expression for its family.\n *\n * @resource [Garbage Collection Proto Docs]{@link https://github.com/googleapis/googleapis/blob/master/google/bigtable/admin/table/v1/bigtable_table_data.proto#L59}\n *\n * @param {string} name - The name of column family.\n * @param {string|object=} rule - Garbage collection rule.\n * @param {object=} rule.age - Delete cells in a column older than the given\n *     age. Values must be at least 1 millisecond.\n * @param {number} rule.versions - Maximum number of versions to delete cells\n *     in a column, except for the most recent.\n * @param {boolean} rule.intersect - Cells to delete should match all rules.\n * @param {boolean} rule.union - Cells to delete should match any of the rules.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:bigtable/family} callback.family - The newly created Family.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var callback = function(err, family, apiResponse) {\n *   // `family` is a Family object\n * };\n *\n * var rule = {\n *   age: {\n *     seconds: 0,\n *     nanos: 5000\n *   },\n *   versions: 3,\n *   union: true\n * };\n *\n * table.createFamily('follows', rule, callback);\n *\n * //-\n * // Alternatively you can send a garbage collection expression.\n * //-\n * var expression = 'version() > 3 || (age() > 3d && version() > 1)';\n *\n * table.createFamily('follows', expression, callback);\n */\nTable.prototype.createFamily = function(name, rule, callback) {\n  var self = this;\n\n  if (is.function(rule)) {\n    callback = rule;\n    rule = null;\n  }\n\n  var grpcOpts = {\n    service: 'BigtableTableService',\n    method: 'createColumnFamily'\n  };\n\n  var reqOpts = {\n    name: this.id,\n    columnFamilyId: name\n  };\n\n  if (is.string(rule)) {\n    reqOpts.columnFamily = {\n      gcExpression: rule\n    };\n  } else if (is.object(rule)) {\n    reqOpts.columnFamily = {\n      gcRule: Family.formatRule_(rule)\n    };\n  }\n\n  this.request(grpcOpts, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var family = self.family(resp.name);\n    family.metadata = resp;\n    callback(null, family, resp);\n  });\n};\n\n/**\n * Delete all rows in the table, optionally corresponding to a particular\n * prefix.\n *\n * @param {options=} options - Configuration object.\n * @param {string} options.prefix - Row key prefix, when omitted all rows\n *     will be deleted.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // You can supply a prefix to delete all corresponding rows.\n * //-\n * var callback = function(err, apiResponse) {\n *   if (!err) {\n *     // Rows successfully deleted.\n *   }\n * };\n *\n * table.deleteRows({\n *   prefix: 'alincoln'\n * }, callback);\n *\n * //-\n * // If you choose to omit the prefix, all rows in the table will be deleted.\n * //-\n * table.deleteRows(callback);\n */\nTable.prototype.deleteRows = function(options, callback) {\n  if (is.function(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var grpcOpts = {\n    service: 'BigtableTableService',\n    method: 'bulkDeleteRows'\n  };\n\n  var reqOpts = {\n    tableName: this.id\n  };\n\n  if (options.prefix) {\n    reqOpts.rowKeyPrefix = Mutation.convertToBytes(options.prefix);\n  } else {\n    reqOpts.deleteAllDataFromTable = true;\n  }\n\n  this.request(grpcOpts, reqOpts, callback);\n};\n\n/**\n * Get a reference to a Table Family.\n *\n * @param {string} name - The family name.\n * @return {module:bigtable/family}\n *\n * @example\n * var family = table.family('my-family');\n */\nTable.prototype.family = function(name) {\n  return new Family(this, name);\n};\n\n/**\n * Get Family objects for all the column familes in your table.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:bigtable/family[]} callback.families - The list of families.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * table.getFamilies(function(err, families, apiResponse) {\n *   // `families` is an array of Family objects.\n * });\n */\nTable.prototype.getFamilies = function(callback) {\n  var self = this;\n\n  this.getMetadata(function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var families = Object.keys(resp.columnFamilies).map(function(familyId) {\n      var family = self.family(familyId);\n      family.metadata = resp.columnFamilies[familyId];\n      return family;\n    });\n\n    callback(null, families, resp);\n  });\n};\n\n/**\n * Get Row objects for the rows currently in your table.\n *\n * @param {options=} options - Configuration object.\n * @param {string} options.key - An individual row key.\n * @param {string[]} options.keys - A list of row keys.\n * @param {string} options.start - Start value for key range.\n * @param {string} options.end - End value for key range.\n * @param {object[]} options.ranges - A list of key ranges.\n * @param {module:bigtable/filter} options.filter - Row filters allow you to\n *     both make advanced queries and format how the data is returned.\n * @param {boolean} options.interleave - Allow for interleaving.\n * @param {number} options.limit - Maximum number of rows to be returned.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:bigtable/row[]} callback.rows - List of Row objects.\n *\n * @example\n * //-\n * // While this method does accept a callback, this is not recommended for\n * // large datasets as it will buffer all rows before executing the callback.\n * // Instead we recommend using the streaming API by simply omitting the\n * // callback.\n * //-\n * var callback = function(err, rows) {\n *   if (!err) {\n *     // `rows` is an array of Row objects.\n *   }\n * };\n *\n * table.getRows(callback);\n *\n * //-\n * // Specify a single row to be returned.\n * //-\n * table.getRows({\n *   key: 'alincoln'\n * }, callback);\n *\n * //-\n * // Specify arbitrary keys for a non-contiguous set of rows.\n * // The total size of the keys must remain under 1MB, after encoding.\n * //-\n * table.getRows({\n *   keys: [\n *     'alincoln',\n *     'gwashington'\n *   ]\n * }, callback);\n *\n * //-\n * // Specify a contiguous range of rows to read by supplying `start` and `end`\n * // keys.\n * //\n * // If the `start` key is omitted, it is interpreted as an empty string.\n * // If the `end` key is omitted, it is interpreted as infinity.\n * //-\n * table.getRows({\n *   start: 'alincoln',\n *   end: 'gwashington'\n * }, callback);\n *\n * //-\n * // Specify multiple ranges.\n * //-\n * table.getRows({\n *   ranges: [{\n *     start: 'alincoln',\n *     end: 'gwashington'\n *   }, {\n *     start: 'tjefferson',\n *     end: 'jadams'\n *   }]\n * }, callback);\n *\n * //-\n * // By default, rows are read sequentially, producing results which are\n * // guaranteed to arrive in increasing row order. Setting `interleave` to\n * // true allows multiple rows to be interleaved in the response, which\n * // increases throughput but breaks this guarantee and may force the client\n * // to use more memory to buffer partially-received rows.\n * //-\n * table.getRows({\n *   interleave: true\n * }, callback);\n *\n * //-\n * // Apply a {module:bigtable/filter} to the contents of the specified rows.\n * //-\n * table.getRows({\n *   filter: [\n *     {\n *       column: 'gwashington'\n *     }, {\n *       value: 1\n *     }\n *   ]\n * }, callback);\n *\n * //-\n * // Get the rows from your table as a readable object stream.\n * //-\n * table.getRows()\n *   .on('error', console.error)\n *   .on('data', function(row) {\n *     // `row` is a Row object.\n *   })\n *   .on('end', function() {\n *     // All rows retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing.\n * //-\n * table.getRows()\n *   .on('data', function(row) {\n *     this.end();\n *   });\n */\nTable.prototype.getRows = function(options, callback) {\n  var self = this;\n\n  if (is.function(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  var grpcOpts = {\n    service: 'BigtableService',\n    method: 'readRows'\n  };\n\n  var reqOpts = {\n    tableName: this.id,\n    objectMode: true\n  };\n\n  if (options.key) {\n    reqOpts.rowKey = Mutation.convertToBytes(options.key);\n  } else if (options.start || options.end) {\n    reqOpts.rowRange = Table.formatRowRange_(options);\n  } else if (options.keys || options.ranges) {\n    reqOpts.rowSet = {};\n\n    if (options.keys) {\n      reqOpts.rowSet.rowKeys = options.keys.map(Mutation.convertToBytes);\n    }\n\n    if (options.ranges) {\n      reqOpts.rowSet.rowRanges = options.ranges.map(Table.formatRowRange_);\n    }\n  }\n\n  if (options.filter) {\n    reqOpts.filter = Filter.parse(options.filter);\n  }\n\n  if (options.interleave) {\n    reqOpts.allowRowInterleaving = options.interleave;\n  }\n\n  if (options.limit) {\n    reqOpts.numRowsLimit = options.limit;\n  }\n\n  var stream = pumpify.obj([\n    this.requestStream(grpcOpts, reqOpts),\n    through.obj(function(rowData, enc, next) {\n      var row = self.row(Mutation.convertFromBytes(rowData.rowKey));\n\n      row.data = Row.formatChunks_(rowData.chunks);\n      next(null, row);\n    })\n  ]);\n\n  if (!is.function(callback)) {\n    return stream;\n  }\n\n  stream\n    .on('error', callback)\n    .pipe(concat(function(rows) {\n      callback(null, rows);\n    }));\n};\n\n/**\n * Insert or update rows in your table.\n *\n * @param {object|object[]} entries - List of entries to be inserted.\n *     See {module:bigtable/table#mutate}.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var entries = [\n *  {\n *     key: 'alincoln',\n *     data: {\n *       follows: {\n *         gwashington: 1\n *       }\n *     }\n *   }\n * ];\n *\n * table.insert(entries, function(err, apiResponse) {});\n *\n * //-\n * // By default whenever you insert new data, the server will capture a\n * // timestamp of when your data was inserted. It's possible to provide a\n * // date object to be used instead.\n * //-\n * var entries = [\n *   {\n *     key: 'gwashington',\n *     data: {\n *       follows: {\n *         jadams: {\n *           value: 1,\n *           timestamp: new Date('March 22, 2016')\n *         }\n *       }\n *     }\n *   }\n * ];\n *\n * table.insert(entries, function(err, apiResponse) {});\n */\nTable.prototype.insert = function(entries, callback) {\n  entries = arrify(entries).map(propAssign('method', Mutation.methods.INSERT));\n\n  return this.mutate(entries, callback);\n};\n\n/**\n * Apply a set of changes to be atomically applied to the specified row(s).\n * Mutations are applied in order, meaning that earlier mutations can be masked\n * by later ones.\n *\n * @param {object|object[]} entries - List of entities to be inserted or\n *     deleted.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // Insert entities. See {module:bigtable/table#insert}\n * //-\n * var callback = function(err, apiResponse) {\n *   if (!err) {\n *     // Mutations were successful.\n *   }\n * };\n *\n * var entries = [\n *   {\n *     method: 'insert',\n *     key: 'gwashington',\n *     data: {\n *       follows: {\n *         jadams: 1\n *       }\n *     }\n *   }\n * ];\n *\n * table.mutate(entries, callback)\n *\n * //-\n * // Delete entities. See {module:bigtable/row#deleteCells}\n * //-\n * var entries = [\n *   {\n *     method: 'delete',\n *     key: 'gwashington'\n *   }\n * ];\n *\n * table.mutate(entries, callback);\n *\n * //-\n * // Delete specific columns within a row.\n * //-\n * var entries = [\n *   {\n *     method: 'delete',\n *     key: 'gwashington',\n *     data: [\n *       'follows:jadams'\n *     ]\n *   }\n * ];\n *\n * table.mutate(entries, callback);\n *\n * //-\n * // Mix and match mutations. This must contain at least one entry and at\n * // most 100,000.\n * //-\n * var entries = [\n *   {\n *     method: 'insert',\n *     key: 'alincoln',\n *     data: {\n *       follows: {\n *         gwashington: 1\n *       }\n *     }\n *   }, {\n *     method: 'delete',\n *     key: 'jadams',\n *     data: [\n *       'follows:gwashington'\n *     ]\n *   }\n * ];\n *\n * table.mutate(entries, callback);\n */\nTable.prototype.mutate = function(entries, callback) {\n  entries = flatten(arrify(entries)).map(Mutation.parse);\n\n  var grpcOpts = {\n    service: 'BigtableService',\n    method: 'mutateRows'\n  };\n\n  var reqOpts = {\n    tableName: this.id,\n    entries: entries\n  };\n\n  this.request(grpcOpts, reqOpts, callback);\n};\n\n/**\n * Get a reference to a table row.\n *\n * @param {string} key - The row key.\n * @return {module:bigtable/row}\n *\n * @example\n * var row = table.row('lincoln');\n */\nTable.prototype.row = function(key) {\n  return new Row(this, key);\n};\n\n/**\n * Returns a sample of row keys in the table. The returned row keys will delimit\n * contigous sections of the table of approximately equal size, which can be\n * used to break up the data for distributed tasks like mapreduces.\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object[]} callback.keys - The list of keys.\n *\n * @example\n * table.sampleRowKeys(function(err, keys) {\n *   // keys = [\n *   //   {\n *   //     key: '',\n *   //     offset: '805306368'\n *   //   },\n *   //   ...\n *   // ]\n * });\n *\n * //-\n * // Get the keys from your table as a readable object stream.\n * //-\n * table.sampleRowKeys()\n *   .on('error', console.error)\n *   .on('data', function(key) {\n *     // Do something with the `key` object.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing.\n * //-\n * table.sampleRowKeys()\n *   .on('data', function(key) {\n *     this.end();\n *   });\n */\nTable.prototype.sampleRowKeys = function(callback) {\n  var grpcOpts = {\n    service: 'BigtableService',\n    method: 'sampleRowKeys'\n  };\n\n  var reqOpts = {\n    tableName: this.id,\n    objectMode: true\n  };\n\n  var stream = pumpify.obj([\n    this.requestStream(grpcOpts, reqOpts),\n    through.obj(function(key, enc, next) {\n      next(null, {\n        key: key.rowKey,\n        offset: key.offsetBytes\n      });\n    })\n  ]);\n\n  if (!is.function(callback)) {\n    return stream;\n  }\n\n  stream\n    .on('error', callback)\n    .pipe(concat(function(keys) {\n      callback(null, keys);\n    }));\n};\n\nmodule.exports = Table;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/bigtable/family.js":"/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n /*!\n * @module bigtable/family\n */\n\n'use strict';\n\nvar createErrorClass = require('create-error-class');\nvar nodeutil = require('util');\nvar is = require('is');\n\n/**\n * @private\n */\nvar FamilyError = createErrorClass('FamilyError', function(name) {\n  this.message = 'Column family not found: ' + name + '.';\n  this.code = 404;\n});\n\n/**\n * @type {module:common/grpcServiceObject}\n * @private\n */\nvar GrpcServiceObject = require('../common/grpc-service-object.js');\n\n/**\n * Create a Family object to interact with your table column families.\n *\n * @constructor\n * @alias module:bigtable/family\n *\n * @example\n * var gcloud = require('gcloud');\n *\n * var bigtable = gcloud.bigtable({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123',\n *   cluster: 'gcloud-node',\n *   zone: 'us-central1-b'\n * });\n *\n * var table = bigtable.table('prezzy');\n * var family = table.family('follows');\n */\nfunction Family(table, name) {\n  var id = Family.formatName_(table.id, name);\n\n  var methods = {\n\n    /**\n     * Create a column family.\n     *\n     * @param {object=} options - See {module:bigtable/table#createFamily}.\n     *\n     * @example\n     * family.create(function(err, family, apiResponse) {\n     *   // The column family was created successfully.\n     * });\n     */\n    create: true,\n\n    /**\n     * Delete the column family.\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * family.delete(function(err, apiResponse) {});\n     */\n    delete: {\n      protoOpts: {\n        service: 'BigtableTableService',\n        method: 'deleteColumnFamily'\n      },\n      reqOpts: {\n        name: id\n      }\n    },\n\n    /**\n     * Check if the column family exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the family exists or not.\n     *\n     * @example\n     * family.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a column family if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * family.get(function(err, family, apiResponse) {\n     *   // `family.metadata` has been populated.\n     * });\n     */\n    get: true\n  };\n\n  var config = {\n    parent: table,\n    id: id,\n    methods: methods,\n    createMethod: function(_, options, callback) {\n      table.createFamily(name, options, callback);\n    }\n  };\n\n  GrpcServiceObject.call(this, config);\n}\n\nnodeutil.inherits(Family, GrpcServiceObject);\n\n/**\n * Format the Column Family name into the expected proto format.\n *\n * @private\n *\n * @param {string} tableName - The full formatted table name.\n * @param {string} name - The column family name.\n * @return {string}\n *\n * @example\n * Family.formatName_(\n *   'projects/p/zones/z/clusters/c/tables/t',\n *   'my-family'\n * );\n * // 'projects/p/zones/z/clusters/c/tables/t/columnFamilies/my-family'\n */\nFamily.formatName_ = function(tableName, name) {\n  if (name.indexOf('/') > -1) {\n    return name;\n  }\n\n  return tableName + '/columnFamilies/' + name;\n};\n\n/**\n * Formats Garbage Collection rule into proto format.\n *\n * @private\n *\n * @param {object} ruleObj - The rule object.\n * @return {object}\n *\n * @example\n * Family.formatRule({\n *   age: {\n *     seconds: 10000,\n *     nanos: 10000\n *   },\n *   versions: 2,\n *   union: true\n * });\n * // {\n * //   union: {\n * //     rules: [\n * //       {\n * //         maxAge: {\n * //           seconds: 10000,\n * //           nanos: 10000\n * //         }\n * //       }, {\n * //         maxNumVersions: 2\n * //       }\n * //     ]\n * //   }\n * // }\n */\nFamily.formatRule_ = function(ruleObj) {\n  var rules = [];\n\n  if (ruleObj.age) {\n    rules.push({\n      maxAge: ruleObj.age\n    });\n  }\n\n  if (ruleObj.versions) {\n    rules.push({\n      maxNumVersions: ruleObj.versions\n    });\n  }\n\n  if (!ruleObj.intersection && !ruleObj.union) {\n    return rules[0];\n  }\n\n  var rule = {};\n  var ruleType = ruleObj.union ? 'union' : 'intersection';\n\n  rule[ruleType] = {\n    rules: rules\n  };\n\n  return rule;\n};\n\n/**\n * Get the column family's metadata.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {object} callback.metadata - The metadata.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * family.getMetadata(function(err, metadata, apiResponse) {});\n */\nFamily.prototype.getMetadata = function(callback) {\n  var self = this;\n\n  this.parent.getFamilies(function(err, families, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    for (var i = 0, l = families.length; i < l; i++) {\n      if (families[i].id === self.id) {\n        self.metadata = families[i].metadata;\n        callback(null, self.metadata, resp);\n        return;\n      }\n    }\n\n    var error = new FamilyError(self.id);\n    callback(error, null, resp);\n  });\n};\n\n/**\n * Set the column family's metadata.\n *\n * See {module:bigtable/table#createFamily} for a detailed explanation of the\n * arguments.\n *\n * @resource [Garbage Collection Proto Docs]{@link https://github.com/googleapis/googleapis/blob/3592a7339da5a31a3565870989beb86e9235476e/google/bigtable/admin/table/v1/bigtable_table_data.proto#L59}\n *\n * @param {object} metadata - Metadata object.\n * @param {object|string=} metadata.rule - Garbage collection rule.\n * @param {string=} metadata.name - The updated column family name.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * family.setMetadata({\n *   name: 'updated-name',\n *   rule: 'version() > 3 || (age() > 3d && version() > 1)'\n * }, function(err, apiResponse) {});\n */\nFamily.prototype.setMetadata = function(metadata, callback) {\n  var grpcOpts = {\n    service: 'BigtableTableService',\n    method: 'updateColumnFamily'\n  };\n\n  var reqOpts = {\n    name: this.id\n  };\n\n  if (metadata.rule) {\n    if (is.string(metadata.rule)) {\n      reqOpts.gcExpression = metadata.rule;\n    } else if (is.object(metadata.rule)) {\n      reqOpts.gcRule = Family.formatRule_(metadata.rule);\n    }\n  }\n\n  if (metadata.name) {\n    reqOpts.name = Family.formatName_(this.parent.id, metadata.name);\n  }\n\n  this.request(grpcOpts, reqOpts, callback);\n};\n\nmodule.exports = Family;\nmodule.exports.FamilyError = FamilyError;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/common/grpc-service-object.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module common/grpc-service-object\n */\n\n'use strict';\n\nvar extend = require('extend');\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('./service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('./util.js');\n\n/**\n * GrpcServiceObject is a base class, meant to be inherited from by a service\n * object that uses the gRPC protobuf API.\n *\n * @constructor\n * @alias module:common/grpc-service-object\n *\n * @private\n *\n * @param {object} config - Configuration object.\n */\nfunction GrpcServiceObject(config) {\n  ServiceObject.call(this, config);\n}\n\nnodeutil.inherits(GrpcServiceObject, ServiceObject);\n\n/**\n * Delete the object.\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n */\nGrpcServiceObject.prototype.delete = function(callback) {\n  var protoOpts = this.methods.delete.protoOpts;\n  var reqOpts = this.methods.delete.reqOpts;\n\n  this.request(protoOpts, reqOpts, callback || util.noop);\n};\n\n/**\n * Get the metadata of this object.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.metadata - The metadata for this object.\n */\nGrpcServiceObject.prototype.getMetadata = function(callback) {\n  var protoOpts = this.methods.getMetadata.protoOpts;\n  var reqOpts = this.methods.getMetadata.reqOpts;\n\n  this.request(protoOpts, reqOpts, callback);\n};\n\n/**\n * Set the metadata for this object.\n *\n * @param {object} metadata - The metadata to set on this object.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n */\nGrpcServiceObject.prototype.setMetadata = function(metadata, callback) {\n  var protoOpts = this.methods.setMetadata.protoOpts;\n  var reqOpts = extend(true, {}, this.methods.setMetadata.reqOpts, metadata);\n\n  this.request(protoOpts, reqOpts, callback || util.noop);\n};\n\n/**\n * Patch a request to the GrpcService object.\n *\n * @private\n */\nGrpcServiceObject.prototype.request = function(protoOpts, reqOpts, callback) {\n  return this.parent.request(protoOpts, reqOpts, callback);\n};\n\n/**\n * Patch a streaming request to the GrpcService object.\n *\n * @private\n */\nGrpcServiceObject.prototype.requestStream = function(protoOpts, reqOpts) {\n  return this.parent.requestStream(protoOpts, reqOpts);\n};\n\nmodule.exports = GrpcServiceObject;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/bigtable/row.js":"/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n /*!\n * @module bigtable/row\n */\n\n'use strict';\n\nvar nodeutil = require('util');\nvar is = require('is');\nvar extend = require('extend');\nvar arrify = require('arrify');\nvar flatten = require('lodash.flatten');\nvar createErrorClass = require('create-error-class');\nvar dotProp = require('dot-prop');\n\n/**\n * @type {module:bigtable/mutation}\n * @private\n */\nvar Mutation = require('./mutation.js');\n\n/**\n * @type {module:bigtable/filter}\n * @private\n */\nvar Filter = require('./filter.js');\n\n/**\n * @type {module:common/grpcServiceObject}\n * @private\n */\nvar GrpcServiceObject = require('../common/grpc-service-object.js');\n\n/**\n * @private\n */\nvar RowError = createErrorClass('RowError', function(row) {\n  this.message = 'Unknown row: ' + row + '.';\n});\n\n/**\n * Create a Row object to interact with your table rows.\n *\n * @constructor\n * @alias module:bigtable/row\n *\n * @example\n * var gcloud = require('gcloud');\n *\n * var bigtable = gcloud.bigtable({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123',\n *   cluster: 'gcloud-node',\n *   zone: 'us-central1-b'\n * });\n *\n * var table = bigtable.table('prezzy');\n * var row = table.row('gwashington');\n */\nfunction Row(table, name) {\n  var methods = {\n\n    /**\n     * Check if the table row exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the row exists or not.\n     *\n     * @example\n     * row.exists(function(err, exists) {});\n     */\n    exists: true\n  };\n\n  var config = {\n    parent: table,\n    methods: methods,\n    id: name\n  };\n\n  GrpcServiceObject.call(this, config);\n\n  this.data = {};\n}\n\nnodeutil.inherits(Row, GrpcServiceObject);\n\n/**\n * Formats the row chunks into friendly format. Chunks contain 3 properties:\n *\n * `rowContents` - The row contents, this essentially is all data pertaining\n *     to a single family.\n *\n * `commitRow` - This is a boolean telling us the all previous chunks for this\n *     row are ok to consume.\n *\n * `resetRow` - This is a boolean telling us that all the previous chunks are to\n *     be discarded.\n *\n * @private\n *\n * @param {chunk[]} chunks - The list of chunks.\n *\n * @example\n * var chunks = [\n *   {\n *     rowContents: {\n *       name: 'follows',\n *       columns: [\n *         {\n *           qualifier: 'gwashington',\n *           cells: [\n *             {\n *               value: 1\n *             }\n *           ]\n *         }\n *       ]\n *     }\n *   }, {\n *     resetRow: true\n *   }, {\n *     rowContents: {\n *       name: 'follows',\n *       columns: [\n *         {\n *           qualifier: 'gwashington',\n *           cells: [\n *             {\n *               value: 2\n *             }\n *           ]\n *         }\n *       ]\n *     }\n *   }, {\n *     commitRow: true\n *   }\n * ];\n *\n * Row.formatChunks_(chunks);\n * // {\n * //   follows: {\n * //     gwashington: [\n * //       {\n * //         value: 2\n * //       }\n * //     ]\n * //   }\n * // }\n */\nRow.formatChunks_ = function(chunks) {\n  var families = [];\n  var chunkList = [];\n\n  chunks.forEach(function(chunk) {\n    if (chunk.resetRow) {\n      chunkList = [];\n    }\n\n    if (chunk.rowContents) {\n      chunkList.push(chunk.rowContents);\n    }\n\n    if (chunk.commitRow) {\n      families = families.concat(chunkList);\n      chunkList = [];\n    }\n  });\n\n  return Row.formatFamilies_(families);\n};\n\n/**\n * Formats a rowContents object into friendly format.\n *\n * @private\n *\n * @param {object[]} families - The row families.\n *\n * @example\n * var families = [\n *   {\n *     name: 'follows',\n *     columns: [\n *       {\n *         qualifier: 'gwashington',\n *         cells: [\n *           {\n *             value: 2\n *           }\n *         ]\n *       }\n *     ]\n *   }\n * ];\n *\n * Row.formatFamilies_(families);\n * // {\n * //   follows: {\n * //     gwashington: [\n * //       {\n * //         value: 2\n * //       }\n * //     ]\n * //   }\n * // }\n */\nRow.formatFamilies_ = function(families) {\n  var data = {};\n\n  families.forEach(function(family) {\n    var familyData = data[family.name] = {};\n\n    family.columns.forEach(function(column) {\n      var qualifier = Mutation.convertFromBytes(column.qualifier);\n\n      familyData[qualifier] = column.cells.map(function(cell) {\n        return {\n          value: Mutation.convertFromBytes(cell.value),\n          timestamp: cell.timestampMicros,\n          labels: cell.labels\n        };\n      });\n    });\n  });\n\n  return data;\n};\n\n/**\n * Create a new row in your table.\n *\n * @param {object=} entry - An entry. See {module:bigtable/table#insert}.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {module:bigtable/row} callback.row - The newly created row object.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var callback = function(err, apiResponse) {\n *   if (!err) {\n *     // Row successfully created\n *   }\n * };\n *\n * row.create(callback);\n *\n * //-\n * // Optionally, you can supply entry data.\n * //-\n * row.create({\n *   follows: {\n *      alincoln: 1\n *   }\n * }, callback);\n */\nRow.prototype.create = function(entry, callback) {\n  var self = this;\n\n  if (is.function(entry)) {\n    callback = entry;\n    entry = {};\n  }\n\n  entry = {\n    key: this.id,\n    data: entry,\n    method: Mutation.methods.INSERT\n  };\n\n  this.parent.mutate(entry, function(err, apiResponse) {\n    if (err) {\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    callback(null, self, apiResponse);\n  });\n};\n\n/**\n * Update a row with rules specifying how the row's contents are to be\n * transformed into writes. Rules are applied in order, meaning that earlier\n * rules will affect the results of later ones.\n *\n * @param {object|object[]} rules - The rules to apply to this row.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // Add an increment amount to an existing value, if the targeted cell is\n * // unset, it will be treated as containing a zero.\n * //-\n * var callback = function(err, apiResponse) {\n *   if (!err) {\n *     // The rules have successfully been applied.\n *   }\n * };\n *\n * row.createRules([\n *   {\n *     column: 'follows:gwashington',\n *     increment: 1\n *   }\n * ], callback);\n *\n * //-\n * // You can also create a rule that will append data to an existing value.\n * // If the targeted cell is unset, it will be treated as a containing an\n * // empty string.\n * //-\n * row.createRules([\n *   {\n *     column: 'follows:alincoln',\n *     append: ' Honest Abe!'\n *   }\n * ], callback);\n */\nRow.prototype.createRules = function(rules, callback) {\n  rules = arrify(rules).map(function(rule) {\n    var column = Mutation.parseColumnName(rule.column);\n    var ruleData = {\n      familyName: column.family,\n      columnQualifier: Mutation.convertToBytes(column.qualifier)\n    };\n\n    if (rule.append) {\n      ruleData.appendValue = Mutation.convertToBytes(rule.append);\n    }\n\n    if (rule.increment) {\n      ruleData.incrementAmount = rule.increment;\n    }\n\n    return ruleData;\n  });\n\n  var grpcOpts = {\n    service: 'BigtableService',\n    method: 'readModifyWriteRow'\n  };\n\n  var reqOpts = {\n    tableName: this.parent.id,\n    rowKey: Mutation.convertToBytes(this.id),\n    rules: rules\n  };\n\n  this.request(grpcOpts, reqOpts, callback);\n};\n\n/**\n * Mutates a row atomically based on the output of a filter. Depending on\n * whether or not any results are yielded, either the `onMatch` or `onNoMatch`\n * callback will be executed.\n *\n * @param {module:bigtable/filter} filter - Filter ot be applied to the contents\n *     of the row.\n * @param {?object[]} onMatch - A list of entries to be ran if a match is found.\n * @param {object[]=} onNoMatch - A list of entries to be ran if no matches are\n *     found.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {boolean} callback.matched - Whether a match was found or not.\n *\n * @example\n * var callback = function(err, matched) {\n *   if (!err) {\n *     // `matched` will let us know if a match was found or not.\n *   }\n * };\n *\n * var filter = [\n *   {\n *     family: 'follows'\n *   }, {\n *     column: 'alincoln',\n *   }, {\n *     value: 1\n *   }\n * ];\n *\n * var entries = [\n *   {\n *     method: 'insert',\n *     data: {\n *       follows: {\n *         jadams: 1\n *       }\n *     }\n *   }\n * ];\n *\n * row.filter(filter, entries, callback);\n *\n * //-\n * // Optionally, you can pass in an array of entries to be ran in the event\n * // that a match is not made.\n * //-\n * row.filter(filter, null, entries, callback);\n */\nRow.prototype.filter = function(filter, onMatch, onNoMatch, callback) {\n  var grpcOpts = {\n    service: 'BigtableService',\n    method: 'checkAndMutateRow'\n  };\n\n  if (is.function(onNoMatch)) {\n    callback = onNoMatch;\n    onNoMatch = [];\n  }\n\n  var reqOpts = {\n    tableName: this.parent.id,\n    rowKey: Mutation.convertToBytes(this.id),\n    predicateFilter: Filter.parse(filter),\n    trueMutations: createFlatMutationsList(onMatch),\n    falseMutations: createFlatMutationsList(onNoMatch)\n  };\n\n  this.request(grpcOpts, reqOpts, function(err, apiResponse) {\n    if (err) {\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    callback(null, apiResponse.predicateMatched, apiResponse);\n  });\n\n  function createFlatMutationsList(entries) {\n    entries = arrify(entries).map(function(entry) {\n      return Mutation.parse(entry).mutations;\n    });\n\n    return flatten(entries);\n  }\n};\n\n/**\n * Deletes all cells in the row.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * row.delete(function(err, apiResponse) {});\n */\nRow.prototype.delete = function(callback) {\n  var mutation = {\n    key: this.id,\n    method: Mutation.methods.DELETE\n  };\n\n  this.parent.mutate(mutation, callback);\n};\n\n/**\n * Delete specified cells from the row. See {module:bigtable/table#mutate}.\n *\n * @param {string[]} columns - Column names for the cells to be deleted.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // Delete individual cells.\n * //-\n * var callback = function(err, apiResponse) {\n *   if (!err) {\n *     // Cells were successfully deleted.\n *   }\n * };\n *\n * row.deleteCells([\n *   'follows:gwashington'\n * ], callback);\n *\n * //-\n * // Delete all cells within a family.\n * //-\n * row.deleteCells([\n *   'follows',\n * ], callback)\n */\nRow.prototype.deleteCells = function(columns, callback) {\n  var mutation = {\n    key: this.id,\n    data: arrify(columns),\n    method: Mutation.methods.DELETE\n  };\n\n  this.parent.mutate(mutation, callback);\n};\n\n/**\n * Get the row data. See {module:bigtable/table#getRows}.\n *\n * @param {string[]=} columns - List of specific columns to retrieve.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {module:bigtable/row} callback.row - The updated Row object.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // Use this method to grab an entire row\n * //-\n * var callback = function(err, row, apiResponse) {\n *   if (!err) {\n *     // `row.cells` has been updated.\n *   }\n * };\n *\n * row.get(callback);\n *\n * //-\n * // Or pass in an array of column names to populate specific cells.\n * // Under the hood this will create an interleave filter.\n * //-\n * row.get([\n *   'follows:gwashington',\n *   'follows:alincoln'\n * ], callback);\n */\nRow.prototype.get = function(columns, callback) {\n  var self = this;\n\n  if (is.function(columns)) {\n    callback = columns;\n    columns = [];\n  }\n\n  var filter;\n\n  columns = arrify(columns);\n\n  if (columns.length) {\n    var filters = columns\n      .map(Mutation.parseColumnName)\n      .map(function(column) {\n        var filters = [{ family: column.family }];\n\n        if (column.qualifier) {\n          filters.push({ column: column.qualifier });\n        }\n\n        return filters;\n      });\n\n    if (filters.length > 1) {\n      filter = [{\n        interleave: filters\n      }];\n    } else {\n      filter = filters[0];\n    }\n  }\n\n  var reqOpts = {\n    key: this.id,\n    filter: filter\n  };\n\n  this.parent.getRows(reqOpts, function(err, rows, apiResponse) {\n    if (err) {\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    var row = rows[0];\n\n    if (!row) {\n      err = new RowError(self.id);\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    extend(true, self.data, row.data);\n\n    // If the user specifies column names, we'll return back the row data we\n    // received. Otherwise, we'll return the row itself in a typical\n    // GrpcServiceObject#get fashion.\n    callback(null, columns.length ? row.data : self, apiResponse);\n  });\n};\n\n/**\n * Get the row's metadata.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {object} callback.metadata - The row's metadata.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * row.getMetadata(function(err, metadata, apiResponse) {});\n */\nRow.prototype.getMetadata = function(callback) {\n  this.get(function(err, row, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    callback(null, row.metadata, resp);\n  });\n};\n\n/**\n * Increment a specific column within the row. If the column does not\n * exist, it is automatically initialized to 0 before being incremented.\n *\n * @param {string} column - The column we are incrementing a value in.\n * @param {number=} value - The amount to increment by, defaults to 1.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {number} callback.value - The updated value of the column.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var callback = function(err, value, apiResponse) {\n *   if (!err) {\n *     // `value` is the value of the updated column.\n *   }\n * };\n *\n * row.increment('follows:gwashington', callback)\n *\n * //-\n * // Specify a custom amount to increment the column by.\n * //-\n * row.increment('follows:gwashington', 2, callback);\n *\n * //-\n * // To decrement a column, simply supply a negative value.\n * //-\n * row.increment('follows:gwashington', -1, callback);\n */\nRow.prototype.increment = function(column, value, callback) {\n  if (is.function(value)) {\n    callback = value;\n    value = 1;\n  }\n\n  var reqOpts = {\n    column: column,\n    increment: value\n  };\n\n  this.createRules(reqOpts, function(err, apiResponse) {\n    if (err) {\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    var data = Row.formatFamilies_(apiResponse.families);\n    var value = dotProp.get(data, column.replace(':', '.'))[0].value;\n\n    callback(null, value, apiResponse);\n  });\n};\n\n/**\n * Update the row cells.\n *\n * @param {string|object} key - Either a column name or an entry\n *     object to be inserted into the row. See {module:bigtable/table#insert}.\n * @param {*=} value - This can be omitted if using entry object.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // Update a single cell.\n * //-\n * var callback = function(err, apiResponse) {\n *   if (!err) {\n *     // The row has been successfully updated.\n *   }\n * };\n *\n * row.save('follows:jadams', 1, callback);\n *\n * //-\n * // Or update several cells at once.\n * //-\n * row.save({\n *   follows: {\n *     jadams: 1,\n *     wmckinley: 1\n *   }\n * }, callback);\n */\nRow.prototype.save = function(key, value, callback) {\n  var rowData;\n\n  if (is.string(key)) {\n    var column = Mutation.parseColumnName(key);\n\n    rowData = {};\n    rowData[column.family] = {};\n    rowData[column.family][column.qualifier] = value;\n  } else {\n    rowData = key;\n    callback = value;\n  }\n\n  var mutation = {\n    key: this.id,\n    data: rowData,\n    method: Mutation.methods.INSERT\n  };\n\n  this.parent.mutate(mutation, callback);\n};\n\nmodule.exports = Row;\nmodule.exports.RowError = RowError;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/bigtable/mutation.js":"/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n /*!\n * @module bigtable/mutation\n */\n\n'use strict';\n\nvar is = require('is');\nvar arrify = require('arrify');\nvar Int64 = require('node-int64');\n\n/**\n * Formats table mutations to be in the expected proto format.\n *\n * @constructor\n * @alias module:bigtable/mutation\n *\n * @example\n * var mutation = new Mutation({\n *   key: 'gwashington',\n *   method: 'insert',\n *   data: {\n *     jadams: 1\n *   }\n * });\n */\nfunction Mutation(mutation) {\n  this.key = mutation.key;\n  this.method = mutation.method;\n  this.data = mutation.data;\n}\n\n/**\n * Mutation methods\n *\n * INSERT => setCell\n * DELETE => deleteFrom*\n */\nvar methods = Mutation.methods = {\n  INSERT: 'insert',\n  DELETE: 'delete'\n};\n\n/**\n * Parses \"bytes\" returned from proto service.\n *\n * @param {string} bytes - Base64 encoded string.\n * @return {string}\n */\nMutation.convertFromBytes = function(bytes) {\n  var buf = new Buffer(bytes, 'base64');\n  var num = new Int64(buf).toNumber();\n\n  if (!isNaN(num) && isFinite(num)) {\n    return num;\n  }\n\n  return buf.toString();\n};\n\n/**\n * Converts data into a buffer for proto service.\n *\n * @param {string} data - The data to be sent.\n * @return {buffer}\n */\nMutation.convertToBytes = function(data) {\n  if (is.number(data)) {\n    return new Int64(data).toBuffer();\n  }\n\n  try {\n    return new Buffer(data);\n  } catch (e) {\n    return data;\n  }\n};\n\n/**\n * Takes date objects and creates a time range.\n *\n * @param {date} start - The start date.\n * @param {date} end - The end date.\n * @return {object}\n */\nMutation.createTimeRange = function(start, end) {\n  var range = {};\n\n  if (is.date(start)) {\n    range.startTimestampMicros = start.getTime();\n  }\n\n  if (is.date(end)) {\n    range.endTimestampMicros = end.getTime();\n  }\n\n  return range;\n};\n\n/**\n * Formats an `insert` mutation to what the proto service expects.\n *\n * @param {object} data - The entity data.\n * @return {object[]}\n *\n * @example\n * Mutation.encodeSetCell({\n *   follows: {\n *     gwashington: 1,\n *     alincoln: 1\n *   }\n * });\n * // [\n * //   {\n * //     setCell: {\n * //       familyName: 'follows',\n * //       columnQualifier: 'gwashington', // as buffer\n * //       timestampMicros: -1, // -1 means to use the server time\n * //       value: 1 // as buffer\n * //     }\n * //   }, {\n * //     setCell: {\n * //       familyName: 'follows',\n * //       columnQualifier: 'alincoln', // as buffer\n * //       timestampMicros: -1,\n * //       value: 1 // as buffer\n * //     }\n * //   }\n * // ]\n */\nMutation.encodeSetCell = function(data) {\n  var mutations = [];\n\n  Object.keys(data).forEach(function(familyName) {\n    var family = data[familyName];\n\n    Object.keys(family).forEach(function(cellName) {\n      var cell = family[cellName];\n\n      if (!is.object(cell)) {\n        cell = {\n          value: cell\n        };\n      }\n\n      var timestamp = cell.timestamp;\n\n      if (is.date(timestamp)) {\n        timestamp = timestamp.getTime();\n      }\n\n      var setCell = {\n        familyName: familyName,\n        columnQualifier: Mutation.convertToBytes(cellName),\n        timestampMicros: timestamp || -1,\n        value: Mutation.convertToBytes(cell.value)\n      };\n\n      mutations.push({ setCell: setCell });\n    });\n  });\n\n  return mutations;\n};\n\n/**\n * Formats a `delete` mutation to what the proto service expects. Depending\n * on what data is supplied to this method, it will return an object that can\n * will do one of the following:\n *\n * * Delete specific cells from a column.\n * * Delete all cells contained with a specific family.\n * * Delete all cells from an entire rows.\n *\n * @param {object} data - The entry data.\n * @return {object}\n *\n * @example\n * Mutation.encodeDelete([\n *   'follows:gwashington'\n * ]);\n * // {\n * //   deleteFromColumn: {\n * //     familyName: 'follows',\n * //     columnQualifier: 'gwashington', // as buffer\n * //     timeRange: null // optional\n * //   }\n * // }\n *\n * Mutation.encodeDelete([\n *   'follows'\n * ]);\n * // {\n * //   deleteFromFamily: {\n * //     familyName: 'follows'\n * //   }\n * // }\n *\n * Mutation.encodeDelete();\n * // {\n * //   deleteFromRow: {}\n * // }\n *\n * //-\n * // It's also possible to specify a time range when deleting specific columns.\n * //-\n * Mutation.encodeDelete([\n *   {\n *     column: 'follows:gwashington',\n *     time: {\n *       start: new Date('March 21, 2000'),\n *       end: new Date('March 21, 2001')\n *     }\n *   }\n * ]);\n */\nMutation.encodeDelete = function(data) {\n  if (!data) {\n    return [{\n      deleteFromRow: {}\n    }];\n  }\n\n  return arrify(data).map(function(mutation) {\n    if (is.string(mutation)) {\n      mutation = {\n        column: mutation\n      };\n    }\n\n    var column = Mutation.parseColumnName(mutation.column);\n\n    if (!column.qualifier) {\n      return {\n        deleteFromFamily: {\n          familyName: column.family\n        }\n      };\n    }\n\n    var timeRange;\n\n    if (mutation.time) {\n      timeRange = Mutation.createTimeRange(\n        mutation.time.start,\n        mutation.time.end\n      );\n    }\n\n    return {\n      deleteFromColumn: {\n        familyName: column.family,\n        columnQualifier: Mutation.convertToBytes(column.qualifier),\n        timeRange: timeRange\n      }\n    };\n  });\n};\n\n/**\n * Creates a new Mutation object and returns the proto JSON form.\n *\n * @param {object} entry - The entity data.\n * @return {object}\n */\nMutation.parse = function(mutation) {\n  if (!(mutation instanceof Mutation)) {\n    mutation = new Mutation(mutation);\n  }\n\n  return mutation.toProto();\n};\n\n/**\n * Parses a column name into an object.\n *\n * @param {string} column - The column name.\n * @return {object}\n *\n * @example\n * Mutation.parseColumnName('follows:gwashington');\n * // {\n * //  family: 'follows',\n * //  qualifier: 'gwashington'\n * // }\n */\nMutation.parseColumnName = function(column) {\n  var parts = column.split(':');\n\n  return {\n    family: parts[0],\n    qualifier: parts[1]\n  };\n};\n\n/**\n * Converts the mutation object into proto friendly JSON.\n *\n * return {object}\n */\nMutation.prototype.toProto = function() {\n  var mutation = {};\n\n  if (this.key) {\n    mutation.rowKey = Mutation.convertToBytes(this.key);\n  }\n\n  if (this.method === methods.INSERT) {\n    mutation.mutations = Mutation.encodeSetCell(this.data);\n  } else if (this.method === methods.DELETE) {\n    mutation.mutations = Mutation.encodeDelete(this.data);\n  }\n\n  return mutation;\n};\n\nmodule.exports = Mutation;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/bigtable/filter.js":"/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module bigtable/filter\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar is = require('is');\nvar createErrorClass = require('create-error-class');\nvar extend = require('extend');\n\n/**\n * @private\n * @type {module:bigtable/mutation}\n */\nvar Mutation = require('./mutation.js');\n\n/**\n * @private\n */\nvar FilterError = createErrorClass('FilterError', function(filter) {\n  this.message = 'Unknown filter: ' + filter + '.';\n});\n\n/**\n * A filter takes a row as input and produces an alternate view of the row based\n * on specified rules. For example, a row filter might trim down a row to\n * include just the cells from columns matching a given regular expression, or\n * might return all the cells of a row but not their values. More complicated\n * filters can be composed out of these components to express requests such as,\n * \"within every column of a particular family, give just the two most recent\n * cells which are older than timestamp X.\"\n *\n * There are two broad categories of filters (true filters and transformers),\n * as well as two ways to compose simple filters into more complex ones\n * ({module:bigtable/filter#interleave}). They work as follows:\n *\n * True filters alter the input row by excluding some of its cells wholesale\n * from the output row. An example of a true filter is the\n * {module:bigtable/filter#value} filter, which excludes cells whose values\n * don't match the specified pattern. All regex true filters use RE2 syntax\n * (https://github.com/google/re2/wiki/Syntax) and are evaluated as full\n * matches. An important point to keep in mind is that RE2(.) is equivalent by\n * default to RE2([^\\n]), meaning that it does not match newlines. When\n * attempting to match an arbitrary byte, you should therefore use the escape\n * sequence '\\C', which may need to be further escaped as '\\\\C' in your client\n * language.\n *\n * Transformers alter the input row by changing the values of some of its\n * cells in the output, without excluding them completely. Currently, the only\n * supported transformer is the {module:bigtable/filter#value} `strip` filter,\n * which replaces every cell's value with the empty string.\n *\n * The total serialized size of a filter message must not\n * exceed 4096 bytes, and filters may not be nested within each other to a depth\n * of more than 20.\n *\n * Use the following table for the various examples found throughout the\n * filter documentation.\n *\n * | Row Key     | follows:gwashington | follows:jadams | follows:tjefferson |\n * | ----------- |:-------------------:|:--------------:|:------------------:|\n * | gwashington |                     | 1              |                    |\n * | tjefferson  | 1                   | 1              |                    |\n * | jadams      | 1                   |                | 1                  |\n *\n * @constructor\n * @alias module:bigtable/filter\n */\nfunction Filter() {\n  this.filters_ = [];\n}\n\n/**\n * @private\n * @throws TypeError\n *\n * Transforms Arrays into a simple regular expression for matching multiple\n * values.\n *\n * @param {regex|string|string[]} regex - Either a plain regex, a regex in\n *     string form or an array of strings.\n *\n * @return {string}\n *\n * @example\n * var regexString = Filter.convertToRegExpString(['a', 'b', 'c']);\n * // => '(a|b|c)'\n */\nFilter.convertToRegExpString = function(regex) {\n  if (is.regexp(regex)) {\n    return regex.toString().replace(/^\\/|\\/$/g, '');\n  }\n\n  if (is.array(regex)) {\n    return '(' + regex.join('|') + ')';\n  }\n\n  if (is.string(regex)) {\n    return regex;\n  }\n\n  if (is.number(regex)) {\n    return regex.toString();\n  }\n\n  throw new TypeError('Can\\'t convert to RegExp String from unknown type.');\n};\n\n/**\n * @private\n *\n * Creates a range object. All bounds default to inclusive.\n *\n * @param {?object|string} start - Lower bound value.\n * @param {?object|string} end - Upper bound value.\n * @param {string} key - Key used to create range value keys.\n *\n * @return {object}\n *\n * @example\n * var range = Filter.createRange('value1', 'value2', 'Test');\n * // {\n * //   startTestInclusive: new Buffer('value1'),\n * //   endTestExclusive: new Buffer('value2')\n * // }\n *\n * //-\n * // It's also possible to pass in objects to specify inclusive/exclusive\n * // bounds.\n * //-\n * var upperBound = {\n *   value: 'value3',\n *   inclusive: false\n * };\n *\n * var range = Filter.createRange(upperBound, null, 'Test2');\n * // => {\n * //   startTest2Exclusive: 'value3'\n * // }\n */\nFilter.createRange = function(start, end, key) {\n  var range = {};\n\n  if (start) {\n    extend(range, createBound('start', start, key));\n  }\n\n  if (end) {\n    extend(range, createBound('end', end, key));\n  }\n\n  return range;\n\n  function createBound(boundName, boundData, key) {\n    var isInclusive = boundData.inclusive !== false;\n    var boundKey = boundName + key + (isInclusive ? 'Inclusive' : 'Exclusive');\n    var bound = {};\n\n    bound[boundKey] = Mutation.convertToBytes(boundData.value || boundData);\n    return bound;\n  }\n};\n\n/**\n * @private\n * @throws FilterError\n *\n * Turns filters into proto friendly format.\n *\n * @param {object[]} filters - The list of filters to be parsed.\n *\n * @return {object}\n *\n * @example\n * var filter = Filter.parse([\n *   {\n *     family: 'my-family',\n *   }, {\n *     column: 'my-column'\n *   }\n * ]);\n * // {\n * //   chain: {\n * //     filters: [\n * //       {\n * //         familyNameRegexFilter: 'my-family'\n * //       },\n * //       {\n * //         columnQualifierRegexFilter: 'my-column'\n * //       }\n * //     ]\n * //   }\n * // }\n */\nFilter.parse = function(filters) {\n  var filter = new Filter();\n\n  arrify(filters).forEach(function(filterObj) {\n    var key = Object.keys(filterObj)[0];\n\n    if (!is.function(filter[key])) {\n      throw new FilterError(key);\n    }\n\n    filter[key](filterObj[key]);\n  });\n\n  return filter.toProto();\n};\n\n/**\n * @example\n * //-\n * // Matches all cells, regardless of input. Functionally equivalent to\n * // leaving `filter` unset, but included for completeness.\n * //-\n * var filter = {\n *   all: true\n * };\n *\n * //-\n * // Does not match any cells, regardless of input. Useful for temporarily\n * // disabling just part of a filter.\n * //-\n * var filter = {\n *   all: false\n * };\n */\nFilter.prototype.all = function(pass) {\n  var filterName = pass ? 'passAllFilter' : 'blockAllFilter';\n\n  this.set(filterName, true);\n};\n\n/**\n * Matches only cells from columns whose qualifiers satisfy the given RE2\n * regex.\n *\n * Note that, since column qualifiers can contain arbitrary bytes, the '\\C'\n * escape sequence must be used if a true wildcard is desired. The '.'\n * character will not match the new line character '\\n', which may be\n * present in a binary qualifier.\n *\n * @example\n * //-\n * // Using the following filter, we would retrieve the `tjefferson` and\n * // `gwashington` columns.\n * //-\n * var filter = [\n *   {\n *     column: /[a-z]+on$/\n *   }\n * ];\n *\n * //-\n * // You can also provide a string (optionally containing regexp characters)\n * // for simple column filters.\n * //-\n * var filter = [\n *   {\n *     column: 'gwashington'\n *   }\n * ];\n *\n * //-\n * // Or you can provide an array of strings if you wish to match against\n * // multiple columns.\n * //-\n * var filter = [\n *   {\n *     column: [\n *       'gwashington',\n *       'tjefferson'\n *     ]\n *   }\n * ];\n *\n * //-\n * // If you wish to use additional column filters, consider using the following\n * // syntax.\n * //-\n * var filter = [\n *   {\n *     column: {\n *       name: 'gwashington'\n *     }\n *   }\n * ];\n *\n *\n * //-\n * // <h4>Column Cell Limits</h4>\n * //\n * // Matches only the most recent number of versions within each column. For\n * // example, if the `versions` is set to 2, this filter would only match\n * // columns updated at the two most recent timestamps.\n * //\n * // If duplicate cells are present, as is possible when using an\n * // {module:bigtable/filter#interleave} filter, each copy of the cell is\n * // counted separately.\n * //-\n * var filter = [\n *   {\n *     column: {\n *       cellLimit: 2\n *     }\n *   }\n * ];\n *\n * //-\n * // <h4>Column Ranges</h4>\n * //\n * // Specifies a contiguous range of columns within a single column family.\n * // The range spans from <column_family>:<start_qualifier> to\n * // <column_family>:<end_qualifier>, where both bounds can be either\n * // inclusive or exclusive. By default both are inclusive.\n * //\n * // When the `start` bound is omitted it is interpreted as an empty string.\n * // When the `end` bound is omitted it is interpreted as Infinity.\n * //-\n * var filter = [\n *   {\n *     column: {\n *       family: 'follows',\n *       start: 'gwashington',\n *       end: 'tjefferson'\n *     }\n *   }\n * ];\n *\n * //-\n * // By default, both the `start` and `end` bounds are inclusive. You can\n * // override these by providing an object explicity stating whether or not it\n * // is `inclusive`.\n * //-\n * var filter = [\n *   {\n *     column: {\n *       family: 'follows',\n *       start: {\n *         value: 'gwashington',\n *         inclusive: false\n *       },\n *       end: {\n *         value: 'jadams',\n *         inclusive: false\n *       }\n *     }\n *   }\n * ];\n */\nFilter.prototype.column = function(column) {\n  if (!is.object(column)) {\n    column = {\n      name: column\n    };\n  }\n\n  if (column.name) {\n    var name = Filter.convertToRegExpString(column.name);\n\n    name = Mutation.convertToBytes(name);\n    this.set('columnQualifierRegexFilter', name);\n  }\n\n  if (is.number(column.cellLimit)) {\n    this.set('cellsPerColumnLimitFilter', column.cellLimit);\n  }\n\n  if (column.start || column.end) {\n    var range = Filter.createRange(column.start, column.end, 'Qualifier');\n\n    range.familyName = column.family;\n    this.set('columnRangeFilter', range);\n  }\n};\n\n/**\n * A filter which evaluates one of two possible filters, depending on\n * whether or not a `test` filter outputs any cells from the input row.\n *\n * IMPORTANT NOTE: The `test` filter does not execute atomically with the\n * pass and fail filters, which may lead to inconsistent or unexpected\n * results. Additionally, condition filters have poor performance, especially\n * when filters are set for the fail condition.\n *\n * @example\n * //-\n * // In the following example we're creating a filter that will check if\n * // `gwashington` follows `tjefferson`. If he does, we'll get all of the\n * // `gwashington` data. If he does not, we'll instead return all of the\n * // `tjefferson` data.\n * //-\n * var filter = [\n *   {\n *     condition: {\n *       // If `test` outputs any cells, then `pass` will be evaluated on the\n *       // input row. Otherwise `fail` will be evaluated.\n *       test: [\n *         {\n *           row: 'gwashington'\n *         },\n *         {\n *           family: 'follows'\n *         },\n *         {\n *           column: 'tjefferson'\n *         }\n *       ],\n *\n *       // If omitted, no results will be returned in the true case.\n *       pass: [\n *         {\n *           row: 'gwashington'\n *         }\n *       ],\n *\n *       // If omitted, no results will be returned in the false case.\n *       fail: [\n *         {\n *           row: 'tjefferson'\n *         }\n *       ]\n *     }\n *   }\n * ];\n */\nFilter.prototype.condition = function(condition) {\n  this.set('condition', {\n    predicateFilter: Filter.parse(condition.test),\n    trueFilter: Filter.parse(condition.pass),\n    falseFilter: Filter.parse(condition.fail)\n  });\n};\n\n/**\n * Matches only cells from columns whose families satisfy the given RE2\n * regex. For technical reasons, the regex must not contain the ':'\n * character, even if it is not being used as a literal.\n * Note that, since column families cannot contain the new line character\n * '\\n', it is sufficient to use '.' as a full wildcard when matching\n * column family names.\n *\n * @example\n * var filter = [\n *   {\n *     family: 'follows'\n *   }\n * ];\n */\nFilter.prototype.family = function(family) {\n  family = Filter.convertToRegExpString(family);\n  this.set('familyNameRegexFilter', family);\n};\n\n/**\n * Applies several filters to the data in parallel and combines the results.\n *\n * The elements of \"filters\" all process a copy of the input row, and the\n * results are pooled, sorted, and combined into a single output row.\n * If multiple cells are produced with the same column and timestamp,\n * they will all appear in the output row in an unspecified mutual order.\n * All interleaved filters are executed atomically.\n *\n * @example\n * //-\n * // In the following example, we're creating a filter that will retrieve\n * // results for entries that were either created between December 17th, 2015\n * // and March 22nd, 2016 or entries that have data for `follows:tjefferson`.\n * //-\n * var filter = [\n *   {\n *     interleave: [\n *       [\n *         {\n *           time: {\n *             start: new Date('December 17, 2015'),\n *             end: new Date('March 22, 2016')\n *           }\n *         }\n *       ],\n *       [\n *         {\n *           family: 'follows'\n *         },\n *         {\n *           column: 'tjefferson'\n *         }\n *       ]\n *     ]\n *   }\n * ];\n */\nFilter.prototype.interleave = function(filters) {\n  this.set('interleave', {\n    filters: filters.map(Filter.parse)\n  });\n};\n\n/**\n * Applies the given label to all cells in the output row. This allows\n * the client to determine which results were produced from which part of\n * the filter.\n *\n * Values must be at most 15 characters in length, and match the RE2\n * pattern [a-z0-9\\\\-]+\n *\n * Due to a technical limitation, it is not currently possible to apply\n * multiple labels to a cell. As a result, a chain filter may have no more than\n * one sub-filter which contains a apply label transformer. It is okay for\n * an {module:bigtable/filter#interleave} to contain multiple apply label\n * transformers, as they will be applied to separate copies of the input. This\n * may be relaxed in the future.\n *\n * @example\n * var filter = {\n *   label: 'my-label'\n * };\n */\nFilter.prototype.label = function(label) {\n  this.set('applyLabelTransformer', label);\n};\n\n/**\n * @example\n * //-\n * // Matches only cells from rows whose keys satisfy the given RE2 regex. In\n * // other words, passes through the entire row when the key matches, and\n * // otherwise produces an empty row.\n * //\n * // Note that, since row keys can contain arbitrary bytes, the '\\C' escape\n * // sequence must be used if a true wildcard is desired. The '.' character\n * // will not match the new line character '\\n', which may be present in a\n * // binary key.\n * //\n * // In the following example we'll use a regular expression to match all\n * // row keys ending with the letters \"on\", which would then yield\n * // `gwashington` and `tjefferson`.\n * //-\n * var filter = [\n *   {\n *     row: /[a-z]+on$/\n *   }\n * ];\n *\n * //-\n * // You can also provide a string (optionally containing regexp characters)\n * // for simple key filters.\n * //-\n * var filter = [\n *   {\n *     row: 'gwashington'\n *   }\n * ];\n *\n * //-\n * // Or you can provide an array of strings if you wish to match against\n * // multiple keys.\n * //-\n * var filter = [\n *   {\n *     row: [\n *       'gwashington',\n *       'tjefferson'\n *     ]\n *   }\n * ];\n *\n * //-\n * // If you wish to use additional row filters, consider using the following\n * // syntax.\n * //-\n * var filter = [\n *   {\n *     row: {\n *       key: 'gwashington'\n *     }\n *   }\n * ];\n *\n * //-\n * // <h4>Row Samples</h4>\n * //\n * // Matches all cells from a row with probability p, and matches no cells\n * // from the row with probability 1-p.\n * //-\n * var filter = [\n *   {\n *     row: {\n *       sample: 1\n *     }\n *   }\n * ];\n *\n * //-\n * // <h4>Row Cell Offsets</h4>\n * //\n * // Skips the first N cells of each row, matching all subsequent cells.\n * // If duplicate cells are present, as is possible when using an\n * // {module:bigtable/filter#interleave}, each copy of the cell is counted\n * // separately.\n * //-\n * var filter = [\n *   {\n *     row: {\n *       cellOffset: 2\n *     }\n *   }\n * ];\n *\n * //-\n * // <h4>Row Cell Limits</h4>\n * //\n * // Matches only the first N cells of each row.\n * // If duplicate cells are present, as is possible when using an\n * // {module:bigtable/filter#interleave}, each copy of the cell is counted\n * // separately.\n * //-\n * var filter = [\n *   {\n *     row: {\n *       cellLimit: 4\n *     }\n *   }\n * ];\n */\nFilter.prototype.row = function(row) {\n  if (!is.object(row)) {\n    row = {\n      key: row\n    };\n  }\n\n  if (row.key) {\n    var key = Filter.convertToRegExpString(row.key);\n\n    key = Mutation.convertToBytes(key);\n    this.set('rowKeyRegexFilter', key);\n  }\n\n  if (row.sample) {\n    this.set('rowSampleFilter', row.sample);\n  }\n\n  if (is.number(row.cellOffset)) {\n    this.set('cellsPerRowOffsetFilter', row.cellOffset);\n  }\n\n  if (is.number(row.cellLimit)) {\n    this.set('cellsPerRowLimitFilter', row.cellLimit);\n  }\n};\n\n/**\n * Stores a filter object.\n *\n * @private\n *\n * @param {string} key - Filter name.\n * @param {*} value - Filter value.\n */\nFilter.prototype.set = function(key, value) {\n  var filter = {};\n\n  filter[key] = value;\n  this.filters_.push(filter);\n};\n\n/**\n * This filter is meant for advanced use only. Hook for introspection into the\n * filter. Outputs all cells directly to the output of the read rather than to\n * any parent filter.\n *\n * Despite being excluded by the qualifier filter, a copy of every cell that\n * reaches the sink is present in the final result.\n *\n * As with an {module:bigtable/filter#interleave} filter, duplicate cells are\n * possible, and appear in an unspecified mutual order.\n *\n * Cannot be used within {module:bigtable/filter#condition} filter.\n *\n * @example\n * //-\n * // Using the following filter, a copy of every cell that reaches the sink is\n * // present in the final result, despite being excluded by the qualifier\n * // filter\n * //-\n * var filter = [\n *   {\n *     family: 'follows'\n *   },\n *   {\n *     interleave: [\n *       [\n *         {\n *           all: true\n *         }\n *       ],\n *       [\n *         {\n *           label: 'prezzy'\n *         },\n *         {\n *           sink: true\n *         }\n *       ]\n *     ]\n *   },\n *   {\n *     column: 'gwashington'\n *   }\n * ];\n *\n * //-\n * // As with an {module:bigtable/filter#interleave} filter, duplicate cells\n * // are possible, and appear in an unspecified mutual order. In this case we\n * // have a duplicates with multiple `gwashington` columns because one copy\n * // passed through the {module:bigtable/filter#all} filter while the other was\n * // passed through the {module:bigtable/filter#label} and sink. Note that one\n * // copy has label \"prezzy\" while the other does not.\n * //-\n */\nFilter.prototype.sink = function(sink) {\n  this.set('sink', sink);\n};\n\n/**\n * Matches only cells with timestamps within the given range.\n *\n * @example\n * var filter = [\n *   {\n *     time: {\n *       start: new Date('December 17, 2006 03:24:00'),\n *       end: new Date()\n *     }\n *   }\n * ];\n */\nFilter.prototype.time = function(time) {\n  var range = Mutation.createTimeRange(time.start, time.end);\n  this.set('timestampRangeFilter', range);\n};\n\n/**\n * @private\n * If we detect multiple filters, we'll assume it's a chain filter and the\n * execution of the filters will be the order in which they were specified.\n */\nFilter.prototype.toProto = function() {\n  if (this.filters_.length === 1) {\n    return this.filters_[0];\n  }\n\n  return {\n    chain: {\n      filters: this.filters_\n    }\n  };\n};\n\n/**\n * Matches only cells with values that satisfy the given regular expression.\n * Note that, since cell values can contain arbitrary bytes, the '\\C' escape\n * sequence must be used if a true wildcard is desired. The '.' character\n * will not match the new line character '\\n', which may be present in a\n * binary value.\n *\n * @example\n * var filter = [\n *   {\n *     value: /[0-9]/\n *   }\n * ];\n *\n * //-\n * // You can also provide a string (optionally containing regexp characters)\n * // for value filters.\n * //-\n * var filter = [\n *   {\n *     value: '1'\n *   }\n * ];\n *\n * //-\n * // Or you can provide an array of strings if you wish to match against\n * // multiple values.\n * //-\n * var filter = [\n *   {\n *     value: ['1', '9']\n *   }\n * ];\n *\n * //-\n * // <h4>Value Ranges</h4>\n * //\n * // Specifies a contigous range of values.\n * //\n * // When the `start` bound is omitted it is interpreted as an empty string.\n * // When the `end` bound is omitted it is interpreted as Infinity.\n * //-\n * var filter = [\n *   {\n *     value: {\n *       start: '1',\n *       end: '9'\n *     }\n *   }\n * ];\n *\n * //-\n * // By default, both the `start` and `end` bounds are inclusive. You can\n * // override these by providing an object explicity stating whether or not it\n * // is `inclusive`.\n * //-\n * var filter = [\n *   {\n *     value: {\n *       start: {\n *         value: '1',\n *         inclusive: false\n *       },\n *       end: {\n *         value: '9',\n *         inclusive: false\n *       }\n *     }\n *   }\n * ];\n *\n * //-\n * // <h4>Strip Values</h4>\n * //\n * // Replaces each cell's value with an emtpy string.\n * //-\n * var filter = [\n *   {\n *     value: {\n *       strip: true\n *     }\n *   }\n * ];\n */\nFilter.prototype.value = function(value) {\n  if (!is.object(value)) {\n    value = {\n      value: value\n    };\n  }\n\n  if (value.value) {\n    var valueReg = Filter.convertToRegExpString(value.value);\n\n    valueReg = Mutation.convertToBytes(valueReg);\n    this.set('valueRegexFilter', valueReg);\n  }\n\n  if (value.start || value.end) {\n    var range = Filter.createRange(value.start, value.end, 'Value');\n\n    this.set('valueRangeFilter', range);\n  }\n\n  if (value.strip) {\n    this.set('stripValueTransformer', value.strip);\n  }\n};\n\nmodule.exports = Filter;\nmodule.exports.FilterError = FilterError;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/common/grpc-service.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module common/grpc-service\n */\n\n'use strict';\n\nvar googleProtoFiles = require('google-proto-files');\nvar grpc = require('grpc');\nvar is = require('is');\nvar nodeutil = require('util');\nvar path = require('path');\nvar retryRequest = require('retry-request');\nvar through = require('through2');\nvar dotProp = require('dot-prop');\nvar extend = require('extend');\n\n/**\n * @type {module:common/service}\n * @private\n */\nvar Service = require('./service.js');\n\n/**\n * @const {object} - A map of protobuf codes to HTTP status codes.\n * @private\n */\nvar GRPC_ERROR_CODE_TO_HTTP = {\n  0: {\n    code: 200,\n    message: 'OK'\n  },\n\n  1: {\n    code: 499,\n    message: 'Client Closed Request'\n  },\n\n  2: {\n    code: 500,\n    message: 'Internal Server Error'\n  },\n\n  3: {\n    code: 400,\n    message: 'Bad Request'\n  },\n\n  4: {\n    code: 504,\n    message: 'Gateway Timeout'\n  },\n\n  5: {\n    code: 404,\n    message: 'Not Found'\n  },\n\n  6: {\n    code: 409,\n    message: 'Conflict'\n  },\n\n  7: {\n    code: 403,\n    message: 'Forbidden'\n  },\n\n  8: {\n    code: 429,\n    message: 'Too Many Requests'\n  },\n\n  9: {\n    code: 412,\n    message: 'Precondition Failed'\n  },\n\n  10: {\n    code: 409,\n    message: 'Conflict'\n  },\n\n  11: {\n    code: 400,\n    message: 'Bad Request'\n  },\n\n  12: {\n    code: 501,\n    message: 'Not Implemented'\n  },\n\n  13: {\n    code: 500,\n    message: 'Internal Server Error'\n  },\n\n  14: {\n    code: 503,\n    message: 'Service Unavailable'\n  },\n\n  15: {\n    code: 500,\n    message: 'Internal Server Error'\n  },\n\n  16: {\n    code: 401,\n    message: 'Unauthorized'\n  }\n};\n\n/**\n * Service is a base class, meant to be inherited from by a \"service,\" like\n * BigQuery or Storage.\n *\n * This handles making authenticated requests by exposing a `makeReq_` function.\n *\n * @constructor\n * @alias module:common/grpc-service\n *\n * @param {object} config - Configuration object.\n * @param {string} config.baseUrl - The base URL to make API requests to.\n * @param {string[]} config.scopes - The scopes required for the request.\n * @param {string} config.service - The name of the service.\n * @param {object=} config.protoServices - Directly provide the required proto\n *     files. This is useful when a single class requires multiple services.\n * @param {object} options - [Configuration object](#/docs/?method=gcloud).\n */\nfunction GrpcService(config, options) {\n  if (global.GCLOUD_SANDBOX_ENV) {\n    // gRPC has a tendency to cause our doc unit tests to fail, so we prevent\n    // any calls to that library from going through.\n    // Reference: https://github.com/GoogleCloudPlatform/gcloud-node/pull/1137#issuecomment-193315047\n    return global.GCLOUD_SANDBOX_ENV;\n  }\n\n  Service.call(this, config, options);\n\n  if (config.customEndpoint) {\n    this.grpcCredentials = grpc.credentials.createInsecure();\n  }\n\n  this.maxRetries = options.maxRetries;\n\n  var apiVersion = config.apiVersion;\n  var service = this.service = config.service;\n\n  this.activeServiceMap_ = new Map();\n  this.protos = {};\n\n  var protoServices = config.protoServices;\n\n  if (!protoServices) {\n    protoServices = {};\n    protoServices[service] = googleProtoFiles[service][apiVersion];\n  }\n\n  for (var protoServiceName in protoServices) {\n    var protoService = this.loadProtoFile_(\n      protoServices[protoServiceName], config);\n\n    this.protos[protoServiceName] = protoService;\n  }\n}\n\nnodeutil.inherits(GrpcService, Service);\n\n/**\n * Make an authenticated request with gRPC.\n *\n * @param {object} protoOpts - The proto options.\n * @param {string} protoOpts.service - The service name.\n * @param {string} protoOpts.method - The method name.\n * @param {number=} protoOpts.timeout - After how many milliseconds should the\n *     request cancel.\n * @param {object} reqOpts - The request options.\n * @param {function=} callback - The callback function.\n */\nGrpcService.prototype.request = function(protoOpts, reqOpts, callback) {\n  if (global.GCLOUD_SANDBOX_ENV) {\n    return global.GCLOUD_SANDBOX_ENV;\n  }\n\n  var self = this;\n\n  if (!this.grpcCredentials) {\n    // We must establish an authClient to give to grpc.\n    this.getGrpcCredentials_(function(err, credentials) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      self.grpcCredentials = credentials;\n      self.request(protoOpts, reqOpts, callback);\n    });\n\n    return;\n  }\n\n  // Clean up gcloud-specific options.\n  delete reqOpts.autoPaginate;\n  delete reqOpts.autoPaginateVal;\n\n  var service = this.getService_(protoOpts);\n  var grpcOpts = {};\n\n  if (is.number(protoOpts.timeout)) {\n    grpcOpts.deadline = GrpcService.createDeadline_(protoOpts.timeout);\n  }\n\n  // Retains a reference to an error from the response. If the final callback is\n  // executed with this as the \"response\", we return it to the user as an error.\n  var respError;\n\n  var retryOpts = {\n    retries: this.maxRetries,\n    shouldRetryFn: GrpcService.shouldRetryRequest_,\n\n    // retry-request determines if it should retry from the incoming HTTP\n    // response status. gRPC always returns an error proto message. We pass that\n    // \"error\" into retry-request to act as the HTTP response, so it can use the\n    // status code to determine if it should retry.\n    request: function(_, onResponse) {\n      respError = null;\n\n      service[protoOpts.method](reqOpts, grpcOpts, function(err, resp) {\n        if (err) {\n          respError = GrpcService.decorateError_(err);\n\n          if (respError) {\n            onResponse(null, respError);\n            return;\n          }\n\n          onResponse(err, resp);\n          return;\n        }\n\n        onResponse(null, resp);\n      });\n    }\n  };\n\n  retryRequest(null, retryOpts, function(err, resp) {\n    if (!err && resp === respError) {\n      err = respError;\n      resp = null;\n    }\n\n    callback(err, resp);\n  });\n};\n\n/**\n * Make an authenticated streaming request with gRPC.\n *\n * @param {object} protoOpts - The proto options.\n * @param {string} protoOpts.service - The service git stat.\n * @param {string} protoOpts.method - The method name.\n * @param {number=} protoOpts.timeout - After how many milliseconds should the\n *     request cancel.\n * @param {object} reqOpts - The request options.\n */\nGrpcService.prototype.requestStream = function(protoOpts, reqOpts) {\n  if (global.GCLOUD_SANDBOX_ENV) {\n    return through.obj();\n  }\n\n  var self = this;\n\n  if (!protoOpts.stream) {\n    protoOpts.stream = through.obj();\n  }\n\n  var stream = protoOpts.stream;\n\n  if (!this.grpcCredentials) {\n    // We must establish an authClient to give to grpc.\n    this.getGrpcCredentials_(function(err, credentials) {\n      if (err) {\n        stream.destroy(err);\n        return;\n      }\n\n      self.grpcCredentials = credentials;\n      self.requestStream(protoOpts, reqOpts);\n    });\n\n    return stream;\n  }\n\n  var objectMode = !!reqOpts.objectMode;\n  delete reqOpts.objectMode;\n\n  var service = this.getService_(protoOpts);\n  var grpcOpts = {};\n\n  if (is.number(protoOpts.timeout)) {\n    grpcOpts.deadline = GrpcService.createDeadline_(protoOpts.timeout);\n  }\n\n  var retryOpts = {\n    retries: this.maxRetries,\n    objectMode: objectMode,\n    shouldRetryFn: GrpcService.shouldRetryRequest_,\n\n    request: function() {\n      return service[protoOpts.method](reqOpts, grpcOpts)\n        .on('status', function(status) {\n          var grcpStatus = GrpcService.decorateStatus_(status);\n\n          this.emit('response', grcpStatus || status);\n        });\n    }\n  };\n\n  return retryRequest(null, retryOpts)\n    .on('error', function(err) {\n      var grpcError = GrpcService.decorateError_(err);\n\n      stream.destroy(grpcError || err);\n    })\n    .pipe(stream);\n};\n\n/**\n * Decode a protobuf Struct's value.\n *\n * @private\n *\n * @param {object} value - A Struct's Field message.\n * @return {*} - The decoded value.\n */\nGrpcService.decodeValue_ = function(value) {\n  switch (value.kind) {\n    case 'structValue': {\n      return GrpcService.structToObj_(value.structValue);\n    }\n\n    case 'nullValue': {\n      return null;\n    }\n\n    case 'listValue': {\n      return value.listValue.values.map(GrpcService.decodeValue_);\n    }\n\n    default: {\n      return value[value.kind];\n    }\n  }\n};\n\n/**\n * Convert a raw value to a type-denoted protobuf message-friendly object.\n *\n * @private\n *\n * @param {*} value - The input value.\n * @param {object=} options - Configuration object.\n * @param {boolean} options.stringify - Stringify un-recognized types.\n * @return {*} - The encoded value.\n *\n * @example\n * GrpcService.encodeValue_('Hi');\n * // {\n * //   stringValue: 'Hello!'\n * // }\n */\nGrpcService.encodeValue_ = function(value, options) {\n  options = options || {};\n\n  var convertedValue;\n\n  if (is.null(value)) {\n    convertedValue = {\n      nullValue: 0\n    };\n  } else if (is.number(value)) {\n    convertedValue = {\n      numberValue: value\n    };\n  } else if (is.string(value)) {\n    convertedValue = {\n      stringValue: value\n    };\n  } else if (is.boolean(value)) {\n    convertedValue = {\n      boolValue: value\n    };\n  } else if (Buffer.isBuffer(value)) {\n    convertedValue = {\n      blobValue: value\n    };\n  } else if (is.object(value)) {\n    convertedValue = {\n      structValue: GrpcService.objToStruct_(value)\n    };\n  } else if (is.array(value)) {\n    convertedValue = {\n      listValue: {\n        values: value.map(GrpcService.encodeValue_)\n      }\n    };\n  } else {\n    if (!options.stringify) {\n      throw new Error('Value of type ' + typeof value + ' not recognized.');\n    }\n\n    convertedValue = {\n      stringValue: String(value)\n    };\n  }\n\n  return convertedValue;\n};\n\n/**\n * Creates a deadline.\n *\n * @private\n *\n * @param {number} timeout - Timeout in miliseconds.\n * @return {date} deadline - The deadline in Date object form.\n */\nGrpcService.createDeadline_ = function(timeout) {\n  return new Date(Date.now() + timeout);\n};\n\n/**\n * Checks for a grpc status code and extends the supplied object with additional\n * information.\n *\n * @private\n *\n * @param {object} obj - The object to be extended.\n * @param {object} response - The grpc response.\n * @return {object|null}\n */\nGrpcService.decorateGrpcResponse_ = function(obj, response) {\n  if (response && GRPC_ERROR_CODE_TO_HTTP[response.code]) {\n    var defaultResponseDetails = GRPC_ERROR_CODE_TO_HTTP[response.code];\n\n    return extend(true, obj, response, {\n      code: defaultResponseDetails.code,\n      message: response.message || defaultResponseDetails.message\n    });\n  }\n\n  return null;\n};\n\n/**\n * Checks for a grpc status code and extends the error object with additional\n * information.\n *\n * @private\n *\n * @param {error|object} err - The grpc error.\n * @return {error|null}\n */\nGrpcService.decorateError_ = function(err) {\n  var errorObj = is.error(err) ? new Error() : {};\n  return GrpcService.decorateGrpcResponse_(errorObj, err);\n};\n\n/**\n * Checks for grpc status code and extends the status object with additional\n * information\n *\n * @private\n * @param {object} status - The grpc status.\n * @return {object|null}\n */\nGrpcService.decorateStatus_ = function(status) {\n  return GrpcService.decorateGrpcResponse_({}, status);\n};\n\n/**\n * Function to decide whether or not a request retry could occur.\n *\n * @private\n *\n * @param {object} response - The request response.\n * @return {boolean} shouldRetry\n */\nGrpcService.shouldRetryRequest_ = function(response) {\n  return [429, 500, 502, 503].indexOf(response.code) > -1;\n};\n\n/**\n * Convert an object to a struct.\n *\n * @private\n *\n * @param {object} obj - An object to convert.\n * @param {object=} options - Configuration object.\n * @param {boolean} options.stringify - Stringify un-recognized types.\n * @return {array} - The converted object.\n *\n * @example\n * GrpcService.objToStruct_({\n *   greeting: 'Hello!',\n *   favNumber: 7,\n *   friendIds: [\n *     1004,\n *     1006\n *   ],\n *   userDetails: {\n *     termsSigned: true\n *   }\n * });\n * // {\n * //   fields: {\n * //     greeting: {\n * //       stringValue: 'Hello!'\n * //     },\n * //     favNumber: {\n * //       numberValue: 7\n * //     },\n * //     friendIds: {\n * //       listValue: [\n * //         {\n * //           numberValue: 1004\n * //         },\n * //         {\n * //           numberValue: 1006\n * //         }\n * //       ]\n * //     },\n * //     userDetails: {\n * //       fields: {\n * //         termsSigned: {\n * //           booleanValue: true\n * //         }\n * //       }\n * //     }\n * //   }\n * // }\n */\nGrpcService.objToStruct_ = function(obj, options) {\n  options = options || {};\n\n  var convertedObject = {\n    fields: {}\n  };\n\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      var value = obj[prop];\n\n      if (is.undefined(value)) {\n        continue;\n      }\n\n      convertedObject.fields[prop] = GrpcService.encodeValue_(value, options);\n    }\n  }\n\n  return convertedObject;\n};\n\n/**\n * Condense a protobuf Struct into an object of only its values.\n *\n * @private\n *\n * @param {object} struct - A protobuf Struct message.\n * @return {object} - The simplified object.\n *\n * @example\n * GrpcService.structToObj_({\n *   fields: {\n *     name: {\n *       kind: 'stringValue',\n *       stringValue: 'Stephen'\n *     }\n *   }\n * });\n * // {\n * //   name: 'Stephen'\n * // }\n */\nGrpcService.structToObj_ = function(struct) {\n  var convertedObject = {};\n\n  for (var prop in struct.fields) {\n    if (struct.fields.hasOwnProperty(prop)) {\n      var value = struct.fields[prop];\n      convertedObject[prop] = GrpcService.decodeValue_(value);\n    }\n  }\n\n  return convertedObject;\n};\n\n/**\n * To authorize requests through gRPC, we must get the raw google-auth-library\n * auth client object.\n *\n * @private\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error getting an auth client.\n */\nGrpcService.prototype.getGrpcCredentials_ = function(callback) {\n  this.authClient.getAuthClient(function(err, authClient) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var credentials = grpc.credentials.combineChannelCredentials(\n      grpc.credentials.createSsl(),\n      grpc.credentials.createFromGoogleCredential(authClient)\n    );\n\n    callback(null, credentials);\n  });\n};\n\n/**\n * Loads a proto file, useful when handling multiple proto files/services\n * within a single instance of GrpcService.\n *\n * @private\n *\n * @param {object} protoConfig - The proto specific configs for this file.\n * @param {object} config - The base config for the GrpcService.\n * @return {object} protoObject - The loaded proto object.\n */\nGrpcService.prototype.loadProtoFile_ = function(protoConfig, config) {\n  var rootDir = googleProtoFiles('..');\n\n  var grpcOpts = {\n    binaryAsBase64: true,\n    convertFieldsToCamelCase: true\n  };\n\n  if (is.string(protoConfig)) {\n    protoConfig = {\n      path: protoConfig\n    };\n  }\n\n  var services = grpc.load({\n    root: rootDir,\n    file: path.relative(rootDir, protoConfig.path)\n  }, 'proto', grpcOpts);\n\n  var serviceName = protoConfig.service || config.service;\n  var apiVersion = protoConfig.apiVersion || config.apiVersion;\n  var service = dotProp.get(services.google, serviceName);\n\n  return service[apiVersion];\n};\n\n/**\n * Retrieves the service object used to make the grpc requests.\n *\n * @private\n *\n * @param {object} protoOpts - The proto options.\n * @return {object} service - The proto service.\n */\nGrpcService.prototype.getService_ = function(protoOpts) {\n  var proto;\n\n  if (this.protos[protoOpts.service]) {\n    proto = this.protos[protoOpts.service];\n  } else {\n    proto = this.protos[this.service];\n  }\n\n  var service = this.activeServiceMap_.get(protoOpts.service);\n\n  if (!service) {\n    service = new proto[protoOpts.service](\n      this.baseUrl,\n      this.grpcCredentials\n    );\n\n    this.activeServiceMap_.set(protoOpts.service, service);\n  }\n\n  return service;\n};\n\nmodule.exports = GrpcService;\nmodule.exports.GRPC_ERROR_CODE_TO_HTTP = GRPC_ERROR_CODE_TO_HTTP;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/index.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar extend = require('extend');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:compute/firewall}\n * @private\n */\nvar Firewall = require('./firewall.js');\n\n/**\n * @type {module:compute/health-check}\n * @private\n */\nvar HealthCheck = require('./health-check.js');\n\n/**\n * @type {module:compute/network}\n * @private\n */\nvar Network = require('./network.js');\n\n/**\n * @type {module:compute/operation}\n * @private\n */\nvar Operation = require('./operation.js');\n\n/**\n * @type {module:compute/region}\n * @private\n */\nvar Region = require('./region.js');\n\n/**\n * @type {module:compute/rule}\n * @private\n */\nvar Rule = require('./rule.js');\n\n/**\n * @type {module:common/service}\n * @private\n */\nvar Service = require('../common/service.js');\n\n/**\n * @type {module:compute/service}\n * @private\n */\nvar ServiceClass = require('./service.js');\n\n/**\n * @type {module:compute/snapshot}\n * @private\n */\nvar Snapshot = require('./snapshot.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * @type {module:compute/zone}\n * @private\n */\nvar Zone = require('./zone.js');\n\n/**\n * A Compute object allows you to interact with the Google Compute Engine API.\n * Using this object, you can access your instances with {module:compute/vm},\n * disks with {module:compute/disk}, and firewalls with\n * {module:compute/firewall}.\n *\n * @alias module:compute\n * @constructor\n *\n * @classdesc\n * The object returned from `gcloud.compute` gives you complete control of your\n * Compute Engine virtual machines, disks, networks, snapshots, addresses,\n * firewalls, and more.\n *\n * To learn more about Compute Engine, see\n * [What is Google Compute Engine?](https://cloud.google.com/compute/docs)\n *\n * @param {object} options - [Configuration object](#/docs).\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n */\nfunction Compute(options) {\n  if (!(this instanceof Compute)) {\n    options = util.normalizeArguments(this, options);\n    return new Compute(options);\n  }\n\n  var config = {\n    baseUrl: 'https://www.googleapis.com/compute/v1',\n    scopes: ['https://www.googleapis.com/auth/compute']\n  };\n\n  Service.call(this, config, options);\n}\n\nnodeutil.inherits(Compute, Service);\n\n/**\n * Create a firewall.\n *\n * @resource [Firewalls Overview]{@link https://cloud.google.com/compute/docs/networking#firewalls}\n * @resource [Firewalls: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/firewalls/insert}\n *\n * @throws {Error} if a name is not provided.\n * @throws {Error} if a config object is not provided.\n *\n * @param {string} name - Name of the firewall.\n * @param {object} config - See a\n *     [Firewall resource](https://cloud.google.com/compute/docs/reference/v1/firewalls#resource).\n * @param {object} config.protocols - A map of protocol to port range. The keys\n *     of the object refer to a protocol (e.g. `tcp`, `udp`) and the value for\n *     the key are the ports/port-ranges that are allowed to make a connection.\n *     If a `true` value, that means all ports on that protocol will be opened.\n *     If `false`, all traffic on that protocol will be blocked.\n * @param {string[]} config.ranges - The IP address blocks that this rule\n *     applies to, expressed in\n *     [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)\n *     format.\n * @param {string[]} config.tags - Instance tags which this rule applies to.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/firewall} callback.firewall - The created Firewall\n *     object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var config = {\n *   protocols: {\n *     tcp: [3000],\n *     udp: [] // An empty array means all ports are allowed.\n *   },\n *\n *   ranges: ['0.0.0.0/0']\n * };\n *\n * function callback(err, firewall, operation, apiResponse) {\n *   // `firewall` is a Firewall object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * }\n *\n * gce.createFirewall('new-firewall-name', config, callback);\n */\nCompute.prototype.createFirewall = function(name, config, callback) {\n  var self = this;\n\n  if (!is.string(name)) {\n    throw new Error('A firewall name must be provided.');\n  }\n\n  if (!is.object(config)) {\n    throw new Error('A firewall configuration object must be provided.');\n  }\n\n  var body = extend({}, config, {\n    name: name\n  });\n\n  if (body.protocols) {\n    body.allowed = arrify(body.allowed);\n\n    for (var protocol in body.protocols) {\n      var allowedConfig = {\n        IPProtocol: protocol\n      };\n\n      var ports = body.protocols[protocol];\n\n      if (ports === false || ports.length === 0) {\n        continue;\n      }\n\n      // If the port is `true`, open up all ports on this protocol.\n      allowedConfig.ports = ports === true ? [] : arrify(ports);\n\n      body.allowed.push(allowedConfig);\n    }\n\n    delete body.protocols;\n  }\n\n  if (body.ranges) {\n    body.sourceRanges = arrify(body.ranges);\n    delete body.ranges;\n  }\n\n  if (body.tags) {\n    body.sourceTags = arrify(body.tags);\n    delete body.tags;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/global/firewalls',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var firewall = self.firewall(name);\n\n    var operation = self.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, firewall, operation, resp);\n  });\n};\n\n/**\n * Create an HTTP or HTTPS health check.\n *\n * @resource [Health Checks Overview]{@link https://cloud.google.com/compute/docs/load-balancing/health-checks}\n * @resource [HttpHealthCheck: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/httpHealthChecks/insert}\n * @resource [HttpsHealthCheck: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/httpsHealthChecks/insert}\n *\n * @param {string} name - Name of the HTTP or HTTPS health check to create.\n * @param {object=} options - See a\n *     [HttpHealthCheck resource](https://cloud.google.com/compute/docs/reference/v1/httpHealthChecks#resource)\n *     and [HttpsHealthCheck resource](https://cloud.google.com/compute/docs/reference/v1/httpsHealthChecks#resource).\n * @param {boolean} options.https - Create an HTTPs health check. Default:\n *     `false`.\n * @param {number} options.interval - How often (in seconds) to send a health\n *     check. The default value is 5 seconds. (Alias for\n *     `options.checkIntervalSec`)\n * @param {number} options.timeout - How long (in seconds) to wait before\n *     claiming failure. The default value is 5 seconds. It is invalid for\n *     this value to be greater than checkIntervalSec. (Alias for\n *     `options.timeoutSec`)\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/health-check} callback.healthCheck - The created\n *     HealthCheck object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * function callback(err, healthCheck, operation, apiResponse) {\n *   // `healthCheck` is a HealthCheck object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of network creation.\n * }\n *\n * gce.createHealthCheck('new-health-check-name', callback);\n */\nCompute.prototype.createHealthCheck = function(name, options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  if (!is.string(name)) {\n    throw new Error('A health check name must be provided.');\n  }\n\n  var body = extend({}, options, {\n    name: name\n  });\n\n  var https = options.https;\n  delete body.https;\n\n  if (body.interval) {\n    body.checkIntervalSec = body.interval;\n    delete body.interval;\n  }\n\n  if (body.timeout) {\n    body.timeoutSec = body.timeout;\n    delete body.timeout;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/global/' + (https ? 'httpsHealthChecks' : 'httpHealthChecks'),\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var healthCheck = self.healthCheck(name, {\n      https: https\n    });\n\n    var operation = self.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, healthCheck, operation, resp);\n  });\n};\n\n/**\n * Create a network.\n *\n * @resource [Networks Overview]{@link https://cloud.google.com/compute/docs/networking#networks}\n * @resource [Networks: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/networks/insert}\n *\n * @param {string} name - Name of the network.\n * @param {object} config - See a\n *     [Network resource](https://cloud.google.com/compute/docs/reference/v1/networks#resource).\n * @param {string} config.gateway - A gateway address for default routing to\n *     other networks. (Alias for `config.gatewayIPv4`)\n * @param {string} config.range -\n *     [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) range\n *     of addresses that are legal on this network. (Alias for\n *     `config.IPv4Range`)\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/network} callback.network - The created Network\n *     object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var config = {\n *   range: '10.240.0.0/16'\n * };\n *\n * function callback(err, network, operation, apiResponse) {\n *   // `network` is a Network object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of network creation.\n * }\n *\n * gce.createNetwork('new-network', config, callback);\n */\nCompute.prototype.createNetwork = function(name, config, callback) {\n  var self = this;\n\n  var body = extend({}, config, {\n    name: name\n  });\n\n  if (body.range) {\n    body.IPv4Range = body.range;\n    delete body.range;\n  }\n\n  if (body.gateway) {\n    body.gatewayIPv4 = body.gateway;\n    delete body.gateway;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/global/networks',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var network = self.network(name);\n\n    var operation = self.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, network, operation, resp);\n  });\n};\n\n/**\n * Create a global forwarding rule.\n *\n * @resource [GlobalForwardingRule Resource]{@link https://cloud.google.com/compute/docs/reference/v1/globalForwardingRules#resource}\n * @resource [GlobalForwardingRules: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/globalForwardingRules/insert}\n *\n * @param {string} name - Name of the rule.\n * @param {object} config - See a\n *     [GlobalForwardingRule resource](https://cloud.google.com/compute/docs/reference/v1/globalForwardingRules#resource).\n * @param {string=} config.ip - The single IP address this forwarding rule will\n *     match against. All traffic that matches the IP address, protocol, and\n *     ports of this forwarding rule will be handled by this rule. If specified,\n *     the IP address must be a static external IP address. To create a new\n *     ephemeral external IP address for the forwarding rule, leave this field\n *     empty. (Alias for `config.IPAddress`)\n * @param {string=} config.protocol - The type of protocol that this forwarding\n *     rule matches. Valid values are `AH`, `ESP`, `SCTP`, `TCP`, `UDP`.\n *     Default: `TCP`. (Alias for `config.IPProtocol`)\n * @param {string=} config.range - A single port or single contiguous port\n *     range, ranging from low to high for which this forwarding rule matches.\n *     Packets of the specified protocol sent to these ports will be forwarded\n *     on to the appropriate target pool or target instance. If this field is\n *     left empty, then the forwarding matches traffic for all ports for the\n *     specified protocol. (Alias for `config.portRange`)\n * @param {string} config.target - The full or valid partial URL of the target\n *     resource to receive the matched traffic. This target must be a global\n *     [`TargetHttpProxy` or `TargetHttpsProxy` resource](https://cloud.google.com/compute/docs/load-balancing/http/target-proxies).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/rule} callback.rule - The created Rule object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var name = 'new-rule-name';\n *\n * var config = {\n *   target: 'global/targetHttpProxies/my-proxy',\n *   range: '8080-8089'\n * };\n *\n * gce.createRule(name, config, function (err, rule, operation, apiResponse) {\n *   // `rule` is a Rule object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nCompute.prototype.createRule = function(name, config, callback) {\n  var self = this;\n\n  var body = extend({}, config, {\n    name: name\n  });\n\n  if (body.ip) {\n    body.IPAddress = body.ip;\n    delete body.ip;\n  }\n\n  if (body.protocol) {\n    body.IPProtocol = body.protocol;\n    delete body.protocol;\n  }\n\n  if (body.range) {\n    body.portRange = body.range;\n    delete body.range;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/global/forwardingRules',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var rule = self.rule(name);\n\n    var operation = self.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, rule, operation, resp);\n  });\n};\n\n/**\n * Create a backend service.\n *\n * @resource [Backend Services Overview]{@link https://cloud.google.com/compute/docs/load-balancing/http/backend-service}\n * @resource [BackendServices: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/backendServices/insert}\n *\n * @param {string} name - Name of the backend service.\n * @param {object} config - See a\n *     [BackendService resource](https://cloud.google.com/compute/docs/reference/v1/backendServices#resource).\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/service} callback.service - The created Service\n *     object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var config = {\n *   backends: [\n *     {\n *       group: 'URL of an Instance Group resource'\n *     }\n *   ],\n *   healthChecks: [\n *     'URL of an HTTP/HTTPS health check resource'\n *   ]\n * };\n *\n * function callback(err, service, operation, apiResponse) {\n *   // `service` is a Service object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of network creation.\n * }\n *\n * gce.createService('new-service', config, callback);\n */\nCompute.prototype.createService = function(name, config, callback) {\n  var self = this;\n\n  var body = extend({}, config, {\n    name: name\n  });\n\n  this.request({\n    method: 'POST',\n    uri: '/global/backendServices',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var service = self.service(name);\n\n    var operation = self.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, service, operation, resp);\n  });\n};\n\n/**\n * Get a reference to a Google Compute Engine firewall.\n *\n * See {module:compute/network#firewall} to get a Firewall object for a specific\n * network.\n *\n * @resource [Firewalls Overview]{@link https://cloud.google.com/compute/docs/networking#firewalls}\n *\n * @param {string} name - Name of the firewall.\n * @return {module:compute/firewall}\n *\n * @example\n * var firewall = gce.firewall('firewall-name');\n */\nCompute.prototype.firewall = function(name) {\n  return new Firewall(this, name);\n};\n\n/**\n * Get a list of addresses. For a detailed description of method's options see\n * [API reference](https://goo.gl/r9XmXJ).\n *\n * @resource [Instances and Networks]{@link https://cloud.google.com/compute/docs/instances-and-network}\n * @resource [Addresses: aggregatedList API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/addresses/aggregatedList}\n *\n * @param {object=} options - Address search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of addresses to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/address} callback.addresses - Address objects from\n *     your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getAddresses(function(err, addresses) {\n *   // addresses is an array of `Address` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, addresses, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getAddresses(nextQuery, callback);\n *   }\n * }\n *\n * gce.getAddresses({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the addresses from your project as a readable object stream.\n * //-\n * gce.getAddresses()\n *   .on('error', console.error)\n *   .on('data', function(address) {\n *     // `address` is an `Address` object.\n *   })\n *   .on('end', function() {\n *     // All addresses retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getAddresses()\n *   .on('data', function(address) {\n *     this.end();\n *   });\n */\nCompute.prototype.getAddresses = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/aggregated/addresses',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var regions = resp.items || {};\n\n    var addresses = Object.keys(regions).reduce(function(acc, regionName) {\n      var region = self.region(regionName.replace('regions/', ''));\n      var regionAddresses = regions[regionName].addresses || [];\n\n      regionAddresses.forEach(function(address) {\n        var addressInstance = region.address(address.name);\n        addressInstance.metadata = address;\n        acc.push(addressInstance);\n      });\n\n      return acc;\n    }, []);\n\n    callback(null, addresses, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of autoscalers. For a detailed description of this method's\n * options, see the [API reference](https://cloud.google.com/compute/docs/reference/v1/autoscalers/aggregatedList).\n *\n * @resource [Managing Autoscalers]{@link https://cloud.google.com/compute/docs/autoscaler/managing-autoscalers}\n * @resource [Understanding Autoscaler Decisions]{@link https://cloud.google.com/compute/docs/autoscaler/understanding-autoscaler-decisions}\n * @resource [Autoscalers: aggregatedList API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/autoscalers/aggregatedList}\n *\n * @param {object=} options - Address search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of addresses to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/autoscaler[]} callback.autoscalers - Autoscaler\n *     objects from your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getAutoscalers(function(err, autoscalers) {\n *   // autoscalers is an array of `Autoscaler` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, autoscalers, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getAutoscalers(nextQuery, callback);\n *   }\n * }\n *\n * gce.getAutoscalers({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the autoscalers from your project as a readable object stream.\n * //-\n * gce.getAutoscalers()\n *   .on('error', console.error)\n *   .on('data', function(autoscaler) {\n *     // `autoscaler` is an `Autoscaler` object.\n *   })\n *   .on('end', function() {\n *     // All addresses retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getAutoscalers()\n *   .on('data', function(address) {\n *     this.end();\n *   });\n */\nCompute.prototype.getAutoscalers = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/aggregated/autoscalers',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var zones = resp.items || {};\n\n    var autoscalers = Object.keys(zones).reduce(function(acc, zoneName) {\n      if (zoneName.indexOf('zones/') !== 0) {\n        return acc;\n      }\n\n      var zone = self.zone(zoneName.replace('zones/', ''));\n      var zoneAutoscalers = zones[zoneName].autoscalers || [];\n\n      zoneAutoscalers.forEach(function(autoscaler) {\n        var autoscalerInstance = zone.autoscaler(autoscaler.name);\n        autoscalerInstance.metadata = autoscaler;\n        acc.push(autoscalerInstance);\n      });\n\n      return acc;\n    }, []);\n\n    callback(null, autoscalers, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of disks.\n *\n * @resource [Disks Overview]{@link https://cloud.google.com/compute/docs/disks}\n * @resource [Disks: aggregatedList API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/disks/aggregatedList}\n *\n * @param {object=} options - Disk search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of disks to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/disk} callback.disks - Disk objects from your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getDisks(function(err, disks) {\n *   // `disks` is an array of `Disk` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, disks, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getDisks(nextQuery, callback);\n *   }\n * }\n *\n * gce.getDisks({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the disks from your project as a readable object stream.\n * //-\n * gce.getDisks()\n *   .on('error', console.error)\n *   .on('data', function(disk) {\n *     // `disk` is a `Disk` object.\n *   })\n *   .on('end', function() {\n *     // All disks retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getDisks()\n *   .on('data', function(disk) {\n *     this.end();\n *   });\n */\nCompute.prototype.getDisks = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/aggregated/disks',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var zones = resp.items || {};\n\n    var disks = Object.keys(zones).reduce(function(acc, zoneName) {\n      var zone = self.zone(zoneName.replace('zones/', ''));\n      var disks = zones[zoneName].disks || [];\n\n      disks.forEach(function(disk) {\n        var diskInstance = zone.disk(disk.name);\n        diskInstance.metadata = disk;\n        acc.push(diskInstance);\n      });\n\n      return acc;\n    }, []);\n\n    callback(null, disks, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of instance groups.\n *\n * @resource [InstanceGroups Overview]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups}\n * @resource [InstanceGroups: aggregatedList API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups/aggregatedList}\n *\n * @param {object=} options - Instance group search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of instance groups to\n *     return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/instance-group[]} callback.instanceGroups -\n *     InstanceGroup objects from your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getInstanceGroups(function(err, instanceGroups) {\n *   // `instanceGroups` is an array of `InstanceGroup` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, instanceGroups, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getInstanceGroups(nextQuery, callback);\n *   }\n * }\n *\n * gce.getInstanceGroups({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the instance groups from your project as a readable object stream.\n * //-\n * gce.getInstanceGroups()\n *   .on('error', console.error)\n *   .on('data', function(instanceGroup) {\n *     // `instanceGroup` is an `InstanceGroup` object.\n *   })\n *   .on('end', function() {\n *     // All instance groups retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getInstanceGroups()\n *   .on('data', function(instanceGroup) {\n *     this.end();\n *   });\n */\nCompute.prototype.getInstanceGroups = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/aggregated/instanceGroups',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var zones = resp.items || {};\n\n    var instanceGroups = Object.keys(zones).reduce(function(acc, zoneName) {\n      var zone = self.zone(zoneName.replace('zones/', ''));\n      var instanceGroups = zones[zoneName].instanceGroups || [];\n\n      instanceGroups.forEach(function(group) {\n        var instanceGroupInstance = zone.instanceGroup(group.name);\n        instanceGroupInstance.metadata = group;\n        acc.push(instanceGroupInstance);\n      });\n\n      return acc;\n    }, []);\n\n    callback(null, instanceGroups, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of firewalls.\n *\n * @resource [Firewalls Overview]{@link https://cloud.google.com/compute/docs/networking#firewalls}\n * @resource [Firewalls: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/firewalls/list}\n *\n * @param {object=} options - Firewall search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of firewalls to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/firewall} callback.firewalls - Firewall objects from\n *     your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getFirewalls(function(err, firewalls) {\n *   // `firewalls` is an array of `Firewall` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, firewalls, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getFirewalls(nextQuery, callback);\n *   }\n * }\n *\n * gce.getFirewalls({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the firewalls from your project as a readable object stream.\n * //-\n * gce.getFirewalls()\n *   .on('error', console.error)\n *   .on('data', function(firewall) {\n *     // `firewall` is a `Firewall` object.\n *   })\n *   .on('end', function() {\n *     // All firewalls retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getFirewalls()\n *   .on('data', function(firewall) {\n *     this.end();\n *   });\n */\nCompute.prototype.getFirewalls = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/global/firewalls',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var firewalls = (resp.items || []).map(function(firewall) {\n      var firewallInstance = self.firewall(firewall.name);\n      firewallInstance.metadata = firewall;\n      return firewallInstance;\n    });\n\n    callback(null, firewalls, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of health checks.\n *\n * @resource [Health Checks Overview]{@link https://cloud.google.com/compute/docs/load-balancing/health-checks}\n * @resource [HttpHealthCheck: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/httpHealthChecks/list}\n * @resource [HttpsHealthCheck: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/httpsHealthChecks/list}\n *\n * @param {object=} options - Health check search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {boolean} options.https - List only HTTPs health checks. Default:\n *     `false`.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of networks to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/health-check} callback.healthChecks - HealthCheck\n *     objects from your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getHealthChecks(function(err, healthChecks) {\n *   // `healthChecks` is an array of `HealthCheck` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, healthChecks, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getHealthChecks(nextQuery, callback);\n *   }\n * }\n *\n * gce.getHealthChecks({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the health checks from your project as a readable object stream.\n * //-\n * gce.getHealthChecks()\n *   .on('error', console.error)\n *   .on('data', function(healthCheck) {\n *     // `healthCheck` is a `HealthCheck` object.\n *   })\n *   .on('end', function() {\n *     // All health checks retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getHealthChecks()\n *   .on('data', function(healthCheck) {\n *     this.end();\n *   });\n */\nCompute.prototype.getHealthChecks = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({}, options);\n\n  var https = options.https;\n  delete options.https;\n\n  this.request({\n    uri: '/global/' + (https ? 'httpsHealthChecks' : 'httpHealthChecks'),\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var healthChecks = (resp.items || []).map(function(healthCheck) {\n      var healthCheckInstance = self.healthCheck(healthCheck.name, {\n        https: https\n      });\n      healthCheckInstance.metadata = healthCheck;\n      return healthCheckInstance;\n    });\n\n    callback(null, healthChecks, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of networks.\n *\n * @resource [Networks Overview]{@link https://cloud.google.com/compute/docs/networking#networks}\n * @resource [Networks: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/networks/list}\n *\n * @param {object=} options - Network search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of networks to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/network} callback.networks - Network objects from your\n *     project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getNetworks(function(err, networks) {\n *   // `networks` is an array of `Network` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, networks, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getNetworks(nextQuery, callback);\n *   }\n * }\n *\n * gce.getNetworks({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the networks from your project as a readable object stream.\n * //-\n * gce.getNetworks()\n *   .on('error', console.error)\n *   .on('data', function(network) {\n *     // `network` is a `Network` object.\n *   })\n *   .on('end', function() {\n *     // All networks retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getNetworks()\n *   .on('data', function(network) {\n *     this.end();\n *   });\n */\nCompute.prototype.getNetworks = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/global/networks',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var networks = (resp.items || []).map(function(network) {\n      var networkInstance = self.network(network.name);\n      networkInstance.metadata = network;\n      return networkInstance;\n    });\n\n    callback(null, networks, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of global operations.\n *\n * @resource [Global Operation Overview]{@link https://cloud.google.com/compute/docs/reference/v1/globalOperations}\n * @resource [GlobalOperations: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/globalOperations/list}\n *\n * @param {object=} options - Operation search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of operations to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operations - Operation objects\n *     from your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getOperations(function(err, operations) {\n *   // `operations` is an array of `Operation` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, operations, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getOperations(nextQuery, callback);\n *   }\n * }\n *\n * gce.getOperations({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the operations from your project as a readable object stream.\n * //-\n * gce.getOperations()\n *   .on('error', console.error)\n *   .on('data', function(operation) {\n *     // `operation` is a `Operation` object.\n *   })\n *   .on('end', function() {\n *     // All operations retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getOperations()\n *   .on('data', function(operation) {\n *     this.end();\n *   });\n */\nCompute.prototype.getOperations = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/global/operations',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var operations = (resp.items || []).map(function(operation) {\n      var operationInstance = self.operation(operation.name);\n      operationInstance.metadata = operation;\n      return operationInstance;\n    });\n\n    callback(null, operations, nextQuery, resp);\n  });\n};\n\n/**\n * Return the regions available to your project.\n *\n * @resource [Regions & Zones Overview]{@link https://cloud.google.com/compute/docs/zones}\n * @resource [Regions: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/regions/list}\n *\n * @param {object=} options - Instance search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of instances to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/region} callback.regions - Region objects that are\n *     available to your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getRegions(function(err, regions) {\n *   // `regions` is an array of `Region` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, regions, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getRegions(nextQuery, callback);\n *   }\n * }\n *\n * gce.getRegions({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the regions available to your project as a readable object stream.\n * //-\n * gce.getRegions()\n *   .on('error', console.error)\n *   .on('data', function(region) {\n *     // `region` is a `Region` object.\n *   })\n *   .on('end', function() {\n *     // All regions retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getRegions()\n *   .on('data', function(region) {\n *     this.end();\n *   });\n */\nCompute.prototype.getRegions = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.request({\n    uri: '/regions',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var regions = resp.items.map(function(region) {\n      var regionInstance = self.region(region.name);\n      regionInstance.metadata = region;\n      return regionInstance;\n    });\n\n    callback(null, regions, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of forwading rules.\n *\n * @resource [GlobalForwardingRules: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/globalForwardingRules/list}\n *\n * @param {object=} options - Rules search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of rules to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/rule} callback.rules - Rule objects from this region.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getRules(function(err, rules) {\n *   // `rules` is an array of `Rule` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, rules, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getRules(nextQuery, callback);\n *   }\n * }\n *\n * gce.getRules({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the rules from your project as a readable object stream.\n * //-\n * gce.getRules()\n *   .on('error', console.error)\n *   .on('data', function(rule) {\n *     // `rule` is a `Rule` object.\n *   })\n *   .on('end', function() {\n *     // All rules retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getRules()\n *   .on('data', function(rule) {\n *     this.end();\n *   });\n */\nCompute.prototype.getRules = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/global/forwardingRules',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var rules = (resp.items || []).map(function(rule) {\n      var ruleInstance = self.rule(rule.name);\n      ruleInstance.metadata = rule;\n      return ruleInstance;\n    });\n\n    callback(null, rules, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of backend services.\n *\n * @resource [Backend Services Overview]{@link https://cloud.google.com/compute/docs/load-balancing/http/backend-service}\n * @resource [BackendServices: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/backendServices/list}\n *\n * @param {object=} options - BackendService search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of snapshots to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/service[]} callback.services - Service objects from\n *     your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getServices(function(err, services) {\n *   // `services` is an array of `Service` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, services, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getServices(nextQuery, callback);\n *   }\n * }\n *\n * gce.getServices({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the backend services from your project as a readable object stream.\n * //-\n * gce.getServices()\n *   .on('error', console.error)\n *   .on('data', function(service) {\n *     // `service` is a `Service` object.\n *   })\n *   .on('end', function() {\n *     // All services retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getServices()\n *   .on('data', function(service) {\n *     this.end();\n *   });\n */\nCompute.prototype.getServices = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/global/backendServices',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var services = (resp.items || []).map(function(service) {\n      var serviceInstance = self.service(service.name);\n      serviceInstance.metadata = service;\n      return serviceInstance;\n    });\n\n    callback(null, services, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of snapshots.\n *\n * @resource [Snapshots Overview]{@link https://cloud.google.com/compute/docs/disks/persistent-disks#snapshots}\n * @resource [Snapshots: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/snapshots/list}\n *\n * @param {object=} options - Snapshot search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of snapshots to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/snapshot} callback.snapshots - Snapshot objects from\n *     your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getSnapshots(function(err, snapshots) {\n *   // `snapshots` is an array of `Snapshot` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, snapshots, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getSnapshots(nextQuery, callback);\n *   }\n * }\n *\n * gce.getSnapshots({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the snapshots from your project as a readable object stream.\n * //-\n * gce.getSnapshots()\n *   .on('error', console.error)\n *   .on('data', function(snapshot) {\n *     // `snapshot` is a `Snapshot` object.\n *   })\n *   .on('end', function() {\n *     // All snapshots retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getSnapshots()\n *   .on('data', function(snapshot) {\n *     this.end();\n *   });\n */\nCompute.prototype.getSnapshots = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/global/snapshots',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var snapshots = (resp.items || []).map(function(snapshot) {\n      var snapshotInstance = self.snapshot(snapshot.name);\n      snapshotInstance.metadata = snapshot;\n      return snapshotInstance;\n    });\n\n    callback(null, snapshots, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of virtual machine instances.\n *\n * @resource [Instances and Networks]{@link https://cloud.google.com/compute/docs/instances-and-network}\n * @resource [Instances: aggregatedList API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/aggregatedList}\n *\n * @param {object=} options - Instance search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of instances to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/vm} callback.vms - VM objects from your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getVMs(function(err, vms) {\n *   // `vms` is an array of `VM` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, vms, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getVMs(nextQuery, callback);\n *   }\n * }\n *\n * gce.getVMs({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the VM instances from your project as a readable object stream.\n * //-\n * gce.getVMs()\n *   .on('error', console.error)\n *   .on('data', function(vm) {\n *     // `vm` is a `VM` object.\n *   })\n *   .on('end', function() {\n *     // All vms retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getVMs()\n *   .on('data', function(vm) {\n *     this.end();\n *   });\n */\nCompute.prototype.getVMs = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/aggregated/instances',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var zones = resp.items || {};\n\n    var vms = Object.keys(zones).reduce(function(acc, zoneName) {\n      var zone = self.zone(zoneName.replace('zones/', ''));\n      var instances = zones[zoneName].instances || [];\n\n      instances.forEach(function(instance) {\n        var vmInstance = zone.vm(instance.name);\n        vmInstance.metadata = instance;\n        acc.push(vmInstance);\n      });\n\n      return acc;\n    }, []);\n\n    callback(null, vms, nextQuery, resp);\n  });\n};\n\n/**\n * Return the zones available to your project.\n *\n * @resource [Regions & Zones Overview]{@link https://cloud.google.com/compute/docs/zones}\n * @resource [Zones: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/zones/list}\n *\n * @param {object=} options - Instance search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of instances to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/zone} callback.zones - Zone objects that are available\n *     to your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gce.getZones(function(err, zones) {\n *   // `zones` is an array of `Zone` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, zones, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gce.getZones(nextQuery, callback);\n *   }\n * }\n *\n * gce.getZones({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the zones available to your project as a readable object stream.\n * //-\n * gce.getZones()\n *   .on('error', console.error)\n *   .on('data', function(zone) {\n *     // `zone` is a `Zone` object.\n *   })\n *   .on('end', function() {\n *     // All zones retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gce.getZones()\n *   .on('data', function(zone) {\n *     this.end();\n *   });\n */\nCompute.prototype.getZones = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.request({\n    uri: '/zones',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var zones = resp.items.map(function(zone) {\n      var zoneInstance = self.zone(zone.name);\n      zoneInstance.metadata = zone;\n      return zoneInstance;\n    });\n\n    callback(null, zones, nextQuery, resp);\n  });\n};\n\n/**\n * Get a reference to a Google Compute Engine health check.\n *\n * @resource [Health Checks Overview]{@link https://cloud.google.com/compute/docs/load-balancing/health-checks}\n *\n * @param {string} name - Name of the health check.\n * @param {object=} options - Configuration object.\n * @param {boolean} options.https - Specify if this is an HTTPS health check\n *     resource. Default: `false`\n * @return {module:compute/health-check}\n *\n * @example\n * var healthCheck = gce.healthCheck('http-health-check-name');\n *\n * //-\n * // Access an HTTPS health check.\n * //-\n * var httpsHealthCheck = gce.healthCheck('https-health-check-name', {\n *   https: true\n * });\n */\nCompute.prototype.healthCheck = function(name, options) {\n  return new HealthCheck(this, name, options);\n};\n\n/**\n * Get a reference to a Google Compute Engine network.\n *\n * @resource [Networks Overview]{@link https://cloud.google.com/compute/docs/networking#networks}\n *\n * @param {string} name - Name of the network.\n * @return {module:compute/network}\n *\n * @example\n * var network = gce.network('network-name');\n */\nCompute.prototype.network = function(name) {\n  return new Network(this, name);\n};\n\n/**\n * Get a reference to a global Google Compute Engine operation.\n *\n * @resource [Global Operation Overview]{@link https://cloud.google.com/compute/docs/reference/v1/globalOperations}\n *\n * @param {string} name - Name of the existing operation.\n * @return {module:compute/operation}\n *\n * @example\n * var operation = gce.operation('operation-name');\n */\nCompute.prototype.operation = function(name) {\n  return new Operation(this, name);\n};\n\n/**\n * Get a reference to a Google Compute Engine region.\n *\n * @resource [Regions & Zones Overview]{@link https://cloud.google.com/compute/docs/zones}\n *\n * @param {string} name - Name of the region.\n * @return {module:compute/region}\n *\n * @example\n * var region = gce.region('region-name');\n */\nCompute.prototype.region = function(name) {\n  return new Region(this, name);\n};\n\n/**\n * Get a reference to a Google Compute Engine forwading rule.\n *\n * @param {string} name - Name of the rule.\n * @return {module:compute/rule}\n *\n * @example\n * var rule = gce.rule('rule-name');\n */\nCompute.prototype.rule = function(name) {\n  return new Rule(this, name);\n};\n\n/**\n * Get a reference to a Google Compute Engine backend service.\n *\n * @resource [Backend Services Overview]{@link https://cloud.google.com/compute/docs/load-balancing/http/backend-service}\n *\n * @param {string} name - Name of the existing service.\n * @return {module:compute/service}\n *\n * @example\n * var service = gce.service('service-name');\n */\nCompute.prototype.service = function(name) {\n  return new ServiceClass(this, name);\n};\n\n/**\n * Get a reference to a Google Compute Engine snapshot.\n *\n * @resource [Snapshots Overview]{@link https://cloud.google.com/compute/docs/disks/persistent-disks#snapshots}\n *\n * @param {string} name - Name of the existing snapshot.\n * @return {module:compute/snapshot}\n *\n * @example\n * var snapshot = gce.snapshot('snapshot-name');\n */\nCompute.prototype.snapshot = function(name) {\n  return new Snapshot(this, name);\n};\n\n/**\n * Get a reference to a Google Compute Engine zone.\n *\n * @resource [Regions & Zones Overview]{@link https://cloud.google.com/compute/docs/zones}\n *\n * @param {string} name - Name of the zone.\n * @return {module:compute/zone}\n *\n * @example\n * var zone = gce.zone('zone-name');\n */\nCompute.prototype.zone = function(name) {\n  return new Zone(this, name);\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(Compute, [\n  'getAddresses',\n  'getAutoscalers',\n  'getDisks',\n  'getFirewalls',\n  'getHealthChecks',\n  'getInstanceGroups',\n  'getNetworks',\n  'getOperations',\n  'getRegions',\n  'getRules',\n  'getServices',\n  'getSnapshots',\n  'getVMs',\n  'getZones'\n]);\n\nmodule.exports = Compute;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/firewall.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/firewall\n */\n\n'use strict';\n\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:compute} compute - Compute object this firewall belongs to.\n * @param {string} name - Name of the firewall.\n */\n/**\n * A Firewall object allows you to interact with a Google Compute Engine\n * firewall.\n *\n * @resource [Firewalls Overview]{@link https://cloud.google.com/compute/docs/networking#firewalls}\n * @resource [Firewall Resource]{@link https://cloud.google.com/compute/docs/reference/v1/firewalls}\n *\n * @constructor\n * @alias module:compute/firewall\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var firewall = gce.firewall('tcp-3000');\n */\nfunction Firewall(compute, name) {\n  var methods = {\n    /**\n     * Create a firewall.\n     *\n     * @param {object} config - See {module:compute#createFirewall}.\n     *\n     * @example\n     * var config = {\n     *   // ...\n     * };\n     *\n     * firewall.create(config, function(err, firewall, operation, apiResponse) {\n     *   // `firewall` is a Firewall object.\n     *\n     *   // `operation` is an Operation object that can be used to check the\n     *   // status of the request.\n     * });\n     */\n    create: true,\n\n    /**\n     * Check if the firewall exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the firewall exists or not.\n     *\n     * @example\n     * firewall.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a firewall if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * firewall.get(function(err, firewall, apiResponse) {\n     *   // `firewall` is a Firewall object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the firewall's metadata.\n     *\n     * @resource [Firewalls: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/firewalls/get}\n     * @resource [Firewall Resource]{@link https://cloud.google.com/compute/docs/reference/v1/firewalls}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The firewall's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * firewall.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: compute,\n    baseUrl: '/global/firewalls',\n    id: name,\n    createMethod: compute.createFirewall.bind(compute),\n    methods: methods\n  });\n\n  this.compute = compute;\n  this.name = name;\n  this.metadata.network = 'global/networks/default';\n}\n\nnodeutil.inherits(Firewall, ServiceObject);\n\n/**\n * Delete the firewall.\n *\n * @resource [Firewalls: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/firewalls/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * firewall.delete(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nFirewall.prototype.delete = function(callback) {\n  var compute = this.compute;\n\n  callback = callback || util.noop;\n\n  ServiceObject.prototype.delete.call(this, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = compute.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\n/**\n * Set the firewall's metadata.\n *\n * @resource [Firewall Resource]{@link https://cloud.google.com/compute/docs/reference/v1/firewalls}\n *\n * @param {object} metadata - See a\n *     [Firewall resource](https://cloud.google.com/compute/docs/reference/v1/firewalls).\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var metadata = {\n *   description: 'New description'\n * };\n *\n * firewall.setMetadata(metadata, function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nFirewall.prototype.setMetadata = function(metadata, callback) {\n  var compute = this.compute;\n\n  callback = callback || util.noop;\n\n  metadata = metadata || {};\n  metadata.name = this.name;\n  metadata.network = this.metadata.network;\n\n  this.request({\n    method: 'PATCH',\n    uri: '',\n    json: metadata\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = compute.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\nmodule.exports = Firewall;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/health-check.js":"/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/health-check\n */\n\n'use strict';\n\nvar extend = require('extend');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:compute} compute - Compute object this health check belongs\n *     to.\n * @param {string} name - Name of the health check.\n * @param {object=} options - Optional configuration.\n * @param {boolean} options.https - Specify if this is an HTTPS health check\n *     resource. Default: `false`\n */\n/**\n * Health checks ensure that Compute Engine forwards new connections only to\n * instances that are up and ready to receive them. Compute Engine sends health\n * check requests to each instance at the specified frequency; once an instance\n * exceeds its allowed number of health check failures, it is no longer\n * considered an eligible instance for receiving new traffic.\n *\n * @resource [Health Checks Overview]{@link https://cloud.google.com/compute/docs/load-balancing/health-checks}\n *\n * @constructor\n * @alias module:compute/health-check\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var healthCheck = gce.healthCheck('health-check-name');\n */\nfunction HealthCheck(compute, name, options) {\n  var methods = {\n    /**\n     * Create an HTTP or HTTPS health check.\n     *\n     * @param {object} options - See {module:compute#createHealthCheck}.\n     *\n     * @example\n     * healthCheck.create(function(err, healthCheck, operation, apiResponse) {\n     *   // `healthCheck` is a HealthCheck object.\n     *\n     *   // `operation` is an Operation object that can be used to check the\n     *   // status of the request.\n     * });\n     */\n    create: true,\n\n    /**\n     * Check if the health check exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the health check exists or\n     *     not.\n     *\n     * @example\n     * healthCheck.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get the health check if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * healthCheck.get(function(err, healthCheck, apiResponse) {\n     *   // `healthCheck` is a HealthCheck object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the health check's metadata.\n     *\n     * @resource [HttpHealthChecks: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/httpHealthChecks/get}\n     * @resource [HttpHealthCheck resource](https://cloud.google.com/compute/docs/reference/v1/httpHealthChecks#resource)\n     * @resource [HttpsHealthChecks: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/httpsHealthChecks/get}\n     * @resource [HttpsHealthCheck resource](https://cloud.google.com/compute/docs/reference/v1/httpsHealthChecks#resource)\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The health check's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * healthCheck.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  options = options || {};\n\n  var https = options.https;\n  this.compute = compute;\n\n  ServiceObject.call(this, {\n    parent: compute,\n    baseUrl: '/global/' + (https ? 'httpsHealthChecks' : 'httpHealthChecks'),\n    id: name,\n    createMethod: function(name, options, callback) {\n      if (is.fn(options)) {\n        callback = options;\n        options = {};\n      }\n\n      options = extend({}, options, { https: https });\n\n      compute.createHealthCheck(name, options, callback);\n    },\n    methods: methods\n  });\n}\n\nnodeutil.inherits(HealthCheck, ServiceObject);\n\n/**\n * Delete the health check.\n *\n * @resource [HttpHealthCheck: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/httpHealthChecks/delete}\n * @resource [HttpsHealthCheck: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/httpsHealthChecks/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * healthCheck.delete(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nHealthCheck.prototype.delete = function(callback) {\n  var compute = this.compute;\n\n  callback = callback || util.noop;\n\n  ServiceObject.prototype.delete.call(this, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = compute.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\n/**\n * Set the health check's metadata.\n *\n * @resource [HttpHealthCheck: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/httpHealthChecks/insert}\n * @resource [HttpsHealthCheck: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/httpsHealthChecks/insert}\n *\n * @param {object} metadata - See a\n *     [HttpHealthCheck resource](https://cloud.google.com/compute/docs/reference/v1/httpHealthChecks#resource)\n *     and [HttpsHealthCheck resource](https://cloud.google.com/compute/docs/reference/v1/httpsHealthChecks#resource).\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var metadata = {\n *   description: 'New description'\n * };\n *\n * healthCheck.setMetadata(metadata, function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nHealthCheck.prototype.setMetadata = function(metadata, callback) {\n  var compute = this.compute;\n\n  callback = callback || util.noop;\n\n  ServiceObject.prototype.setMetadata.call(this, metadata, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = compute.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\nmodule.exports = HealthCheck;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/network.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/network\n */\n\n'use strict';\n\nvar extend = require('extend');\nvar format = require('string-format-obj');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:compute} compute - The Compute module this network belongs to.\n * @param {string} name - Network name.\n */\n/**\n * A Network object allows you to interact with a Google Compute Engine network.\n *\n * @resource [Networks Overview]{@link https://cloud.google.com/compute/docs/networking#networks}\n * @resource [Network Resource]{@link https://cloud.google.com/compute/docs/reference/v1/networks}\n *\n * @constructor\n * @alias module:compute/network\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var network = gce.network('network-name');\n */\nfunction Network(compute, name) {\n  var methods = {\n    /**\n     * Create a network.\n     *\n     * @param {object} config - See {module:compute#createNetwork}.\n     *\n     * @example\n     * var config = {\n     *   // ...\n     * };\n     *\n     * network.create(config, function(err, network, operation, apiResponse) {\n     *   // `network` is a Network object.\n     *\n     *   // `operation` is an Operation object that can be used to check the\n     *   // status of network creation.\n     * });\n     */\n    create: true,\n\n    /**\n     * Check if the network exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the network exists or not.\n     *\n     * @example\n     * network.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a network if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * network.get(function(err, network, apiResponse) {\n     *   // `network` is a Network object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the network's metadata.\n     *\n     * @resource [Network Resource]{@link https://cloud.google.com/compute/docs/reference/v1/networks}\n     * @resource [Networks: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/networks/delete}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The network's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * network.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: compute,\n    baseUrl: '/global/networks',\n    id: name,\n    createMethod: compute.createNetwork.bind(compute),\n    methods: methods,\n  });\n\n  this.compute = compute;\n  this.formattedName = Network.formatName_(compute, name);\n  this.name = name;\n}\n\nnodeutil.inherits(Network, ServiceObject);\n\n/**\n * Format a network's name how the API expects.\n *\n * @private\n *\n * @param {module:compute} compute - The Compute object this network belongs to.\n * @param {string} name - The name of the network.\n * @return {string} - The formatted name.\n */\nNetwork.formatName_ = function(compute, name) {\n  return format('projects/{projectId}/global/networks/{name}', {\n    projectId: compute.projectId,\n    name: name\n  });\n};\n\n/**\n * Create a firewall for this network.\n *\n * @resource [Firewalls Overview]{@link https://cloud.google.com/compute/docs/networking#firewalls}\n * @resource [Firewalls: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/firewalls/insert}\n *\n * @param {string} name - Name of the firewall.\n * @param {object} config - See a\n *     [Firewall resource](https://cloud.google.com/compute/docs/reference/v1/firewalls#resource).\n * @param {object} config.protocols - A map of protocol to port range. The keys\n *     of the object refer to a protocol (e.g. `tcp`, `udp`) and the value for\n *     the key are the ports/port-ranges that are allowed to make a connection.\n * @param {string[]} config.ranges - The IP address blocks that this rule\n *     applies to, expressed in\n *     [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)\n *     format.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/firewall} callback.firewall - The created Firewall\n *     object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var config = {\n *   protocols: {\n *     tcp: [3000],\n *     udp: [] // An empty array means all ports are allowed.\n *   },\n *\n *   ranges: ['0.0.0.0/0']\n * };\n *\n * function callback(err, firewall, operation, apiResponse) {\n *   // `firewall` is a Firewall object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * }\n *\n * network.createFirewall('new-firewall-name', config, callback);\n */\nNetwork.prototype.createFirewall = function(name, config, callback) {\n  config = extend({}, config, {\n    network: this.formattedName\n  });\n\n  this.compute.createFirewall(name, config, callback);\n};\n\n/**\n * Delete the network.\n *\n * @resource [Networks: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/networks/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * network.delete(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nNetwork.prototype.delete = function(callback) {\n  var compute = this.compute;\n\n  callback = callback || util.noop;\n\n  ServiceObject.prototype.delete.call(this, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = compute.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\n/**\n * Get a reference to a Google Compute Engine firewall in this network.\n *\n * @resource [Firewalls Overview]{@link https://cloud.google.com/compute/docs/networking#firewalls}\n *\n * @param {string} name - Name of the firewall.\n *\n * @example\n * var firewall = network.firewall('firewall-name');\n */\nNetwork.prototype.firewall = function(name) {\n  var firewall = this.compute.firewall(name);\n\n  firewall.metadata = {\n    network: this.formattedName\n  };\n\n  return firewall;\n};\n\n/**\n * Get a list of firewalls for this network.\n *\n * @resource [Firewalls Overview]{@link https://cloud.google.com/compute/docs/networking#firewalls}\n * @resource [Firewalls: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/firewalls/list}\n *\n * @param {object=} options - Firewall search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of firewalls to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/firewall} callback.firewalls - Firewall objects from\n *     this network.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * network.getFirewalls(function(err, firewalls) {\n *   // `firewalls` is an array of `Firewall` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, firewalls, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     network.getFirewalls(nextQuery, callback);\n *   }\n * }\n *\n * network.getFirewalls({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the firewalls from your project as a readable object stream.\n * //-\n * network.getFirewalls()\n *   .on('error', console.error)\n *   .on('data', function(firewall) {\n *     // `firewall` is a `Firewall` object.\n *   })\n *   .on('end', function() {\n *     // All firewalls retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * network.getFirewalls()\n *   .on('data', function(firewall) {\n *     this.end();\n *   });\n */\nNetwork.prototype.getFirewalls = function(options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({}, options, {\n    filter: 'network eq .*' + this.formattedName\n  });\n\n  return this.compute.getFirewalls(options, callback);\n};\n\nmodule.exports = Network;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/operation.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/operation\n */\n\n'use strict';\n\nvar events = require('events');\nvar modelo = require('modelo');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:compute} scope - The scope of the operation: a `Compute`,\n *     `Zone`, or `Region` object.\n * @param {string} name - Operation name.\n */\n/**\n * An Operation object allows you to interact with a Google Compute Engine\n * operation.\n *\n * An operation can be a\n * [GlobalOperation](https://cloud.google.com/compute/docs/reference/v1/globalOperations),\n * [RegionOperation](https://cloud.google.com/compute/docs/reference/v1/regionOperations),\n * or\n * [ZoneOperation](https://cloud.google.com/compute/docs/reference/v1/zoneOperations).\n *\n * @constructor\n * @alias module:compute/operation\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * //-\n * // Reference a global operation.\n * //-\n * var operation = gce.operation('operation-id');\n *\n * //-\n * // Reference a region operation.\n * //-\n * var region = gce.region('us-central1');\n * var operation = region.operation('operation-id');\n *\n * //-\n * // Reference a zone operation.\n * //-\n * var zone = gce.zone('us-central1-a');\n * var operation = zone.operation('operation-id');\n *\n * //-\n * // All operations are event emitters. The status of each operation is polled\n * // continuously, starting only after you register a \"complete\" listener.\n * //-\n * operation.on('complete', function(metadata) {\n *   // The operation is complete.\n * });\n *\n * //-\n * // You can register a listener to monitor when the operation begins running.\n * //-\n * operation.on('running', function(metadata) {\n *   // The operation is running.\n * });\n *\n * //-\n * // Be sure to register an error handler as well to catch any issues which\n * // impeded the operation.\n * //-\n * operation.on('error', function(err) {\n *   // An error occurred during the operation.\n * });\n *\n * //-\n * // To force the Operation object to stop polling for updates, simply remove\n * // any \"complete\" listeners you've registered.\n * //\n * // The easiest way to do this is with `removeAllListeners()`.\n * //-\n * operation.removeAllListeners();\n */\nfunction Operation(scope, name) {\n  var isCompute = scope.constructor.name === 'Compute';\n\n  var methods = {\n    /**\n     * Delete the operation.\n     *\n     * @resource [GlobalOperations: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/globalOperations/delete}\n     * @resource [RegionOperations: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/regionOperations/delete}\n     * @resource [ZoneOperations: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/zoneOperations/delete}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * operation.delete(function(err, apiResponse) {});\n     */\n    delete: true,\n\n    /**\n     * Check if the operation exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the operation exists or not.\n     *\n     * @example\n     * operation.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get an operation if it exists.\n     *\n     * @example\n     * operation.get(function(err, operation, apiResponse) {\n     *   // `operation` is an Operation object.\n     * });\n     */\n    get: true\n  };\n\n  ServiceObject.call(this, {\n    parent: scope,\n    baseUrl: isCompute ? '/global/operations' : '/operations',\n    id: name,\n    methods: methods\n  });\n\n  events.EventEmitter.call(this);\n\n  this.completeListeners = 0;\n  this.hasActiveListeners = false;\n  this.name = name;\n\n  this.listenForEvents_();\n}\n\nmodelo.inherits(Operation, ServiceObject, events.EventEmitter);\n\n/**\n * Get the operation's metadata. For a detailed description of metadata see\n * [Operation resource](https://goo.gl/sWm1rt).\n *\n * @resource [GlobalOperations: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/globalOperations/get}\n * @resource [RegionOperations: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/regionOperations/get}\n * @resource [ZoneOperations: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/zoneOperations/get}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object} callback.metadata - The disk's metadata.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * operation.getMetadata(function(err, metadata, apiResponse) {\n *   // `metadata.error`: Contains errors if the operation failed.\n *   // `metadata.warnings`: Contains warnings.\n * });\n */\nOperation.prototype.getMetadata = function(callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  ServiceObject.prototype.getMetadata.call(this, function(err, apiResponse) {\n    // An Operation entity contains a property named `error`. This makes\n    // `request` think the operation failed, and will return an ApiError to\n    // this callback. We have to make sure this isn't a false error by seeing if\n    // the response body contains a property that wouldn't exist on a failed API\n    // request (`name`).\n    var requestFailed = err && (!apiResponse || apiResponse.name !== self.name);\n\n    if (requestFailed) {\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    self.metadata = apiResponse;\n\n    callback(null, self.metadata, apiResponse);\n  });\n};\n\n/**\n * Begin listening for events on the operation. This method keeps track of how\n * many \"complete\" listeners are registered and removed, making sure polling is\n * handled automatically.\n *\n * As long as there is one active \"complete\" listener, the connection is open.\n * When there are no more listeners, the polling stops.\n *\n * @private\n */\nOperation.prototype.listenForEvents_ = function() {\n  var self = this;\n\n  this.on('newListener', function(event) {\n    if (event === 'complete') {\n      self.completeListeners++;\n\n      if (!self.hasActiveListeners) {\n        self.hasActiveListeners = true;\n        self.startPolling_();\n      }\n    }\n  });\n\n  this.on('removeListener', function(event) {\n    if (event === 'complete' && --self.completeListeners === 0) {\n      self.hasActiveListeners = false;\n    }\n  });\n};\n\n/**\n * Poll `getMetadata` to check the operation's status. This runs a loop to ping\n * the API on an interval.\n *\n * Note: This method is automatically called once a \"complete\" event handler is\n * registered on the operation.\n *\n * @private\n */\nOperation.prototype.startPolling_ = function() {\n  var self = this;\n\n  if (!this.hasActiveListeners) {\n    return;\n  }\n\n  this.getMetadata(function(err, metadata, apiResponse) {\n    // Parsing the response body will automatically create an ApiError object if\n    // the operation failed.\n    var parsedHttpRespBody = util.parseHttpRespBody(apiResponse);\n    err = err || parsedHttpRespBody.err;\n\n    if (err) {\n      self.emit('error', err);\n      return;\n    }\n\n    if (metadata.status === 'RUNNING' && !self.status) {\n      self.status = metadata.status;\n      self.emit('running', metadata);\n    }\n\n    if (metadata.status !== 'DONE') {\n      setTimeout(self.startPolling_.bind(self), 500);\n      return;\n    }\n\n    self.status = metadata.status;\n    self.emit('complete', metadata);\n  });\n};\n\nmodule.exports = Operation;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/region.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/region\n */\n\n'use strict';\n\nvar extend = require('extend');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:compute/address}\n * @private\n */\nvar Address = require('./address.js');\n\n/**\n * @type {module:compute/operation}\n * @private\n */\nvar Operation = require('./operation.js');\n\n/**\n * @type {module:compute/rule}\n * @private\n */\nvar Rule = require('./rule.js');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/*! Developer Documentation\n *\n * @param {module:compute} compute - Compute object this region belongs to.\n * @param {string} name - Name of the region.\n */\n/**\n * A Region object allows you to interact with a Google Compute Engine region.\n *\n * @resource [Regions & Zones Overview]{@link https://cloud.google.com/compute/docs/zones}\n * @resource [Region Resource]{@link https://cloud.google.com/compute/docs/reference/v1/regions}\n *\n * @constructor\n * @alias module:compute/region\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var region = gce.region('us-central1');\n */\nfunction Region(compute, name) {\n  var methods = {\n    /**\n     * Check if the region exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the region exists or not.\n     *\n     * @example\n     * region.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a region.\n     *\n     * @example\n     * region.get(function(err, region, apiResponse) {\n     *   // `region` is a Region object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the region's metadata.\n     *\n     * @resource [Region Resource]{@link https://cloud.google.com/compute/docs/reference/v1/regions}\n     * @resource [Regions: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/regions/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The region's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * region.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: compute,\n    baseUrl: '/regions',\n    id: name,\n    methods: methods\n  });\n\n  this.name = name;\n\n  this.interceptors.push({\n    request: function(reqOpts) {\n      if (reqOpts.uri.indexOf('/global/forwardingRules') > -1) {\n        reqOpts.uri = reqOpts.uri.replace('/global', '');\n      }\n      return reqOpts;\n    }\n  });\n}\n\nnodeutil.inherits(Region, ServiceObject);\n\n/**\n * Get a reference to a Google Compute Engine address in this region.\n *\n * @resource [Instances and Networks]{@link https://cloud.google.com/compute/docs/instances-and-network}\n *\n * @param {string} name - Name of the address.\n * @return {module:compute/address}\n *\n * @example\n * var address = region.address('address-name');\n */\nRegion.prototype.address = function(name) {\n  return new Address(this, name);\n};\n\n/**\n * Create an address in this region.\n *\n * @resource [Instances and Networks]{@link https://cloud.google.com/compute/docs/instances-and-network}\n * @resource [Address Resource]{@link https://cloud.google.com/compute/docs/reference/v1/addresses}\n * @resource [Addresses: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/addresses/insert}\n *\n * @param {string} name - Name of the address.\n * @param {object=} options - See an\n *     [Address resource](https://cloud.google.com/compute/docs/reference/v1/addresses).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/address} callback.address - The created Address\n *     object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * function callback(err, address, operation, apiResponse) {\n *   // `address` is an Address object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * }\n *\n * region.createAddress('new-address', callback);\n */\nRegion.prototype.createAddress = function(name, options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/addresses',\n    json: extend({}, options, {\n      name: name\n    })\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var address = self.address(name);\n\n    var operation = self.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, address, operation, resp);\n  });\n};\n\n/**\n * Create a forwarding rule in this region.\n *\n * @resource [ForwardingRule Resource]{@link https://cloud.google.com/compute/docs/reference/v1/forwardingRules#resource}\n * @resource [ForwardingRules: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/forwardingRules/insert}\n *\n * @param {string} name - Name of the rule.\n * @param {object} config - See a\n *     [ForwardingRule resource](https://cloud.google.com/compute/docs/reference/v1/forwardingRules#resource).\n * @param {string=} config.ip - The single IP address this forwarding rule will\n *     match against. All traffic that matches the IP address, protocol, and\n *     ports of this forwarding rule will be handled by this rule. If specified,\n *     the IP address must be a static external IP address. To create a new\n *     ephemeral external IP address for the forwarding rule, leave this field\n *     empty. (Alias for `config.IPAddress`)\n * @param {string=} config.protocol - The type of protocol that this forwarding\n *     rule matches. Valid values are `AH`, `ESP`, `SCTP`, `TCP`, `UDP`.\n *     Default: `TCP`. (Alias for `config.IPProtocol`)\n * @param {string=} config.range - A single port or single contiguous port\n *     range, ranging from low to high for which this forwarding rule matches.\n *     Packets of the specified protocol sent to these ports will be forwarded\n *     on to the appropriate target pool or target instance. If this field is\n *     left empty, then the forwarding matches traffic for all ports for the\n *     specified protocol. (Alias for `config.portRange`)\n * @param {string} config.target - The full or valid partial URL of the target\n *     resource to receive the matched traffic.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/rule} callback.rule - The created Rule object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var name = 'new-rule-name';\n *\n * var cfg = {\n *   target: 'zones/us-central1-a/targetInstances/my-target-instance',\n *   range: '8080-8089'\n * };\n *\n * region.createRule(name, cfg, function (err, rule, operation, apiResponse) {\n *   // `rule` is a Rule object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nRegion.prototype.createRule = function(name, config, callback) {\n  this.parent.createRule.call(this, name, config, callback);\n};\n\n/**\n * Get a list of addresses in this region.\n *\n * @resource [Instances and Networks]{@link https://cloud.google.com/compute/docs/instances-and-network}\n * @resource [Addresses: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/addresses/list}\n *\n * @param {object=} options - Address search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of addresses to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/address} callback.addresses - Address objects from\n *     this region.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * region.getAddresses(function(err, addresses) {\n *   // `addresses` is an array of `Address` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, addresses, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     region.getAddresses(nextQuery, callback);\n *   }\n * }\n *\n * region.getAddresses({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the addresses from your project as a readable object stream.\n * //-\n * region.getAddresses()\n *   .on('error', console.error)\n *   .on('data', function(address) {\n *     // `address` is an `Address` object.\n *   })\n *   .on('end', function() {\n *     // All addresses retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * region.getAddresses()\n *   .on('data', function(address) {\n *     this.end();\n *   });\n */\nRegion.prototype.getAddresses = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/addresses',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var addresses = (resp.items || []).map(function(address) {\n      var addressInstance = self.address(address.name);\n      addressInstance.metadata = address;\n      return addressInstance;\n    });\n\n    callback(null, addresses, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of operations for this region.\n *\n * @resource [Region Operation Overview]{@link https://cloud.google.com/compute/docs/reference/v1/regionOperations}\n * @resource [RegionOperations: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/regionOperations/list}\n *\n * @param {object=} options - Operation search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of operations to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operations - Operation objects\n *     from this region.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * region.getOperations(function(err, operations) {\n *   // `operations` is an array of `Operation` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, operations, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     region.getOperations(nextQuery, callback);\n *   }\n * }\n *\n * region.getOperations({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the operations from your project as a readable object stream.\n * //-\n * region.getOperations()\n *   .on('error', console.error)\n *   .on('data', function(operation) {\n *     // `operation` is an `Operation` object.\n *   })\n *   .on('end', function() {\n *     // All operations retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * region.getOperations()\n *   .on('data', function(operation) {\n *     this.end();\n *   });\n */\nRegion.prototype.getOperations = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/operations',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var operations = (resp.items || []).map(function(operation) {\n      var operationInstance = self.operation(operation.name);\n      operationInstance.metadata = operation;\n      return operationInstance;\n    });\n\n    callback(null, operations, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of forwading rules in this region.\n *\n * @resource [ForwardingRules: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/forwardingRules/list}\n *\n * @param {object=} options - Rules search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of rules to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/rule} callback.rules - Rule objects from this region.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * region.getRules(function(err, rules) {\n *   // `rules` is an array of `Rule` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, rules, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     region.getRules(nextQuery, callback);\n *   }\n * }\n *\n * region.getRules({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the rules from this region as a readable object stream.\n * //-\n * region.getRules()\n *   .on('error', console.error)\n *   .on('data', function(rule) {\n *     // `rule` is a `Rule` object.\n *   })\n *   .on('end', function() {\n *     // All rules retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * region.getRules()\n *   .on('data', function(rule) {\n *     this.end();\n *   });\n */\nRegion.prototype.getRules = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/forwardingRules',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var rules = (resp.items || []).map(function(rule) {\n      var ruleInstance = self.rule(rule.name);\n      ruleInstance.metadata = rule;\n      return ruleInstance;\n    });\n\n    callback(null, rules, nextQuery, resp);\n  });\n};\n\n/**\n * Get a reference to a Google Compute Engine region operation.\n *\n * @resource [Region Operation Overview]{@link https://cloud.google.com/compute/docs/reference/v1/regionOperations}\n *\n * @param {string} name - Name of the existing operation.\n * @return {module:compute/operation}\n *\n * @example\n * var operation = region.operation('operation-name');\n */\nRegion.prototype.operation = function(name) {\n  return new Operation(this, name);\n};\n\n/**\n * Get a reference to a Google Compute Engine forwarding rule in this region.\n *\n * @param {string} name - Name of the rule.\n * @return {module:compute/rule}\n *\n * @example\n * var rule = region.rule('rule-name');\n */\nRegion.prototype.rule = function(name) {\n  return new Rule(this, name);\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(Region, ['getAddresses', 'getOperations', 'getRules']);\n\nmodule.exports = Region;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/address.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/address\n */\n\n'use strict';\n\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:region} region - Region this address belongs to.\n * @param {string} name - The name of the address.\n */\n/**\n * An Address object allows you to interact with a Google Compute Engine\n * address.\n *\n * @resource [Instances and Networks]{@link https://cloud.google.com/compute/docs/instances-and-network}\n * @resource [Address Resource]{@link https://cloud.google.com/compute/docs/reference/v1/addresses} *\n *\n * @constructor\n * @alias module:compute/address\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var region = gce.region('region-name');\n *\n * var address = region.address('address1');\n */\nfunction Address(region, name) {\n  var methods = {\n    /**\n     * Create an address.\n     *\n     * @param {object=} options - See {module:compute#createAddress}.\n     *\n     * @example\n     * address.create(function(err, address, operation, apiResponse) {\n     *   // `address` is an Address object.\n     *\n     *   // `operation` is an Operation object that can be used to check the\n     *   // of the request.\n     * });\n     */\n    create: true,\n\n    /**\n     * Check if the address exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the address exists or not.\n     *\n     * @example\n     * address.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get an address if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * address.get(function(err, address, apiResponse) {\n     *   // `address` is an Address object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the metadata of this address.\n     *\n     * @resource [Address Resource]{@link https://cloud.google.com/compute/docs/reference/v1/addresses}\n     * @resource [Addresses: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/addresses/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The address's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * address.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: region,\n    baseUrl: '/addresses',\n    id: name,\n    createMethod: region.createAddress.bind(region),\n    methods: methods\n  });\n\n  this.name = name;\n  this.region = region;\n}\n\nnodeutil.inherits(Address, ServiceObject);\n\n/**\n * Delete the address.\n *\n * @resource [Addresses: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/addresses/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * address.delete(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nAddress.prototype.delete = function(callback) {\n  callback = callback || util.noop;\n\n  var region = this.region;\n\n  this.request({\n    method: 'DELETE',\n    uri: ''\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = region.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\nmodule.exports = Address;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/rule.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/rule\n */\n\n'use strict';\n\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:compute|module:compute/region} scope - The parent scope this\n *     firewall rule belongs to.\n * @param {string} name - Rule name.\n */\n/**\n * Forwarding rules work in conjunction with target pools and target instances\n * to support load balancing and protocol forwarding features. To use load\n * balancing and protocol forwarding, you must create a forwarding rule that\n * directs traffic to specific target pools (for load balancing) or target\n * instances (for protocol forwarding).\n *\n * @resource [Forwarding rules]{@link https://cloud.google.com/compute/docs/load-balancing/network/forwarding-rules}\n *\n * @constructor\n * @alias module:compute/rule\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * //-\n * // Reference a global rule.\n * //-\n * var rule = gce.rule('rule-name');\n *\n * //-\n * // Reference a region rule.\n * //-\n * var region = gce.region('us-central1');\n * var rule = region.rule('rule-name');\n */\nfunction Rule(scope, name) {\n  var isGlobalRule = scope.constructor.name === 'Compute';\n\n  var methods = {\n    /**\n     * Create a forwarding rule.\n     *\n     * @param {object} config - See {module:compute#createRule} or\n     *     {module:compute/region#createRule} if accessing this object through\n     *     a Region.\n     *\n     * @example\n     * var config = {\n     *   // `target` will be different depending of this is a Regional or Global\n     *   // forwarding rule\n     *   target: 'global/targetHttpProxies/my-proxy',\n     *   portRange: '8080-8089'\n     * };\n     *\n     * rule.create(config, function(err, rule, operation, apiResponse) {\n     *   // `rule` is a Rule object.\n     *\n     *   // `operation` is an Operation object that can be used to check the\n     *   // of the request.\n     * });\n     */\n    create: true,\n\n    /**\n     * Check if the forwarding rule exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the rule exists or not.\n     *\n     * @example\n     * rule.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a forwarding rule if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * rule.get(function(err, rule, apiResponse) {\n     *   // `rule` is a Rule object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the metadata of this rule.\n     *\n     * @resource [GlobalForwardingRule Resource]{@link https://cloud.google.com/compute/docs/reference/v1/globalForwardingRules#resource}\n     * @resource [ForwardingRule Resource]{@link https://cloud.google.com/compute/docs/reference/v1/globalForwardingRules#resource}\n     * @resource [GlobalForwardingRules: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/globalForwardingRules/get}\n     * @resource [ForwardingRules: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/forwardingRules/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The rule's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * rule.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: scope,\n    baseUrl: (isGlobalRule ? '/global' : '') + '/forwardingRules',\n    id: name,\n    createMethod: scope.createRule.bind(scope),\n    methods: methods\n  });\n\n  this.scope = scope;\n}\n\nnodeutil.inherits(Rule, ServiceObject);\n\n/**\n * Delete the rule.\n *\n * @resource [GlobalForwardingRules: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/globalForwardingRules/delete}\n * @resource [ForwardingRules: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/forwardingRules/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * rule.delete(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nRule.prototype.delete = function(callback) {\n  callback = callback || util.noop;\n\n  var scope = this.scope;\n\n  ServiceObject.prototype.delete.call(this, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = scope.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\n/**\n * Set the target for this forwarding rule.\n *\n * @resource [GlobalForwardingRules: setTarget API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/globalForwardingRules/setTarget}\n * @resource [ForwardingRules: setTarget API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/forwardingRules/setTarget}\n *\n * @param {string} target - The full or valid partial URL of the target resource\n *     to receive the matched traffic. For regional forwarding rules, this\n *     target must live in the same region as the forwarding rule. For global\n *     forwarding rules, this target must be a global `TargetHttpProxy`\n *     resource.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * rule.setTarget('new-target', function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nRule.prototype.setTarget = function(target, callback) {\n  callback = callback || util.noop;\n\n  var scope = this.scope;\n\n  this.request({\n    method: 'POST',\n    uri: '/setTarget',\n    json: {\n      target: target\n    }\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = scope.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\nmodule.exports = Rule;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/service.js":"/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/service\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar format = require('string-format-obj');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:compute} compute - The Compute instance this service inherits\n *     from.\n * @param {string} name - Name of the service.\n */\n/**\n * An HTTP(S) load balancing backend service is a centralized service for\n * managing backends, which in turn manage instances that handle user requests.\n * You configure your load balancing service to route requests to your backend\n * service. The backend service in turn knows which instances it can use, how\n * much traffic they can handle, and how much traffic they are currently\n * handling. In addition, the backend service monitors health checking and does\n * not send traffic to unhealthy instances.\n *\n * @resource [Backend Services Overview]{@link https://cloud.google.com/compute/docs/load-balancing/http/backend-service}\n *\n * @constructor\n * @alias module:compute/service\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var service = gce.service('service-name');\n */\nfunction Service(compute, name) {\n  var methods = {\n    /**\n     * Create a backend service.\n     *\n     * @param {object} config - See {module:compute#createService}.\n     *\n     * @example\n     * service.create({\n     *   backends: [\n     *     {\n     *       group: 'URL of an Instance Group resource'\n     *     }\n     *   ],\n     *   healthChecks: [\n     *     'URL of an HTTP/HTTPS health check resource'\n     *   ]\n     * }, function(err, service, operation, apiResponse) {\n     *   // `service` is a Service object.\n     *\n     *   // `operation` is an Operation object that can be used to check the\n     *   // of the request.\n     * });\n     */\n    create: true,\n\n    /**\n     * Check if the backend service exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the backend service exists or\n     *     not.\n     *\n     * @example\n     * service.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a Service object if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * service.get(function(err, service, apiResponse) {\n     *   // `service` is a Service object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the metadata of this backend service.\n     *\n     * @resource [BackendService Resource]{@link https://cloud.google.com/compute/docs/reference/v1/backendServices#resource}\n     * @resource [BackendService: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/backendServices/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The service's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * service.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: compute,\n    baseUrl: '/global/backendServices',\n    id: name,\n    createMethod: compute.createService.bind(compute),\n    methods: methods\n  });\n\n  this.compute = compute;\n  this.name = name;\n}\n\nnodeutil.inherits(Service, ServiceObject);\n\n/**\n * Delete the backend service.\n *\n * @resource [BackendServices: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/backendServices/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * service.delete(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nService.prototype.delete = function(callback) {\n  var compute = this.compute;\n\n  callback = callback || util.noop;\n\n  ServiceObject.prototype.delete.call(this, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = compute.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\n/**\n * Get the most recent health check results.\n *\n * @resource [BackendServices: getHealth API Documentation]{@link https://cloud.google.com/compute/docs/reference/latest/backendServices/getHealth}\n *\n * @param {string|object} group - The fully-qualified URL of an Instance Group\n *     resource.\n * @param {string} group.name - The name of the Instance Group resource.\n * @param {module:compute/zone|string} group.zone - The name of the zone or a\n *     Zone object.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object[]} callback.status - A list of health checks and their\n *     corresponding status.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * service.getHealth({\n *   name: 'instance-group-name',\n *   zone: 'us-central1-a'\n * }, function(err, status, apiResponse) {\n *   if (!err) {\n *     // status = [\n *     //   {\n *     //      ipAddress: '...',\n *     //      instance: '...',\n *     //      healthState: '...',\n *     //      port: '...'\n *     //   }\n *     // ]\n *   }\n * });\n */\nService.prototype.getHealth = function(group, callback) {\n  if (!is.string(group)) {\n    group = format('{baseUrl}/projects/{p}/zones/{z}/instanceGroups/{n}', {\n      baseUrl: 'https://www.googleapis.com/compute/v1',\n      p: this.parent.projectId,\n      z: group.zone.name || group.zone,\n      n: group.name\n    });\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/getHealth',\n    json: {\n      group: group\n    }\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    callback(null, arrify(resp.healthStatus), resp);\n  });\n};\n\n/**\n * Set the backend service's metadata.\n *\n * @resource [BackendService Resource]{@link https://cloud.google.com/compute/docs/reference/v1/backendServices#resource}\n *\n * @param {object} metadata - See a\n *     [BackendService resource](https://cloud.google.com/compute/docs/reference/v1/backendServices#resource).\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var metadata = {\n *   description: 'New description'\n * };\n *\n * service.setMetadata(metadata, function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nService.prototype.setMetadata = function(metadata, callback) {\n  var compute = this.compute;\n\n  callback = callback || util.noop;\n\n  this.request({\n    method: 'PATCH',\n    uri: '',\n    json: metadata\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = compute.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\nmodule.exports = Service;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/snapshot.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/snapshot\n */\n\n'use strict';\n\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:compute|module:compute/disk} scope - The parent scope this\n *     snapshot belongs to. If it's a Disk, we expose the `create` methods.\n * @param {string} name - Snapshot name.\n */\n/**\n * A Snapshot object allows you to interact with a Google Compute Engine\n * snapshot.\n *\n * @resource [Snapshots Overview]{@link https://cloud.google.com/compute/docs/disks/persistent-disks#snapshots}\n * @resource [Snapshot Resource]{@link https://cloud.google.com/compute/docs/reference/v1/snapshots}\n *\n * @constructor\n * @alias module:compute/snapshot\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var snapshot = gce.snapshot('snapshot-name');\n *\n * //-\n * // Or, access through a disk.\n * //-\n * var disk = gce.zone('us-central1-a').disk('disk-name');\n * var snapshot = disk.snapshot('disk-snapshot-name');\n */\nfunction Snapshot(scope, name) {\n  var isDisk = scope.constructor.name === 'Disk';\n\n  var methods = {\n    /**\n     * Check if the snapshot exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the snapshot exists or not.\n     *\n     * @example\n     * snapshot.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a snapshot if it exists.\n     *\n     * If you access this snapshot through a Disk object, this can be used as a\n     * \"get or create\" method. Pass an object with `autoCreate` set to `true`.\n     * Any extra configuration that is normally required for the `create` method\n     * must be contained within this object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * snapshot.get(function(err, snapshot, apiResponse) {\n     *   // `snapshot` is a Snapshot object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the snapshot's metadata.\n     *\n     * @resource [Snapshot Resource]{@link https://cloud.google.com/compute/docs/reference/v1/snapshots}\n     * @resource [Snapshots: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/snapshots/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The snapshot's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * snapshot.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  var config = {\n    parent: scope,\n    baseUrl: '/global/snapshots',\n    id: name,\n    methods: methods\n  };\n\n  if (isDisk) {\n    config.createMethod = scope.createSnapshot.bind(scope);\n\n    /**\n     * Create a snapshot.\n     *\n     * **This is only available if you accessed this object through\n     * {module:compute/disk#snapshot}.**\n     *\n     * @param {object} config - See {module:compute/disk#createSnapshot}.\n     *\n     * @example\n     * snapshot.create(function(err, snapshot, operation, apiResponse) {\n     *   // `snapshot` is a Snapshot object.\n     *\n     *   // `operation` is an Operation object that can be used to check the\n     *   // status of the request.\n     * });\n     */\n    config.methods.create = true;\n  }\n\n  ServiceObject.call(this, config);\n\n  this.compute = isDisk ? scope.compute : scope;\n  this.name = name;\n}\n\nnodeutil.inherits(Snapshot, ServiceObject);\n\n/**\n * Delete the snapshot.\n *\n * @resource [Snapshots: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/snapshots/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * snapshot.delete(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nSnapshot.prototype.delete = function(callback) {\n  callback = callback || util.noop;\n\n  var compute = this.compute;\n\n  ServiceObject.prototype.delete.call(this, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = compute.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\nmodule.exports = Snapshot;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/zone.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/zone\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar async = require('async');\nvar extend = require('extend');\nvar format = require('string-format-obj');\nvar gceImages = require('gce-images');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:compute/autoscaler}\n * @private\n */\nvar Autoscaler = require('./autoscaler.js');\n\n/**\n * @type {module:compute/disk}\n * @private\n */\nvar Disk = require('./disk.js');\n\n/**\n * @type {module:compute/instance-group}\n * @private\n */\nvar InstanceGroup = require('./instance-group.js');\n\n/**\n * @type {module:compute/operation}\n * @private\n */\nvar Operation = require('./operation.js');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:compute/vm}\n * @private\n */\nvar VM = require('./vm.js');\n\n/*! Developer Documentation\n *\n * @param {module:compute} compute - Compute object this zone belongs to.\n * @param {string} name - Name of the zone.\n */\n/**\n * A Zone object allows you to interact with a Google Compute Engine zone.\n *\n * @resource [Regions & Zones Overview]{@link https://cloud.google.com/compute/docs/zones}\n * @resource [Zone Resource]{@link https://cloud.google.com/compute/docs/reference/v1/zones}\n *\n * @constructor\n * @alias module:compute/zone\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var zone = gce.zone('us-central1-a');\n */\nfunction Zone(compute, name) {\n  var methods = {\n    /**\n     * Check if the zone exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the zone exists or not.\n     *\n     * @example\n     * zone.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a zone.\n     *\n     * @example\n     * zone.get(function(err, zone, apiResponse) {\n     *   // `zone` is a Zone object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the zone's metadata.\n     *\n     * @resource [Zone Resource]{@link https://cloud.google.com/compute/docs/reference/v1/zones}\n     * @resource [Zones: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/zones/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The zone's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * zone.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: compute,\n    baseUrl: '/zones',\n    id: name,\n    methods: methods\n  });\n\n  this.compute = compute;\n  this.name = name;\n\n  this.gceImages = gceImages({\n    authClient: compute.authClient\n  });\n}\n\nnodeutil.inherits(Zone, ServiceObject);\n\n/**\n * Get a reference to a Google Compute Engine autoscaler in this zone.\n *\n * @param {string} name - Name of the autoscaler.\n * @return {module:compute/autoscaler}\n *\n * @example\n * var autoscaler = zone.autoscaler('autoscaler-name');\n */\nZone.prototype.autoscaler = function(name) {\n  return new Autoscaler(this, name);\n};\n\n/**\n * Create an autoscaler in this zone.\n *\n * @resource [Load Balancing and Scaling]{@link https://cloud.google.com/compute/docs/load-balancing-and-autoscaling}\n * @resource [Autoscaler Resource]{@link https://cloud.google.com/compute/docs/reference/v1/autoscalers}\n * @resource [Autoscalers: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/autoscalers/insert}\n *\n * @throws {Error} If `config.target` is not provided.\n *\n * @param {string} name - Name of the autoscaler.\n * @param {object} config - See an\n *     [Autoscaler resource](https://cloud.google.com/compute/docs/reference/v1/autoscalers).\n * @param {number} config.coolDown - The number of seconds that the autoscaler\n *     should wait before it starts collecting information from a new instance.\n *     Alias for `config.autoscalingPolicy.coolDownPeriodSec`.\n * @param {number} config.cpu - The target CPU utilization that the autoscaler\n *     should maintain, between 1 - 100. Alias for\n *     `config.autoscalingPolicy.cpuUtilization.utilizationTarget`.\n * @param {number} config.loadBalance - Backend capacity utilization that\n *     autoscaler should maintain, between 1 - 100. Alias for\n *     `config.autoscalingPolicy.loadBalancingUtilization.utilizationTarget`.\n * @param {number} config.maxReplicas - The maximum number of instances that the\n *     autoscaler can scale up to. Alias for\n *     `config.autoscalingPolicy.maxNumReplicas`.\n * @param {number} config.minReplicas - The minimum number of replicas that the\n *     autoscaler can scale down to. Alias for\n *     `config.autoscalingPolicy.minNumReplicas`.\n * @param {string} config.target - The name of the managed instance group that\n *     this autoscaler will scale.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/autoscaler} callback.autoscaler - The created\n *     Autoscaler object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var config = {\n *   coolDown: 30,\n *   cpu: 80,\n *   loadBalance: 40,\n *   maxReplicas: 5,\n *   minReplicas: 0,\n *   target: 'instance-group-1'\n * };\n *\n * function callback(err, autoscaler, operation, apiResponse) {\n *   // `autoscaler` is an Autoscaler object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * }\n *\n * zone.createAutoscaler('name', config, callback);\n */\nZone.prototype.createAutoscaler = function(name, config, callback) {\n  var self = this;\n\n  if (!config.target) {\n    throw new Error('Cannot create an autoscaler without a target.');\n  }\n\n  var json = extend(true, {}, config, {\n    name: name,\n    autoscalingPolicy: {}\n  });\n\n  if (!/^https*:/.test(json.target)) {\n    json.target = [\n      'https://content.googleapis.com/compute/v1/projects/',\n      this.compute.projectId,\n      '/zones/',\n      this.name,\n      '/instanceGroupManagers/',\n      json.target\n    ].join('');\n  }\n\n  if (is.defined(json.coolDown)) {\n    json.autoscalingPolicy.coolDownPeriodSec = json.coolDown;\n    delete json.coolDown;\n  }\n\n  if (is.defined(json.cpu)) {\n    json.autoscalingPolicy.cpuUtilization = {\n      utilizationTarget: json.cpu / 100\n    };\n    delete json.cpu;\n  }\n\n  if (is.defined(json.loadBalance)) {\n    json.autoscalingPolicy.loadBalancingUtilization = {\n      utilizationTarget: json.loadBalance / 100\n    };\n    delete json.loadBalance;\n  }\n\n  if (is.defined(json.maxReplicas)) {\n    json.autoscalingPolicy.maxNumReplicas = json.maxReplicas;\n    delete json.maxReplicas;\n  }\n\n  if (is.defined(json.minReplicas)) {\n    json.autoscalingPolicy.minNumReplicas = json.minReplicas;\n    delete json.minReplicas;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/autoscalers',\n    json: json\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var autoscaler = self.autoscaler(name);\n\n    var operation = self.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, autoscaler, operation, resp);\n  });\n};\n\n/**\n * Create a persistent disk in this zone.\n *\n * @resource [Disk Resource]{@link https://cloud.google.com/compute/docs/reference/v1/disks}\n * @resource [Disks: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/disks/insert}\n *\n * @param {string} name - Name of the disk.\n * @param {object} config - See a\n *     [Disk resource](https://cloud.google.com/compute/docs/reference/v1/disks).\n * @param {string=} config.os - Specify the name of an OS, and we will use the\n *     latest version as the source image of a new boot disk. See\n *     [this list of accepted OS names](https://github.com/stephenplusplus/gce-images#accepted-os-names).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/disk} callback.disk - The created Disk object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var config = {\n *   os: 'ubuntu',\n *   sizeGb: 10\n * };\n *\n * zone.createDisk('name', config, function(err, disk, operation, apiResponse) {\n *   // `disk` is a Disk object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nZone.prototype.createDisk = function(name, config, callback) {\n  var self = this;\n\n  var query = {};\n  var body = extend({}, config, {\n    name: name\n  });\n\n  if (body.image) {\n    query.sourceImage = body.image;\n    delete body.image;\n  }\n\n  if (body.os) {\n    this.gceImages.getLatest(body.os, function(err, image) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      delete body.os;\n      body.sourceImage = image.selfLink;\n\n      self.createDisk(name, body, callback);\n    });\n    return;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/disks',\n    qs: query,\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var disk = self.disk(name);\n\n    var operation = self.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, disk, operation, resp);\n  });\n};\n\n/**\n * Create an instance group in this zone.\n *\n * @resource [InstanceGroup Resource]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups#resource}\n * @resource [InstanceGroups: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups/insert}\n *\n * @param {string} name - Name of the instance group.\n * @param {object} options - See an\n *     [InstanceGroup resource](https://cloud.google.com/compute/docs/reference/v1/instanceGroups#resource).\n * @param {object} options.ports - A map of names to ports. The key should be\n *     the name, and the value the port number. Maps to `options.namedPorts`.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/instance-group} callback.instanceGroup - The created\n *     InstanceGroup object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * function onCreated(err, instanceGroup, operation, apiResponse) {\n *   // `instanceGroup` is an InstanceGroup object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * }\n *\n * zone.createInstanceGroup('instance-group-name', onCreated);\n */\nZone.prototype.createInstanceGroup = function(name, options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var body = extend({}, options, {\n    name: name\n  });\n\n  if (body.ports) {\n    body.namedPorts = InstanceGroup.formatPorts_(body.ports);\n    delete body.ports;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/instanceGroups',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var instanceGroup = self.instanceGroup(name);\n\n    var operation = self.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, instanceGroup, operation, resp);\n  });\n};\n\n/**\n * Create a virtual machine in this zone.\n *\n * @resource [Instance Resource]{@link https://cloud.google.com/compute/docs/reference/v1/instances}\n * @resource [Instances: insert API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/insert}\n *\n * @param {string} name - Name of the instance.\n * @param {object} config - See an\n *     [Instance resource](https://cloud.google.com/compute/docs/reference/v1/instances).\n * @param {object[]=} config.disks - See a\n *     [Disk resource](https://cloud.google.com/compute/docs/reference/v1/disks).\n * @param {boolean=} config.http - Allow HTTP traffic. Default: `false`\n * @param {boolean=} config.https - Allow HTTPS traffic. Default: `false`\n * @param {object[]=} config.networkInterfaces - An array of configurations for\n *     this interface. This specifies how this interface should interact with\n *     other network services, such as connecting to the internet. Default:\n *     `[ { network: 'global/networks/default' } ]`\n * @param {string=} config.machineType - The machine type resource to use.\n *     Provide only the name of the machine, e.g. `n1-standard-16`. Refer to\n *     [Available Machine Types](https://goo.gl/jrHEbo). Default:\n *     `n1-standard-1`\n * @param {string=} config.os - Specify the name of an OS, and we will use the\n *     latest version as the source image of a new boot disk. See\n *     [this list of accepted OS names](https://github.com/stephenplusplus/gce-images#accepted-os-names).\n * @param {string[]=} config.tags - An array of tags.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/vm} callback.vm - The created VM object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // Create a new instance using the latest Debian version as the source image\n * // for a new boot disk.\n * //-\n * var config = {\n *   os: 'debian',\n *   http: true,\n *   tags: ['debian-server']\n * };\n *\n * //-\n * // The above object will auto-expand behind the scenes to something like the\n * // following. The Debian version may be different when you run the command.\n * //-\n * var config = {\n *   machineType: 'n1-standard-1',\n *   disks: [\n *     {\n *       boot: true,\n *       initializeParams: {\n *         sourceImage:\n *           'https://www.googleapis.com/compute/v1/projects' +\n *           '/debian-cloud/global/images/debian-7-wheezy-v20150710'\n *       }\n *     }\n *   ],\n *   networkInterfaces: [\n *     {\n *       network: 'global/networks/default'\n *     }\n *   ],\n *   tags: [\n *     {\n *       items: [\n *         'debian-server',\n *         'http-server'\n *       ]\n *     }\n *   ]\n * };\n *\n * function callback(err, vm, operation, apiResponse) {\n *   // `vm` is a VM object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * }\n *\n * zone.createVM('new-vm-name', config, callback);\n */\nZone.prototype.createVM = function(name, config, callback) {\n  var self = this;\n\n  var body = extend({\n    name: name,\n    machineType: 'n1-standard-1',\n    networkInterfaces: [\n      {\n        network: 'global/networks/default'\n      }\n    ]\n  }, config);\n\n  if (body.machineType.indexOf('/') === -1) {\n    // The specified machineType is only a partial name, e.g. 'n1-standard-1'.\n    body.machineType = format('zones/{zoneName}/machineTypes/{machineType}', {\n      zoneName: this.name,\n      machineType: body.machineType\n    });\n  }\n\n  if (is.array(body.tags)) {\n    body.tags = {\n      items: body.tags\n    };\n  }\n\n  if (body.http || body.https) {\n    // We will add tags to the created instance (http-server and/or\n    // https-server), and create the appropriate firewall rules to allow\n    // connections on the necessary ports to these tags.\n    var createFirewallMethods = [];\n\n    body.networkInterfaces[0].accessConfigs = [\n      {\n        type: 'ONE_TO_ONE_NAT'\n      }\n    ];\n\n    body.tags = body.tags || {};\n    body.tags.items = body.tags.items || [];\n\n    if (body.http) {\n      delete body.http;\n\n      createFirewallMethods.push(this.createHttpServerFirewall_.bind(this));\n\n      if (body.tags.items.indexOf('http-server') === -1) {\n        body.tags.items.push('http-server');\n      }\n    }\n\n    if (body.https) {\n      delete body.https;\n\n      createFirewallMethods.push(this.createHttpsServerFirewall_.bind(this));\n\n      if (body.tags.items.indexOf('https-server') === -1) {\n        body.tags.items.push('https-server');\n      }\n    }\n\n    // We have to make sure the firewall rules exist to allow HTTP/S traffic.\n    async.parallel(createFirewallMethods, function(err) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      self.createVM(name, body, callback);\n    });\n\n    return;\n  }\n\n  if (body.os) {\n    this.gceImages.getLatest(body.os, function(err, image) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      delete body.os;\n      body.disks = body.disks || [];\n      body.disks.push({\n        autoDelete: true,\n        boot: true,\n        initializeParams: {\n          sourceImage: image.selfLink\n        }\n      });\n\n      self.createVM(name, body, callback);\n    });\n\n    return;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/instances',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var vm = self.vm(name);\n\n    var operation = self.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, vm, operation, resp);\n  });\n};\n\n/**\n * Get a reference to a Google Compute Engine disk in this zone.\n *\n * @resource [Disks Overview]{@link https://cloud.google.com/compute/docs/disks}\n *\n * @param {string} name - Name of the disk.\n * @return {module:compute/disk}\n *\n * @example\n * var disk = zone.disk('disk1');\n */\nZone.prototype.disk = function(name) {\n  return new Disk(this, name);\n};\n\n/**\n * Get a list of autoscalers from this zone.\n *\n * @resource [Managing Autoscalers]{@link https://cloud.google.com/compute/docs/autoscaler/managing-autoscalers}\n * @resource [Understanding Autoscaler Decisions]{@link https://cloud.google.com/compute/docs/autoscaler/understanding-autoscaler-decisions}\n * @resource [Autoscalers: aggregatedList API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/autoscalers/list}\n *\n * @param {object=} options - Autoscaler search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of autoscalers to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/autoscaler[]} callback.autoscalers - Autoscaler\n *     objects from your project.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * zone.getAutoscalers(function(err, autoscalers) {\n *   // autoscalers is an array of `Autoscaler` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, autoscalers, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     zone.getAutoscalers(nextQuery, callback);\n *   }\n * }\n *\n * zone.getAutoscalers({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the autoscalers from this zone as a readable object stream.\n * //-\n * zone.getAutoscalers()\n *   .on('error', console.error)\n *   .on('data', function(autoscaler) {\n *     // `autoscaler` is an `Autoscaler` object.\n *   })\n *   .on('end', function() {\n *     // All autoscalers retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * zone.getAutoscalers()\n *   .on('data', function(autoscaler) {\n *     this.end();\n *   });\n */\nZone.prototype.getAutoscalers = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/autoscalers',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var autoscalers = arrify(resp.items).map(function(autoscaler) {\n      var autoscalerInstance = self.autoscaler(autoscaler.name);\n      autoscalerInstance.metadata = autoscaler;\n\n      return autoscalerInstance;\n    });\n\n    callback(null, autoscalers, nextQuery, resp);\n  });\n};\n\n/**\n *  Get a list of disks in this zone.\n *\n * @resource [Disks Overview]{@link https://cloud.google.com/compute/docs/disks}\n * @resource [Disks: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/disks/list}\n *\n * @param {object=} options - Disk search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n  *     `{name} {comparison} {filterString}`.\n  *     - **`name`**: the name of the field to compare\n  *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n  *       (not equal)\n  *     - **`filterString`**: the string to filter to. For string fields, this\n  *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of disks to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/disk} callback.disks - Disk objects from this zone.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * zone.getDisks(function(err, disks) {\n *   // `disks` is an array of `Disk` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, disks, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     zone.getDisks(nextQuery, callback);\n *   }\n * }\n *\n * zone.getDisks({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the disks from your project as a readable object stream.\n * //-\n * zone.getDisks()\n *   .on('error', console.error)\n *   .on('data', function(disk) {\n *     // `disk` is a `Disk` object.\n *   })\n *   .on('end', function() {\n *     // All disks retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * zone.getDisks()\n *   .on('data', function(disk) {\n *     this.end();\n *   });\n */\nZone.prototype.getDisks = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/disks',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var disks = (resp.items || []).map(function(disk) {\n      var diskInstance = self.disk(disk.name);\n      diskInstance.metadata = disk;\n      return diskInstance;\n    });\n\n    callback(null, disks, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of instance groups for this zone.\n *\n * @resource [InstanceGroups Overview]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups}\n * @resource [InstanceGroups: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups/list}\n *\n * @param {object=} options - Instance group search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of instance groups to\n *     return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/instance-group[]} callback.instanceGroups -\n *     InstanceGroup objects from this zone.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * zone.getInstanceGroups(function(err, instanceGroups) {\n *   // `instanceGroups` is an array of `InstanceGroup` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, instanceGroups, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     zone.getInstanceGroups(nextQuery, callback);\n *   }\n * }\n *\n * zone.getInstanceGroups({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the instance groups from your project as a readable object stream.\n * //-\n * zone.getInstanceGroups()\n *   .on('error', console.error)\n *   .on('data', function(instanceGroup) {\n *     // `instanceGroup` is an `InstanceGroup` object.\n *   })\n *   .on('end', function() {\n *     // All instance groups retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * zone.getInstanceGroups()\n *   .on('data', function(instanceGroup) {\n *     this.end();\n *   });\n */\nZone.prototype.getInstanceGroups = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/instanceGroups',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var instanceGroups = (resp.items || []).map(function(instanceGroup) {\n      var instanceGroupInstance = self.instanceGroup(instanceGroup.name);\n      instanceGroupInstance.metadata = instanceGroup;\n      return instanceGroupInstance;\n    });\n\n    callback(null, instanceGroups, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of operations for this zone.\n *\n * @resource [Zone Operation Overview]{@link https://cloud.google.com/compute/docs/reference/v1/zoneOperations}\n * @resource [ZoneOperations: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/zoneOperations/list}\n *\n * @param {object=} options - Operation search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of operations to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operations - Operation objects\n *     from this zone.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * zone.getOperations(function(err, operations) {\n *   // `operations` is an array of `Operation` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, operations, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     zone.getOperations(nextQuery, callback);\n *   }\n * }\n *\n * zone.getOperations({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the operations from your project as a readable object stream.\n * //-\n * zone.getOperations()\n *   .on('error', console.error)\n *   .on('data', function(operation) {\n *     // `operation` is an `Operation` object.\n *   })\n *   .on('end', function() {\n *     // All operations retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * zone.getOperations()\n *   .on('data', function(operation) {\n *     this.end();\n *   });\n */\nZone.prototype.getOperations = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/operations',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var operations = (resp.items || []).map(function(operation) {\n      var operationInstance = self.operation(operation.name);\n      operationInstance.metadata = operation;\n      return operationInstance;\n    });\n\n    callback(null, operations, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of VM instances in this zone.\n *\n * @resource [Instances and Networks]{@link https://cloud.google.com/compute/docs/instances-and-network}\n * @resource [Instances: list API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/list}\n *\n * @param {object=} options - Instance search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/vm} callback.vms - VM objects from this zone.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * zone.getVMs(function(err, vms) {\n *   // `vms` is an array of `VM` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * functionÂ callback(err, vms, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     zone.getVMs(nextQuery, callback);\n *   }\n * }\n *\n * zone.getVMs({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the VM instances from your project as a readable object stream.\n * //-\n * zone.getVMs()\n *   .on('error', console.error)\n *   .on('data', function(vm) {\n *     // `vm` is a `VM` object.\n *   })\n *   .on('end', function() {\n *     // All instances retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * zone.getVMs()\n *   .on('data', function(vm) {\n *     this.end();\n *   });\n */\nZone.prototype.getVMs = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/instances',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var vms = (resp.items || []).map(function(instance) {\n      var vmInstance = self.vm(instance.name);\n      vmInstance.metadata = instance;\n      return vmInstance;\n    });\n\n    callback(null, vms, nextQuery, resp);\n  });\n};\n\n/**\n * Get a reference to a Google Compute Engine instance group.\n *\n * @resource [InstanceGroups Overview]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups}\n *\n * @param {string} name - Name of the existing instance group.\n * @return {module:compute/instance-group}\n *\n * @example\n * var instanceGroup = zone.instanceGroup('my-instance-group');\n */\nZone.prototype.instanceGroup = function(name) {\n  return new InstanceGroup(this, name);\n};\n\n/**\n * Get a reference to a Google Compute Engine zone operation.\n *\n * @resource [Zone Operation Overview]{@link https://cloud.google.com/compute/docs/reference/v1/zoneOperations}\n *\n * @param {string} name - Name of the existing operation.\n * @return {module:compute/operation}\n *\n * @example\n * var operation = zone.operation('operation-1445532685163-8b137d2a-1822afe7');\n */\nZone.prototype.operation = function(name) {\n  return new Operation(this, name);\n};\n\n/**\n * Get a reference to a Google Compute Engine virtual machine instance.\n *\n * @resource [Instances and Networks]{@link https://cloud.google.com/compute/docs/instances-and-network}\n *\n * @param {string} name - Name of the virtual machine.\n * @return {module:compute/vm}\n *\n * @example\n * var vm = zone.vm('vm-name');\n */\nZone.prototype.vm = function(name) {\n  return new VM(this, name);\n};\n\n/**\n * This method attempts to create a firewall rule to allow tcp:80 connections.\n *\n * @private\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - If the firewall couldn't be created and it\n *     didn't already exist.\n */\nZone.prototype.createHttpServerFirewall_ = function(callback) {\n  this.compute.createFirewall('default-allow-http', {\n    protocols: {\n      tcp: [80]\n    },\n    ranges: ['0.0.0.0/0'],\n    tags: ['http-server']\n  }, function(err) {\n    // If it already exists, we're all good.\n    callback(err && err.code !== 409 ? err : null);\n  });\n};\n\n/**\n * This method attempts to create a firewall rule to allow tcp:443 connections.\n *\n * @private\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - If the firewall couldn't be created and it\n *     didn't already exist.\n */\nZone.prototype.createHttpsServerFirewall_ = function(callback) {\n  this.compute.createFirewall('default-allow-https', {\n    protocols: {\n      tcp: [443]\n    },\n    ranges: ['0.0.0.0/0'],\n    tags: ['https-server']\n  }, function(err) {\n    // If it already exists, we're all good.\n    callback(err && err.code !== 409 ? err : null);\n  });\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(Zone, [\n  'getAutoscalers',\n  'getDisks',\n  'getInstanceGroups',\n  'getOperations',\n  'getVMs'\n]);\n\nmodule.exports = Zone;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/autoscaler.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/autoscaler\n */\n\n'use strict';\n\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:compute/zone} zone - Zone object this autoscaler belongs to.\n * @param {string} name - Name of the autoscaler.\n */\n/**\n * Autoscalers allow you to automatically scale virtual machine instances in\n * managed instance groups according to an autoscaling policy that you define.\n *\n * @resource [Autoscaling Groups of Instances]{@link https://cloud.google.com/compute/docs/autoscaler}\n *\n * @constructor\n * @alias module:compute/autoscaler\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var zone = gce.zone('us-central1-a');\n *\n * var autoscaler = zone.autoscaler('autoscaler-name');\n */\nfunction Autoscaler(zone, name) {\n  var methods = {\n    /**\n     * Create an autoscaler.\n     *\n     * @param {object} config - See {module:compute/zone#createAutoscaler}.\n     *\n     * @example\n     * autoscaler.create({\n     *   coolDown: 30,\n     *   cpu: 80,\n     *   loadBalance: 40,\n     *   maxReplicas: 5,\n     *   minReplicas: 0,\n     *   target: 'instance-group-1'\n     * }, function(err, autoscaler, operation, apiResponse) {\n     *   // `autoscaler` is an Autoscaler object.\n     *\n     *   // `operation` is an Operation object that can be used to check the\n     *   // of the request.\n     * });\n     */\n    create: true,\n\n    /**\n     * Check if the autoscaler exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the autoscaler exists or not.\n     *\n     * @example\n     * autoscaler.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get an autoscaler if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * autoscaler.get(function(err, autoscaler, apiResponse) {\n     *   // `autoscaler` is an Autoscaler object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the metadata of this autoscaler.\n     *\n     * @resource [Autoscaler Resource]{@link https://cloud.google.com/compute/docs/reference/v1/autoscalers}\n     * @resource [Autoscalers: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/autoscalers/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The autoscaler's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * autoscaler.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: zone,\n    baseUrl: '/autoscalers',\n    id: name,\n    createMethod: zone.createAutoscaler.bind(zone),\n    methods: methods\n  });\n\n  this.name = name;\n  this.zone = zone;\n}\n\nnodeutil.inherits(Autoscaler, ServiceObject);\n\n/**\n * Delete the autoscaler.\n *\n * @resource [Autoscalers: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/autoscalers/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * autoscaler.delete(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nAutoscaler.prototype.delete = function(callback) {\n  callback = callback || util.noop;\n\n  var zone = this.zone;\n\n  ServiceObject.prototype.delete.call(this, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = zone.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\n/**\n * Set the autoscaler's metadata.\n *\n * @resource [Autoscaler Resource]{@link https://cloud.google.com/compute/docs/reference/v1/autoscalers}\n *\n * @param {object} metadata - See a\n *     [Firewall resource](https://cloud.google.com/compute/docs/reference/v1/autoscalers).\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var metadata = {\n *   description: 'New description'\n * };\n *\n * autoscaler.setMetadata(metadata, function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nAutoscaler.prototype.setMetadata = function(metadata, callback) {\n  var zone = this.zone;\n\n  callback = callback || util.noop;\n\n  metadata = metadata || {};\n  metadata.name = this.name;\n  metadata.zone = this.zone.name;\n\n  zone.request({\n    method: 'PATCH',\n    uri: '/autoscalers',\n    qs: {\n      autoscaler: this.name\n    },\n    json: metadata\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = zone.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\nmodule.exports = Autoscaler;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/disk.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/disk\n */\n\n'use strict';\n\nvar extend = require('extend');\nvar format = require('string-format-obj');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:compute/snapshot}\n * @private\n */\nvar Snapshot = require('./snapshot.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:zone} zone - Zone this disk belongs to.\n * @param {string} name - The name of the disk.\n */\n/**\n * A Disk object allows you to interact with a Google Compute Engine disk.\n *\n * @resource [Disks Overview]{@link https://cloud.google.com/compute/docs/disks}\n * @resource [Disk Resource]{@link https://cloud.google.com/compute/docs/reference/v1/disks}\n *\n * @constructor\n * @alias module:compute/disk\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var zone = gce.zone('zone-name');\n *\n * var disk = zone.disk('disk1');\n */\nfunction Disk(zone, name) {\n  var methods = {\n    /**\n     * Create a persistent disk.\n     *\n     * @param {object} config - See {module:compute/zone#createDisk}.\n     *\n     * @example\n     * var config = {\n     *   // ...\n     * };\n     *\n     * disk.create(config, function(err, disk, operation, apiResponse) {\n     *   // `disk` is a Disk object.\n     *\n     *   // `operation` is an Operation object that can be used to check the\n     *   // status of the request.\n     * });\n     */\n    create: true,\n\n    /**\n     * Check if the disk exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the disk exists or not.\n     *\n     * @example\n     * disk.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a disk if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * disk.get(function(err, disk, apiResponse) {\n     *   // `disk` is a Disk object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the disk's metadata.\n     *\n     * @resource [Disk Resource]{@link https://cloud.google.com/compute/docs/reference/v1/disks}\n     * @resource [Disks: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/disks/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The disk's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * disk.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: zone,\n    baseUrl: '/disks',\n    id: name,\n    createMethod: zone.createDisk.bind(zone),\n    methods: methods\n  });\n\n  this.name = name;\n  this.zone = zone;\n\n  this.formattedName = Disk.formatName_(zone, name);\n}\n\nnodeutil.inherits(Disk, ServiceObject);\n\n/**\n * Format a disk's name how the API expects.\n *\n * @private\n *\n * @param {module:compute/zone} zone - The Zone this disk belongs to.\n * @param {string} name - The name of the disk.\n * @return {string} - The formatted name.\n */\nDisk.formatName_ = function(zone, name) {\n  return format('projects/{pId}/zones/{zoneName}/disks/{diskName}', {\n    pId: zone.compute.projectId,\n    zoneName: zone.name,\n    diskName: name\n  });\n};\n\n/**\n * Create a snapshot of a disk.\n *\n * @resource [Snapshots Overview]{@link https://cloud.google.com/compute/docs/disks/persistent-disks#snapshots}\n * @resource [Disks: createSnapshot API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/disks/createSnapshot}\n *\n * @param {string} name - Name of the snapshot.\n * @param {object=} options - See the\n *     [Disks: createSnapshot](https://cloud.google.com/compute/docs/reference/v1/disks/createSnapshot)\n *     request body.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/snapshot} callback.snapshot - The created Snapshot\n *     object.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * function callback(err, snapshot, operation, apiResponse) {\n *   // `snapshot` is a Snapshot object.\n *\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * }\n *\n * disk.createSnapshot('new-snapshot-name', callback);\n */\nDisk.prototype.createSnapshot = function(name, options, callback) {\n  var self = this;\n  var zone = this.zone;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/createSnapshot',\n    json: extend({}, options, {\n      name: name\n    })\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var snapshot = self.snapshot(name);\n\n    var operation = zone.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, snapshot, operation, resp);\n  });\n};\n\n/**\n * Delete the disk.\n *\n * @resource [Disks: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/disks/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * disk.delete(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nDisk.prototype.delete = function(callback) {\n  var zone = this.zone;\n\n  callback = callback || util.noop;\n\n  ServiceObject.prototype.delete.call(this, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = zone.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\n/**\n * Get a reference to a snapshot from this disk.\n *\n * @resource [Snapshots Overview]{@link https://cloud.google.com/compute/docs/disks/persistent-disks#snapshots}\n *\n * @param {string} name - Name of the snapshot.\n * @return {module:compute/snapshot}\n *\n * @example\n * var snapshot = disk.snapshot('snapshot-name');\n */\nDisk.prototype.snapshot = function(name) {\n  return new Snapshot(this, name);\n};\n\nmodule.exports = Disk;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/instance-group.js":"/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/instance-group\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar extend = require('extend');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:compute/zone} zone - Zone object this instance group belongs\n *     to.\n * @param {string} name - Name of the instance group.\n */\n/**\n * You can create and manage groups of virtual machine instances so that you\n * don't have to individually control each instance in your project.\n *\n * @resource [Creating Groups of Instances]{@link https://cloud.google.com/compute/docs/instance-groups}\n * @resource [Unmanaged Instance Groups]{@link https://cloud.google.com/compute/docs/instance-groups/unmanaged-groups}\n *\n * @constructor\n * @alias module:compute/instance-group\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var zone = gce.zone('us-central1-a');\n *\n * var instanceGroup = zone.instanceGroup('web-servers');\n */\nfunction InstanceGroup(zone, name) {\n  var methods = {\n    /**\n     * Create an instance group.\n     *\n     * @param {object=} options - See {module:zone#createInstanceGroup}.\n     *\n     * @example\n     * function onCreated(err, instanceGroup, operation, apiResponse) {\n     *   // `instanceGroup` is an InstanceGroup object.\n     *\n     *   // `operation` is an Operation object that can be used to check the\n     *   // status of the request.\n     * }\n     *\n     * instanceGroup.create(onCreated);\n     */\n    create: true,\n\n    /**\n     * Check if the instance group exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the instance group exists or\n     *     not.\n     *\n     * @example\n     * instanceGroup.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get an instance group if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * instanceGroup.get(function(err, instanceGroup, apiResponse) {\n     *   // `instanceGroup` is an InstanceGroup object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the instance group's metadata.\n     *\n     * @resource [InstanceGroups: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups/get}\n     * @resource [InstanceGroups Resource]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The instance group's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * instanceGroup.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: zone,\n    baseUrl: '/instanceGroups',\n    id: name,\n    createMethod: zone.createInstanceGroup.bind(zone),\n    methods: methods\n  });\n\n  this.zone = zone;\n  this.name = name;\n}\n\nnodeutil.inherits(InstanceGroup, ServiceObject);\n\n/**\n * Format a map of named ports in the way the API expects.\n *\n * @private\n *\n * @param {object} ports - A map of names to ports. The key should be the name,\n *     and the value the port number.\n * @return {object[]} - The formatted array of named ports.\n */\nInstanceGroup.formatPorts_ = function(ports) {\n  return Object.keys(ports).map(function(port) {\n    return {\n      name: port,\n      port: ports[port]\n    };\n  });\n};\n\n/**\n * Add one or more VMs to this instance group.\n *\n * @resource [InstanceGroups: addInstances API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups/addInstances}\n *\n * @param {module:compute/vm|module:compute/vm[]} vms - VM instances to add to\n *     this instance group.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var vms = [\n *   gce.zone('us-central1-a').vm('http-server'),\n *   gce.zone('us-central1-a').vm('https-server')\n * ];\n *\n * instanceGroup.add(vms, function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nInstanceGroup.prototype.add = function(vms, callback) {\n  var self = this;\n\n  this.request({\n    method: 'POST',\n    uri: '/addInstances',\n    json: {\n      instances: arrify(vms).map(function(vm) {\n        return {\n          instance: vm.url\n        };\n      })\n    }\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = self.zone.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\n/**\n * Delete the instance group.\n *\n * @resource [InstanceGroups: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * instanceGroup.delete(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nInstanceGroup.prototype.delete = function(callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  ServiceObject.prototype.delete.call(this, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = self.zone.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\n/**\n * Get a list of VM instances in this instance group.\n *\n * @resource [InstaceGroups: listInstances API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups/listInstances}\n *\n * @param {object=} options - Instance search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - Search filter in the format of\n *     `{name} {comparison} {filterString}`.\n *     - **`name`**: the name of the field to compare\n *     - **`comparison`**: the comparison operator, `eq` (equal) or `ne`\n *       (not equal)\n *     - **`filterString`**: the string to filter to. For string fields, this\n *       can be a regular expression.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of VMs to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {boolean} options.running - Only return instances which are running.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/vm[]} callback.vms - VM objects from this isntance\n *     group.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * instanceGroup.getVMs(function(err, vms) {\n *   // `vms` is an array of `VM` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * functionÂ callback(err, vms, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     instanceGroup.getVMs(nextQuery, callback);\n *   }\n * }\n *\n * instanceGroup.getVMs({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the VM instances from your project as a readable object stream.\n * //-\n * instanceGroup.getVMs()\n *   .on('error', console.error)\n *   .on('data', function(vm) {\n *     // `vm` is a `VM` object.\n *   })\n *   .on('end', function() {\n *     // All instances retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * instanceGroup.getVMs()\n *   .on('data', function(vm) {\n *     this.end();\n *   });\n */\nInstanceGroup.prototype.getVMs = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  var body;\n\n  if (options.running) {\n    body = {\n      instanceState: 'RUNNING'\n    };\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/listInstances',\n    qs: options,\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var vms = arrify(resp.items).map(function(vm) {\n      var vmInstance = self.zone.vm(vm.instance);\n      vmInstance.metadata = vm;\n      return vmInstance;\n    });\n\n    callback(null, vms, nextQuery, resp);\n  });\n};\n\n/**\n * Remove one or more VMs from this instance group.\n *\n * @resource [InstanceGroups: removeInstances API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups/removeInstances}\n *\n * @param {module:compute/vm|module:compute/vm[]} vms - VM instances to remove\n *     from this instance group.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var vms = [\n *   gce.zone('us-central1-a').vm('http-server'),\n *   gce.zone('us-central1-a').vm('https-server')\n * ];\n *\n * instanceGroup.remove(vms, function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nInstanceGroup.prototype.remove = function(vms, callback) {\n  var self = this;\n\n  this.request({\n    method: 'POST',\n    uri: '/removeInstances',\n    json: {\n      instances: arrify(vms).map(function(vm) {\n        return {\n          instance: vm.url\n        };\n      })\n    }\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = self.zone.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(err, operation, resp);\n  });\n};\n\n/**\n * Set the named ports for this instance group.\n *\n * @resource [InstanceGroups: setNamedPorts API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instanceGroups/setNamedPorts}\n *\n * @param {object} ports - A map of names to ports. The key should be the name,\n *     and the value the port number.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var ports = {\n *   http: 80,\n *   https: 443\n * };\n *\n * instanceGroup.setPorts(ports, function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nInstanceGroup.prototype.setPorts = function(ports, callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  this.request({\n    method: 'POST',\n    uri: '/setNamedPorts',\n    json: {\n      namedPorts: InstanceGroup.formatPorts_(ports)\n    }\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = self.zone.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(InstanceGroup, ['getVMs']);\n\nmodule.exports = InstanceGroup;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/compute/vm.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module compute/vm\n */\n\n'use strict';\n\nvar createErrorClass = require('create-error-class');\nvar extend = require('extend');\nvar format = require('string-format-obj');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:compute/disk}\n * @private\n */\nvar Disk = require('./disk.js');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * Custom error type for errors related to detaching a disk.\n *\n * @private\n *\n * @param {string} message - Custom error message.\n * @return {Error}\n */\nvar DetachDiskError = createErrorClass('DetachDiskError', function(message) {\n  this.message = message;\n});\n\n/*! Developer Documentation\n *\n * @param {module:zone} zone - Zone object this instance belongs to.\n * @param {string} name - Name of the instance.\n */\n/**\n * An Instance object allows you to interact with a Google Compute Engine\n * instance.\n *\n * @resource [Instances and Networks]{@link https://cloud.google.com/compute/docs/instances-and-network}\n * @resource [Instance Resource]{@link https://cloud.google.com/compute/docs/reference/v1/instances}\n *\n * @constructor\n * @alias module:compute/vm\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var gce = gcloud.compute();\n *\n * var zone = gce.zone('zone-name');\n *\n * var vm = zone.vm('vm-name');\n */\nfunction VM(zone, name) {\n  this.name = name.replace(/.*\\/([^/]+)$/, '$1'); // Just the instance name.\n  this.zone = zone;\n\n  this.url = format('{base}/{project}/zones/{zone}/instances/{name}', {\n    base: 'https://www.googleapis.com/compute/v1/projects',\n    project: zone.compute.projectId,\n    zone: zone.name,\n    name: this.name\n  });\n\n  var methods = {\n    /**\n     * Create a virtual machine.\n     *\n     * @param {object} config - See {module:compute/zone#createVM}.\n     *\n     * @example\n     * var config = {\n     *   // ...\n     * };\n     *\n     * vm.create(config, function(err, vm, operation, apiResponse) {\n     *   // `vm` is a VM object.\n     *\n     *   // `operation` is an Operation object that can be used to check the\n     *   // status of the request.\n     * });\n     */\n    create: true,\n\n    /**\n     * Check if the vm exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the vm exists or not.\n     *\n     * @example\n     * vm.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a virtual machine if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * vm.get(function(err, vm, apiResponse) {\n     *   // `vm` is a VM object.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the instance's metadata.\n     *\n     * @resource [Instance Resource]{@link https://cloud.google.com/compute/docs/reference/v1/instances}\n     * @resource [Instance: get API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The instance's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * vm.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: zone,\n    baseUrl: '/instances',\n    id: this.name,\n    createMethod: zone.createVM.bind(zone),\n    methods: methods\n  });\n}\n\nnodeutil.inherits(VM, ServiceObject);\n\n/**\n * Attach a disk to the instance.\n *\n * @resource [Disks Overview]{@link https://cloud.google.com/compute/docs/disks}\n * @resource [Disk Resource]{@link https://cloud.google.com/compute/docs/reference/v1/disks}\n * @resource [Instance: attachDisk API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/attachDisk}\n *\n * @throws {Error} if a {module:compute/disk} is not provided.\n *\n * @param {module:compute/disk} disk - The disk to attach.\n * @param {object=} options - See the\n *     [Instances: attachDisk](https://cloud.google.com/compute/docs/reference/v1/instances/attachDisk)\n *     request body.\n * @param {boolean} options.readOnly - Attach the disk in read-only mode. (Alias\n *     for `options.mode = READ_ONLY`)\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var disk = zone.disk('my-disk');\n *\n * function callback(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * }\n *\n * vm.attachDisk(disk, callback);\n *\n * //-\n * // Provide an options object to customize the request.\n * //-\n * var options = {\n *   autoDelete: true,\n *   readOnly: true\n * };\n *\n * vm.attachDisk(disk, options, callback);\n */\nVM.prototype.attachDisk = function(disk, options, callback) {\n  if (!(disk instanceof Disk)) {\n    throw new Error('A Disk object must be provided.');\n  }\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var body = extend({\n    // Default the deviceName to the name of the disk, like the Console does.\n    deviceName: disk.name\n  }, options, {\n    source: disk.formattedName\n  });\n\n  if (body.readOnly) {\n    body.mode = 'READ_ONLY';\n    delete body.readOnly;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/attachDisk',\n    json: body\n  }, callback);\n};\n\n/**\n * Delete the instance.\n *\n * @resource [Instance: delete API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * vm.delete(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nVM.prototype.delete = function(callback) {\n  this.request({\n    method: 'DELETE',\n    uri: ''\n  }, callback || util.noop);\n};\n\n/**\n * Detach a disk from the instance.\n *\n * @resource [Instance: detachDisk API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/detachDisk}\n *\n * @param {module:compute/disk|string} deviceName - The device name of the disk\n *     to detach. If a Disk object is provided, we try to find the device name\n *     automatically by searching through the attached disks on the instance.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var disk = zone.disk('my-disk');\n *\n * vm.detachDisk(disk, function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nVM.prototype.detachDisk = function(disk, callback) {\n  var self = this;\n\n  if (!(disk instanceof Disk)) {\n    throw new Error('A Disk object must be provided.');\n  }\n\n  this.getMetadata(function(err, metadata) {\n    if (err) {\n      callback(new DetachDiskError(err.message));\n      return;\n    }\n\n    var deviceName;\n    var baseUrl = 'https://www.googleapis.com/compute/v1/';\n    var disks = metadata.disks || [];\n\n    // Try to find the deviceName by matching the source of the attached disks\n    // to the name of the disk provided by the user.\n    for (var i = 0; !deviceName && i < disks.length; i++) {\n      var attachedDisk = disks[i];\n      var source = attachedDisk.source.replace(baseUrl, '');\n\n      if (source === disk.formattedName) {\n        deviceName = attachedDisk.deviceName;\n      }\n    }\n\n    if (!deviceName) {\n      callback(new DetachDiskError('Device name for this disk was not found.'));\n      return;\n    }\n\n    self.request({\n      method: 'POST',\n      uri: '/detachDisk',\n      qs: {\n        deviceName: deviceName\n      }\n    }, callback || util.noop);\n  });\n};\n\n/**\n * Returns the serial port output for the instance.\n *\n * @resource [Instances: getSerialPortOutput API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/getSerialPortOutput}\n *\n * @param {number=} port - The port from which the output is retrieved (1-4).\n *    Default: `1`.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.output - The output from the port.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * vm.getSerialPortOutput(function(err, output, apiResponse) {});\n */\nVM.prototype.getSerialPortOutput = function(port, callback) {\n  if (is.fn(port)) {\n    callback = port;\n    port = 1;\n  }\n\n  var reqOpts = {\n    uri: '/serialPort',\n    qs: {\n      port: port\n    }\n  };\n\n  ServiceObject.prototype.request.call(this, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    callback(null, resp.contents, resp);\n  });\n};\n\n/**\n * Get the instance's tags and their fingerprint.\n *\n * This method wraps {module:compute/vm#getMetadata}, returning only the `tags`\n * property.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object[]} callback.tags - Tag objects from this VM.\n * @param {string} callback.fingerprint - The current tag fingerprint.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * vm.getTags(function(err, tags, fingerprint, apiResponse) {});\n */\nVM.prototype.getTags = function(callback) {\n  this.getMetadata(function(err, metadata, apiResponse) {\n    if (err) {\n      callback(err, null, null, apiResponse);\n      return;\n    }\n\n    callback(null, metadata.tags.items, metadata.tags.fingerprint, apiResponse);\n  });\n};\n\n/**\n * Reset the instance.\n *\n * @resource [Instances: reset API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/reset}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * vm.reset(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nVM.prototype.reset = function(callback) {\n  this.request({\n    method: 'POST',\n    uri: '/reset'\n  }, callback || util.noop);\n};\n\n/**\n * Set the metadata for this instance.\n *\n * @resource [Instances: setMetadata API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/setMetadata}\n *\n * @param {object} metadata - New metadata.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * vm.setMetadata({\n *   'startup-script': '...'\n * }, function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nVM.prototype.setMetadata = function(metadata, callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  this.getMetadata(function(err, currentMetadata, apiResponse) {\n    if (err) {\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    var newMetadata = {\n      fingerprint: currentMetadata.metadata.fingerprint,\n      items: []\n    };\n\n    for (var prop in metadata) {\n      if (metadata.hasOwnProperty(prop)) {\n        newMetadata.items.push({\n          key: prop,\n          value: metadata[prop]\n        });\n      }\n    }\n\n    self.request({\n      method: 'POST',\n      uri: '/setMetadata',\n      json: newMetadata\n    }, callback);\n  });\n};\n\n/**\n * Set the instance's tags.\n *\n * @resource [Instances: setTags API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/setTags}\n *\n * @param {string[]} tags - The new tags for the instance.\n * @param {string} fingerprint - The current tags fingerprint. An up-to-date\n *     fingerprint must be provided.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * vm.getTags(function(err, tags, fingerprint) {\n *   tags.push('new-tag');\n *\n *  vm.setTags(tags, fingerprint, function(err, operation, apiResponse) {\n *     // `operation` is an Operation object that can be used to check the\n *     //  status of the request.\n *   });\n * });\n */\nVM.prototype.setTags = function(tags, fingerprint, callback) {\n  var body = {\n    items: tags,\n    fingerprint: fingerprint\n  };\n\n  this.request({\n    method: 'POST',\n    uri: '/setTags',\n    json: body\n  }, callback || util.noop);\n};\n\n/**\n * Start the instance.\n *\n * @resource [Instances: start API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/start}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * vm.start(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nVM.prototype.start = function(callback) {\n  this.request({\n    method: 'POST',\n    uri: '/start'\n  }, callback || util.noop);\n};\n\n/**\n * Stop the instance.\n *\n * @resource [Instances: stop API Documentation]{@link https://cloud.google.com/compute/docs/reference/v1/instances/stop}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:compute/operation} callback.operation - An operation object\n *     that can be used to check the status of the request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * vm.stop(function(err, operation, apiResponse) {\n *   // `operation` is an Operation object that can be used to check the status\n *   // of the request.\n * });\n */\nVM.prototype.stop = function(callback) {\n  this.request({\n    method: 'POST',\n    uri: '/stop'\n  }, callback || util.noop);\n};\n\n/**\n * Make a new request object from the provided arguments and wrap the callback\n * to intercept non-successful responses.\n *\n * Most operations on a VM are long-running. This method handles building an\n * operation and returning it to the user's provided callback. In methods that\n * don't require an operation, we simply don't do anything with the `Operation`\n * object.\n *\n * @private\n *\n * @param {string} method - Action.\n * @param {string} path - Request path.\n * @param {*} query - Request query object.\n * @param {*} body - Request body contents.\n * @param {function} callback - The callback function.\n */\nVM.prototype.request = function(reqOpts, callback) {\n  var zone = this.zone;\n\n  ServiceObject.prototype.request.call(this, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var operation = zone.operation(resp.name);\n    operation.metadata = resp;\n\n    callback(null, operation, resp);\n  });\n};\n\nmodule.exports = VM;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/datastore/index.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module datastore\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar is = require('is');\nvar modelo = require('modelo');\n\n/**\n * @type {module:datastore/request}\n * @private\n */\nvar DatastoreRequest = require('./request.js');\n\n/**\n * @type {module:datastore/entity}\n * @private\n */\nvar entity = require('./entity.js');\n\n/**\n * @type {module:datastore/query}\n * @private\n */\nvar Query = require('./query.js');\n\n/**\n * @type {module:common/grpc-service}\n * @private\n */\nvar GrpcService = require('../common/grpc-service.js');\n\n/**\n * @type {module:datastore/transaction}\n * @private\n */\nvar Transaction = require('./transaction.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * Interact with the\n * [Google Cloud Datastore](https://developers.google.com/datastore/).\n *\n * @constructor\n * @alias module:datastore\n * @mixes module:datastore/request\n *\n * @classdesc\n * The `gcloud.datastore` object allows you to interact with Google Cloud\n * Datastore.\n *\n * To learn more about Datastore, read the\n * [Google Cloud Datastore Concepts Overview](https://cloud.google.com/datastore/docs/concepts/overview)\n *\n * @param {object=} options - [Configuration object](#/docs).\n * @param {string=} options.apiEndpoint - Override the default API endpoint used\n *     to reach Datastore. This is useful for connecting to your local Datastore\n *     server (usually \"http://localhost:8080\").\n * @param {string} options.namespace - Namespace to isolate transactions to.\n *\n * @example\n * var gcloud = require('gcloud')({\n *   projectId: 'grape-spaceship-123',\n *   keyFilename: '/path/to/keyfile.json'\n * });\n *\n * var datastore = gcloud.datastore();\n *\n * //-\n * // <h3>The Datastore Emulator</h3>\n * //\n * // <h4>gcloud SDK not supported</h4>\n * //\n * // As of this release, the Datastore emulator that is part of the gcloud SDK\n * // is not compatible with gcloud-node. We use\n * // <a href=\"http://grpc.io\">gRPC</a> as our transport layer, while the gcloud\n * // SDK's Datastore emulator does not support gRPC.\n * //\n * // <h4>Use `gcd.sh` directly</h4>\n * // For now, you must use the\n * // <a href=\"https://storage.googleapis.com/gcd/tools/gcd-grpc-1.0.0.zip\">\n * // gcd.sh</a> script.\n * //\n * // When you run `./gcd start [datastore]`, you will see the following\n * // printed:\n * //\n * // <pre>\n * //   If you are using a library that supports the DATASTORE_EMULATOR_HOST\n * //   environment variable, run:\n * //     export DATASTORE_EMULATOR_HOST=localhost:8080\n * // </pre>\n * //\n * // Set that environment variable and your localhost Datastore will\n * // automatically be used. You can also pass this address in manually with\n * // `apiEndpoint`.\n * //-\n * var datastore = gcloud.datastore({\n *   apiEndpoint: 'http://localhost:8080'\n * });\n *\n * //-\n * // Additionally, `DATASTORE_PROJECT_ID` is recognized. If you have this set,\n * // you don't need to provide a `projectId`.\n * //-\n *\n * //-\n * // <h3>Retrieving Records</h3>\n * //\n * // Records, called \"entities\" in Datastore, are retrieved by using a key. The\n * // key is more than a numeric identifier, it is a complex data structure that\n * // can be used to model relationships. The simplest key has a string `kind`\n * // value, and either a numeric `id` value, or a string `name` value.\n * //\n * // A single record can be retrieved with {module:datastore/key} and\n * // {module:datastore#get}.\n * //-\n * var key = datastore.key(['Company', 'Google']);\n *\n * datastore.get(key, function(err, entity) {\n *   // entity.data = The record.\n *   // entity.key = The key.\n * });\n *\n * //-\n * // <h3>Querying Records</h3>\n * //\n * // Create a query with {module:datastore#createQuery}.\n * //-\n * var query = datastore.createQuery('Company');\n *\n * //-\n * // Multiple records can be found that match criteria with\n * // {module:datastore/query#filter}.\n * //-\n * query.filter('location', 'CA');\n *\n * //-\n * // Records can also be ordered with {module:datastore/query#order}.\n * //-\n * query.order('name');\n *\n * //-\n * // The number of records returned can be specified with\n * // {module:datastore/query#limit}.\n * //-\n * query.limit(5);\n *\n * //-\n * // Records' key structures can also be queried with\n * // {module:datastore/query#hasAncestor}.\n * //-\n * var ancestorKey = datastore.key(['ParentCompany', 'Alphabet']);\n *\n * query.hasAncestor(ancestorKey);\n *\n * //-\n * // Run the query with {module:datastore#runQuery}.\n * //-\n * datastore.runQuery(query, function(err, entities) {\n *   // entities = [\n *   //   {\n *   //     data: The record,\n *   //     key: The key for this record\n *   //   },\n *   //   ...\n *   // ]\n * });\n *\n * //-\n * // <h3>Paginating Records</h3>\n * //\n * // Imagine building a website that allows a user to sift through hundreds of\n * // their contacts. You'll likely want to only display a subset of these at\n * // once, so you set a limit.\n * //-\n * var express = require('express');\n * var app = express();\n *\n * var NUM_RESULTS_PER_PAGE = 15;\n *\n * app.get('/contacts', function(req, res) {\n *   var query = datastore.createQuery('Contacts')\n *     .limit(NUM_RESULTS_PER_PAGE);\n *\n *   if (req.query.nextPageCursor) {\n *     query.start(req.query.nextPageCursor);\n *   }\n *\n *   datastore.runQuery(query, function(err, entities, info) {\n *     if (err) {\n *       // Error handling omitted.\n *       return;\n *     }\n *\n *     // Respond to the front end with the contacts and the cursoring token\n *     // from the query we just ran.\n *     var frontEndResponse = {\n *       contacts: entities\n *     };\n *\n *     // Check if  more results may exist.\n *     if (info.moreResults !== gcloud.datastore.NO_MORE_RESULTS) {\n *       frontEndResponse.nextPageCursor = info.endCursor;\n *     }\n *\n *     res.render('contacts', frontEndResponse);\n *   });\n * });\n *\n * //-\n * // <h3>Creating Records</h3>\n * //\n * // New entities can be created and persisted with {module:datastore#save}.\n * // The entitiy must have a key to be saved. If you don't specify an\n * // identifier for the key, one is generated for you.\n * //\n * // We will create a key with a `name` identifier, \"Google\".\n * //-\n * var key = datastore.key(['Company', 'Google']);\n *\n * var data = {\n *   name: 'Google',\n *   location: 'CA'\n * };\n *\n * datastore.save({\n *   key: key,\n *   data: data\n * }, function(err) {\n *   if (!err) {\n *     // Record saved successfully.\n *   }\n * });\n *\n * //-\n * // We can verify the data was saved by using {module:datastore#get}.\n * //-\n * datastore.get(key, function(err, entity) {\n *   // entity = {\n *   //   key: datastore.key(['Company', 'Google']),\n *   //   data: {\n *   //     name: 'Google',\n *   //     location: 'CA'\n *   //   }\n *   // }\n * });\n *\n * //-\n * // If we want to update this record, we can modify the data object and re-\n * // save it.\n * //-\n * data.symbol = 'GOOG';\n *\n * datastore.save({\n *   key: key, // defined above (datastore.key(['Company', 'Google']))\n *   data: data\n * }, function(err, entity) {\n *   if (!err) {\n *     // Record updated successfully.\n *   }\n * });\n *\n * //-\n * // <h3>Deleting Records</h3>\n * //\n * // Entities can be removed from Datastore by passing the entity's key object\n * // to {module:datastore#delete}.\n * //-\n * var key = datastore.key(['Company', 'Google']);\n *\n * datastore.delete(key, function(err) {\n *   if (!err) {\n *     // Record deleted successfully.\n *   }\n * });\n *\n * //-\n * // <h3>Transactions</h3>\n * //\n * // Complex logic can be wrapped in a transaction with\n * // {module:datastore#transaction}. All queries and updates run within\n * // the transaction will be applied when the `done` function is called.\n * //-\n * var transaction = datastore.transaction();\n *\n * transaction.run(function(err) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   var key = datastore.key(['Company', 'Google']);\n *\n *   transaction.get(key, function(err, data) {\n *     if (err) {\n *       // Error handling omitted.\n *     }\n *\n *     data.symbol = 'GOOG';\n *\n *     transaction.save({\n *       key: key,\n *       data: data\n *     });\n *\n *     transaction.commit(function(err) {\n *       if (!err) {\n *         // Transaction committed successfully.\n *       }\n *     });\n *   });\n * });\n */\nfunction Datastore(options) {\n  if (!(this instanceof Datastore)) {\n    options = util.normalizeArguments(this, options, {\n      projectIdRequired: false\n    });\n    return new Datastore(options);\n  }\n\n  this.defaultBaseUrl_ = 'datastore.googleapis.com';\n  this.determineBaseUrl_(options.apiEndpoint);\n\n  this.namespace = options.namespace;\n  this.projectId = process.env.DATASTORE_PROJECT_ID || options.projectId;\n\n  var config = {\n    projectIdRequired: false,\n    baseUrl: this.baseUrl_,\n    customEndpoint: this.customEndpoint_,\n    service: 'datastore',\n    apiVersion: 'v1beta3',\n    scopes: ['https://www.googleapis.com/auth/datastore']\n  };\n\n  GrpcService.call(this, config, options);\n}\n\nmodelo.inherits(Datastore, DatastoreRequest, GrpcService);\n\n/**\n * Helper function to get a Datastore Double object.\n *\n * @param {number} value - The double value.\n * @return {object}\n *\n * @example\n * var threeDouble = gcloud.datastore.double(3.0);\n */\nDatastore.double = function(value) {\n  return new entity.Double(value);\n};\n\n/**\n * Helper function to get a Datastore Geo Point object.\n *\n * @param {object} coordinates - Coordinate value.\n * @param {number} coordinates.latitude - Latitudinal value.\n * @param {number} coordinates.longitude - Longitudinal value.\n * @return {object}\n *\n * @example\n * var coordinates = {\n *   latitude: 40.6894,\n *   longitude: -74.0447\n * };\n *\n * var geoPoint = gcloud.datastore.geoPoint(coordinates);\n */\nDatastore.geoPoint = function(coordindates) {\n  return new entity.GeoPoint(coordindates);\n};\n\n/**\n * Helper function to get a Datastore Integer object.\n *\n * @param {number} value - The integer value.\n * @return {object}\n *\n * @example\n * var sevenInteger = gcloud.datastore.int(7);\n */\nDatastore.int = function(value) {\n  return new entity.Int(value);\n};\n\n/**\n * This is one of three values which may be returned from\n * {module:datastore#runQuery}, {module:transaction#runQuery}, and\n * {module:datastore/query#run} as `info.moreResults`.\n *\n * There *may* be more results after the specified end cursor.\n *\n * @type {string}\n */\nDatastore.MORE_RESULTS_AFTER_CURSOR = 'MORE_RESULTS_AFTER_CURSOR';\n\n/**\n * This is one of three values which may be returned from\n * {module:datastore#runQuery}, {module:transaction#runQuery}, and\n * {module:datastore/query#run} as `info.moreResults`.\n *\n * There *may* be more results after the specified limit.\n *\n * @type {string}\n */\nDatastore.MORE_RESULTS_AFTER_LIMIT = 'MORE_RESULTS_AFTER_LIMIT';\n\n/**\n * This is one of three values which may be returned from\n * {module:datastore#runQuery}, {module:transaction#runQuery}, and\n * {module:datastore/query#run} as `info.moreResults`.\n *\n * There are no more results left to query for.\n *\n * @type {string}\n */\nDatastore.NO_MORE_RESULTS = 'NO_MORE_RESULTS';\n\n/**\n * Create a query for the specified kind. See {module:datastore/query} for all\n * of the available methods.\n *\n * @resource [Datastore Queries]{@link https://cloud.google.com/datastore/docs/concepts/queries}\n *\n * @see {module:datastore/query}\n *\n * @param {string=} namespace - Namespace.\n * @param {string} kind - The kind to query.\n * @return {module:datastore/query}\n *\n * @example\n * var query = datastore.createQuery('Company');\n */\nDatastore.prototype.createQuery = function(namespace, kind) {\n  if (arguments.length === 1) {\n    kind = arrify(namespace);\n    namespace = this.namespace;\n  }\n\n  return new Query(this, namespace, arrify(kind));\n};\n\n/**\n * Helper to create a Key object, scoped to the instance's namespace by default.\n *\n * You may also specify a configuration object to define a namespace and path.\n *\n * @param {...*=} options - Key path. To specify or override a namespace,\n *     you must use an object here to explicitly state it.\n * @param {object=} options - Configuration object.\n * @param {...*=} options.path - Key path.\n * @param {string=} options.namespace - Optional namespace.\n * @return {Key} A newly created Key from the options given.\n *\n * @example\n * //-\n * // Create an incomplete key with a kind value of `Company`.\n * //-\n * var key = datastore.key('Company');\n *\n * //-\n * // Create a complete key with a kind value of `Company` and id `123`.\n * //-\n * var key = datastore.key(['Company', 123]);\n *\n * //-\n * // Create a complete key with a kind value of `Company` and name `Google`.\n * // Note: `id` is used for numeric identifiers and `name` is used otherwise.\n * //-\n * var key = datastore.key(['Company', 'Google']);\n *\n * //-\n * // Create a complete key from a provided namespace and path.\n * //-\n * var key = datastore.key({\n *   namespace: 'My-NS',\n *   path: ['Company', 123]\n * });\n */\nDatastore.prototype.key = function(options) {\n  options = is.object(options) ? options : {\n    namespace: this.namespace,\n    path: arrify(options)\n  };\n\n  return new entity.Key(options);\n};\n\n/**\n * Create a new Transaction object.\n *\n * @return {module:datastore/transaction}\n * @private\n */\nDatastore.prototype.transaction = function() {\n  return new Transaction(this);\n};\n\n/**\n * Determine the appropriate endpoint to use for API requests. If not explicitly\n * defined, check for the \"DATASTORE_EMULATOR_HOST\" environment variable, used\n * to connect to a local Datastore server.\n *\n * @private\n *\n * @param {string} customApiEndpoint - Custom API endpoint.\n */\nDatastore.prototype.determineBaseUrl_ = function(customApiEndpoint) {\n  var baseUrl = this.defaultBaseUrl_;\n  var leadingProtocol = new RegExp('^https*://');\n  var trailingSlashes = new RegExp('/*$');\n\n  if (customApiEndpoint) {\n    baseUrl = customApiEndpoint;\n    this.customEndpoint_ = true;\n  } else if (process.env.DATASTORE_EMULATOR_HOST) {\n    baseUrl = process.env.DATASTORE_EMULATOR_HOST;\n    this.customEndpoint_ = true;\n  }\n\n  this.baseUrl_ = baseUrl\n    .replace(leadingProtocol, '')\n    .replace(trailingSlashes, '');\n};\n\nmodule.exports = Datastore;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/datastore/request.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module datastore/request\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar concat = require('concat-stream');\nvar extend = require('extend');\nvar is = require('is');\nvar propAssign = require('prop-assign');\nvar split = require('split-array-stream');\n\n/**\n * @type {module:datastore/entity}\n * @private\n */\nvar entity = require('./entity.js');\n\n/**\n * @type {module:datastore/query}\n * @private\n */\nvar Query = require('./query.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * A map of read consistency values to proto codes.\n *\n * @type {object}\n * @private\n */\nvar CONSISTENCY_PROTO_CODE = {\n  eventual: 2,\n  strong: 1\n};\n\n/*! Developer Documentation\n *\n * Handles request logic for Datastore.\n *\n * Creates requests to the Datastore endpoint. Designed to be inherited by\n * {module:datastore} and {module:datastore/transaction} objects.\n *\n * @example\n * // This is how to create a transaction object directly using this Transaction\n * // class. The following transaction object is created for use in the examples\n * // in this file below.\n * var datastore = gcloud.datastore({ projectId: 'project-id' });\n * var Transaction = require('gcloud/lib/datastore/transaction');\n * var transaction = new Transaction(datastore, 'my-project-id');\n * transaction.id = '1234'; // Give the transaction an ID.\n */\n/**\n * Handle logic for Datastore API operations.\n *\n * @constructor\n * @alias module:datastore/request\n * @mixin\n */\nfunction DatastoreRequest() {}\n\n/**\n * Generate IDs without creating entities.\n *\n * @param {Key} incompleteKey - The key object to complete.\n * @param {number} n - How many IDs to generate.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {array} callback.keys - The generated IDs\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var incompleteKey = datastore.key(['Company']);\n *\n * //-\n * // The following call will create 100 new IDs from the Company kind, which\n * // exists under the default namespace.\n * //-\n * datastore.allocateIds(incompleteKey, 100, function(err, keys) {});\n *\n * //-\n * // Or, if you're using a transaction object.\n * //-\n * var transaction = datastore.transaction();\n *\n * transaction.run(function(err) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   transaction.allocateIds(incompleteKey, 100, function(err, keys) {\n *     if (err) {\n *       // Error handling omitted.\n *     }\n *\n *     transaction.commit(function(err) {\n *       if (!err) {\n *         // Transaction committed successfully.\n *       }\n *     });\n *   });\n * });\n *\n * //-\n * // You may prefer to create IDs from a non-default namespace by providing an\n * // incomplete key with a namespace. Similar to the previous example, the call\n * // below will create 100 new IDs, but from the Company kind that exists under\n * // the \"ns-test\" namespace.\n * //-\n * var incompleteKey = datastore.key({\n *   namespace: 'ns-test',\n *   path: ['Company']\n * });\n *\n * function callback(err, keys, apiResponse) {}\n *\n * datastore.allocateIds(incompleteKey, 100, callback);\n */\nDatastoreRequest.prototype.allocateIds = function(incompleteKey, n, callback) {\n  if (entity.isKeyComplete(incompleteKey)) {\n    throw new Error('An incomplete key should be provided.');\n  }\n\n  var incompleteKeys = [];\n  for (var i = 0; i < n; i++) {\n    incompleteKeys.push(entity.keyToKeyProto(incompleteKey));\n  }\n\n  var protoOpts = {\n    service: 'Datastore',\n    method: 'allocateIds'\n  };\n\n  var reqOpts = {\n    keys: incompleteKeys\n  };\n\n  this.request_(protoOpts, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var keys = (resp.keys || []).map(entity.keyFromKeyProto);\n\n    callback(null, keys, resp);\n  });\n};\n\n/**\n * Delete all entities identified with the specified key(s).\n *\n * @param {Key|Key[]} key - Datastore key object(s).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var key = datastore.key(['Company', 123]);\n * datastore.delete(key, function(err, apiResp) {});\n *\n * //-\n * // Or, if you're using a transaction object.\n * //-\n * var transaction = datastore.transaction();\n *\n * transaction.run(function(err) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   transaction.delete(key);\n *\n *   transaction.commit(function(err) {\n *     if (!err) {\n *       // Transaction committed successfully.\n *     }\n *   });\n * });\n *\n * //-\n * // Delete multiple entities at once.\n * //-\n * datastore.delete([\n *   datastore.key(['Company', 123]),\n *   datastore.key(['Product', 'Computer'])\n * ], function(err, apiResponse) {});\n */\nDatastoreRequest.prototype.delete = function(keys, callback) {\n  callback = callback || util.noop;\n\n  var protoOpts = {\n    service: 'Datastore',\n    method: 'commit'\n  };\n\n  var reqOpts = {\n    mutations: arrify(keys).map(function(key) {\n      return {\n        delete: entity.keyToKeyProto(key)\n      };\n    })\n  };\n\n  if (this.id) {\n    this.requests_.push(reqOpts);\n    return;\n  }\n\n  this.request_(protoOpts, reqOpts, callback);\n};\n\n/**\n * Retrieve the entities identified with the specified key(s) in the current\n * transaction. Get operations require a valid key to retrieve the\n * key-identified entity from Datastore.\n *\n * @throws {Error} If at least one Key object is not provided.\n *\n * @param {Key|Key[]} keys - Datastore key object(s).\n * @param {object=} options - Optional configuration.\n * @param {string} options.consistency - Specify either `strong` or `eventual`.\n *     If not specified, default values are chosen by Datastore for the\n *     operation. Learn more about strong and eventual consistency\n *     [here](https://cloud.google.com/datastore/docs/articles/balancing-strong-and-eventual-consistency-with-google-cloud-datastore).\n * @param {boolean} options.maxApiCalls - Maximum API calls to make.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object|object[]} callback.entity - The entity object(s) which match\n *     the provided keys.\n *\n * @example\n * //-\n * // Get a single entity.\n * //-\n * var key = datastore.key(['Company', 123]);\n *\n * datastore.get(key, function(err, entity) {});\n *\n * //-\n * // Or, if you're using a transaction object.\n * //-\n * var transaction = datastore.transaction();\n *\n * transaction.run(function(err) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   transaction.get(key, function(err, entity) {\n *     if (err) {\n *       // Error handling omitted.\n *     }\n *\n *     transaction.commit(function(err) {\n *       if (!err) {\n *         // Transaction committed successfully.\n *       }\n *     });\n *   });\n * });\n *\n * //-\n * // Get multiple entities at once with a callback.\n * //-\n * var keys = [\n *   datastore.key(['Company', 123]),\n *   datastore.key(['Product', 'Computer'])\n * ];\n *\n * datastore.get(keys, function(err, entities) {});\n *\n * //-\n * // Or, get the entities as a readable object stream.\n * //-\n * datastore.get(keys)\n *   .on('error', function(err) {})\n *   .on('data', function(entity) {\n *     // entity is an entity object.\n *   })\n *   .on('end', function() {\n *     // All entities retrieved.\n *   });\n *\n * //-\n * // Here's how you would update the value of an entity with the help of the\n * // `save` method.\n * //-\n * datastore.get(key, function(err, entity) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   entity.data.newValue = true;\n *   datastore.save(entity, function(err) {});\n * });\n */\nDatastoreRequest.prototype.get = function(keys, options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  if (is.fn(callback)) {\n    // Run this method in stream mode and send the results back to the callback.\n    this.get(keys, options)\n      .on('error', callback)\n      .pipe(concat(function(results) {\n        var isSingleLookup = !is.array(keys);\n        callback(null, isSingleLookup ? results[0] : results);\n      }));\n    return;\n  }\n\n  keys = arrify(keys).map(entity.keyToKeyProto);\n\n  if (keys.length === 0) {\n    throw new Error('At least one Key object is required.');\n  }\n\n  var limiter = util.createLimiter(makeRequest, options);\n  var stream = limiter.stream;\n\n  stream.once('reading', function() {\n    limiter.makeRequest(keys);\n  });\n\n  function makeRequest(keys) {\n    var protoOpts = {\n      service: 'Datastore',\n      method: 'lookup'\n    };\n\n    var reqOpts = {\n      keys: keys\n    };\n\n    if (options.consistency) {\n      var code = CONSISTENCY_PROTO_CODE[options.consistency.toLowerCase()];\n\n      reqOpts.readOptions = {\n        readConsistency: code\n      };\n    }\n\n    self.request_(protoOpts, reqOpts, function(err, resp) {\n      if (err) {\n        stream.destroy(err);\n        return;\n      }\n\n      var entities = entity.formatArray(resp.found);\n      var nextKeys = (resp.deferred || []).map(entity.keyFromKeyProto);\n\n      split(entities, stream, function(streamEnded) {\n        if (streamEnded) {\n          return;\n        }\n\n        if (nextKeys.length > 0) {\n          limiter.makeRequest(nextKeys);\n          return;\n        }\n\n        stream.push(null);\n      });\n    });\n  }\n\n  return stream;\n};\n\n/**\n * Maps to {module:datastore#save}, forcing the method to be `insert`.\n */\nDatastoreRequest.prototype.insert = function(entities, callback) {\n  entities = arrify(entities).map(propAssign('method', 'insert'));\n  this.save(entities, callback);\n};\n\n/**\n * Datastore allows you to query entities by kind, filter them by property\n * filters, and sort them by a property name. Projection and pagination are also\n * supported.\n *\n * If you provide a callback, the query is run, and the results are returned as\n * the second argument to your callback. A third argument may also exist, which\n * is a query object that uses the end cursor from the previous query as the\n * starting cursor for the next query. You can pass that object back to this\n * method to see if more results exist.\n *\n * You may also omit the callback to this function to trigger streaming mode.\n *\n * See below for examples of both approaches.\n *\n * @param {module:datastore/query} q - Query object.\n * @param {object=} options - Optional configuration.\n * @param {string} options.consistency - Specify either `strong` or `eventual`.\n *     If not specified, default values are chosen by Datastore for the\n *     operation. Learn more about strong and eventual consistency\n *     [here](https://cloud.google.com/datastore/docs/articles/balancing-strong-and-eventual-consistency-with-google-cloud-datastore).\n * @param {boolean} options.maxApiCalls - Maximum API calls to make.\n * @param {function=} callback - The callback function. If omitted, a readable\n *     stream instance is returned.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object[]} callback.entities - A list of entities.\n * @param {object} callback.info - An object useful for pagination.\n * @param {?string} callback.info.endCursor - Use this in a follow-up query to\n *     begin from where these results ended.\n * @param {string} callback.info.moreResults - Datastore responds with one of:\n *\n *     - {module:datastore#MORE_RESULTS_AFTER_LIMIT}: There *may* be more\n *       results after the specified limit.\n *     - {module:datastore#MORE_RESULTS_AFTER_CURSOR}: There *may* be more\n *       results after the specified end cursor.\n *     - {module:datastore#NO_MORE_RESULTS}: There are no more results.\n *\n * @example\n * //-\n * // Where you see `transaction`, assume this is the context that's relevant to\n * // your use, whether that be a Datastore or a Transaction object.\n * //-\n * var query = datastore.createQuery('Lion');\n *\n * datastore.runQuery(query, function(err, entities, info) {});\n *\n * //-\n * // Or, if you're using a transaction object.\n * //-\n * var transaction = datastore.transaction();\n *\n * transaction.run(function(err) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   transaction.runQuery(query, function(err, entities) {\n *     if (err) {\n *       // Error handling omitted.\n *     }\n *\n *     transaction.commit(function(err) {\n *       if (!err) {\n *         // Transaction committed successfully.\n *       }\n *     });\n *   });\n * });\n *\n * //-\n * // If you omit the callback, you will get the matching entities in a readable\n * // object stream.\n * //-\n * datastore.runQuery(query)\n *   .on('error', console.error)\n *   .on('data', function (entity) {})\n *   .on('info', function(info) {})\n *   .on('end', function() {\n *     // All entities retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * datastore.runQuery(query)\n *   .on('data', function (entity) {\n *     this.end();\n *   });\n *\n * //-\n * // A keys-only query returns just the keys of the result entities instead of\n * // the entities themselves, at lower latency and cost.\n * //-\n * var keysOnlyQuery = datastore.createQuery('Lion').select('__key__');\n *\n * datastore.runQuery(keysOnlyQuery, function(err, entities) {\n *   // entities[].key = Key object\n *   // entities[].data = Empty object\n * });\n */\nDatastoreRequest.prototype.runQuery = function(query, options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  var info;\n\n  if (is.fn(callback)) {\n    // Run this method in stream mode and send the results back to the callback.\n    this.runQuery(query, options)\n      .on('error', callback)\n      .on('info', function(info_) {\n        info = info_;\n      })\n      .pipe(concat(function(results) {\n        callback(null, results, info);\n      }));\n    return;\n  }\n\n  var limiter = util.createLimiter(makeRequest, options);\n  var stream = limiter.stream;\n\n  stream.once('reading', function() {\n    limiter.makeRequest(query);\n  });\n\n  function makeRequest(query) {\n    var protoOpts = {\n      service: 'Datastore',\n      method: 'runQuery'\n    };\n\n    var reqOpts = {\n      query: entity.queryToQueryProto(query)\n    };\n\n    if (options.consistency) {\n      var code = CONSISTENCY_PROTO_CODE[options.consistency.toLowerCase()];\n      reqOpts.readOptions = {\n        readConsistency: code\n      };\n    }\n\n    if (query.namespace) {\n      reqOpts.partitionId = {\n        namespaceId: query.namespace\n      };\n    }\n\n    self.request_(protoOpts, reqOpts, onResultSet);\n  }\n\n  function onResultSet(err, resp) {\n    if (err) {\n      stream.destroy(err);\n      return;\n    }\n\n    var info = {\n      moreResults: resp.batch.moreResults\n    };\n\n    if (resp.batch.endCursor) {\n      info.endCursor = resp.batch.endCursor;\n    }\n\n    var entities = [];\n\n    if (resp.batch.entityResults) {\n      entities = entity.formatArray(resp.batch.entityResults);\n    }\n\n    // Emit each result right away, then get the rest if necessary.\n    split(entities, stream, function(streamEnded) {\n      if (streamEnded) {\n        return;\n      }\n\n      if (resp.batch.moreResults !== 'NOT_FINISHED') {\n        stream.emit('info', info);\n        stream.push(null);\n        return;\n      }\n\n      // The query is \"NOT_FINISHED\". Get the rest of the results.\n      var offset = query.offsetVal === -1 ? 0 : query.offsetVal;\n\n      var continuationQuery = extend(true, new Query(), query)\n        .start(info.endCursor)\n        .offset(offset - resp.batch.skippedResults);\n\n      var limit = query.limitVal;\n      if (limit && limit > -1) {\n        continuationQuery.limit(limit - resp.batch.entityResults.length);\n      }\n\n      limiter.makeRequest(continuationQuery);\n    });\n  }\n\n  return stream;\n};\n\n/**\n * Insert or update the specified object(s). If a key is incomplete, its\n * associated object is inserted and the original Key object is updated to\n * contain the generated ID.\n *\n * This method will determine the correct Datastore method to execute (`upsert`,\n * `insert`, or `update`) by using the key(s) provided. For example, if you\n * provide an incomplete key (one without an ID), the request will create a new\n * entity and have its ID automatically assigned. If you provide a complete key,\n * the entity will be updated with the data specified.\n *\n * By default, all properties are indexed. To prevent a property from being\n * included in *all* indexes, you must supply an entity's `data` property as an\n * array. See below for an example.\n *\n * @borrows {module:datastore/transaction#save} as save\n *\n * @throws {Error} If an unrecognized method is provided.\n *\n * @param {object|object[]} entities - Datastore key object(s).\n * @param {Key} entities.key - Datastore key object.\n * @param {string=} entities.method - Explicit method to use, either 'insert',\n *     'update', or 'upsert'.\n * @param {object|object[]} entities.data - Data to save with the provided key.\n *     If you provide an array of objects, you must use the explicit syntax:\n *     `name` for the name of the property and `value` for its value. You may\n *     also specify an `excludeFromIndexes` property, set to `true` or `false`.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // Save a single entity.\n * //\n * // Notice that we are providing an incomplete key. After saving, the original\n * // Key object used to save will be updated to contain the path with its\n * // generated ID.\n * //-\n * var key = datastore.key('Company');\n *\n * datastore.save({\n *   key: key,\n *   data: {\n *     rating: '10'\n *   }\n * }, function(err) {\n *   console.log(key.path); // [ 'Company', 5669468231434240 ]\n *   console.log(key.namespace); // undefined\n * });\n *\n * //-\n * // Save a single entity using a provided name instead of auto-generated ID.\n * //\n * // Here we are providing a key with name instead of an ID. After saving, the\n * // original Key object used to save will be updated to contain the path with\n * // the name instead of a generated ID.\n * //-\n * var key = datastore.key(['Company', 'donutshack']);\n *\n * datastore.save({\n *   key: key,\n *   data: {\n *     name: 'DonutShack',\n *     rating: 8\n *   }\n * }, function(err) {\n *   console.log(key.path); // ['Company', 'donutshack']\n *   console.log(key.namespace); // undefined\n * });\n *\n * //-\n * // Save a single entity with a provided namespace. Namespaces allow for\n * // multitenancy. To read more about this, see\n * // [the Datastore docs on key concepts](https://goo.gl/M1LUAu).\n * //\n * // Here we are providing a key with namespace.\n * //-\n * var key = datastore.key({\n *   namespace: 'my-namespace',\n *   path: ['Company', 'donutshack']\n * });\n *\n * datastore.save({\n *   key: key,\n *   data: {\n *     name: 'DonutShack',\n *     rating: 8\n *   }\n * }, function(err) {\n *   console.log(key.path); // ['Company', 'donutshack']\n *   console.log(key.namespace); // 'my-namespace'\n * });\n *\n * //-\n * // Save different types of data, including ints, doubles, dates, booleans,\n * // blobs, and lists.\n * //\n * // Notice that we are providing an incomplete key. After saving, the original\n * // Key object used to save will be updated to contain the path with its\n * // generated ID.\n * //-\n * var key = datastore.key('Company');\n *\n * datastore.save({\n *   key: key,\n *   data: {\n *     name: 'DonutShack',\n *     rating: gcloud.datastore.int(10),\n *     worth: gcloud.datastore.double(123456.78),\n *     location: gcloud.datastore.geoPoint({\n *       latitude: 40.6894,\n *       longitude: -74.0447\n *     }),\n *     numDonutsServed: 45,\n *     founded: new Date('Tue May 12 2015 15:30:00 GMT-0400 (EDT)'),\n *     isStartup: true,\n *     donutEmoji: new Buffer('\\uD83C\\uDF69'),\n *     keywords: [\n *       'donut',\n *       'coffee',\n *       'yum'\n *     ]\n *   }\n * }, function(err, apiResponse) {});\n *\n * //-\n * // To specify an `excludeFromIndexes` value for a Datastore entity, pass in\n * // an array for the key's data.\n * //-\n * datastore.save({\n *   key: datastore.key('Company'),\n *   data: [\n *     {\n *       name: 'rating',\n *       value: 10,\n *       excludeFromIndexes: true\n *     }\n *   ]\n * }, function(err, apiResponse) {});\n *\n * //-\n * // Save multiple entities at once.\n * //-\n * var companyKey = datastore.key(['Company', 123]);\n * var productKey = datastore.key(['Product', 'Computer']);\n *\n * datastore.save([\n *   {\n *     key: companyKey,\n *     data: {\n *       HQ: 'Dallas, TX'\n *     }\n *   },\n *   {\n *     key: productKey,\n *     data: {\n *       vendor: 'Dell'\n *     }\n *   }\n * ], function(err, apiResponse) {});\n *\n * //-\n * // Explicitly attempt to 'insert' a specific entity.\n * //-\n * var userKey = datastore.key(['User', 'chilts']);\n *\n * datastore.save({\n *   key: userKey,\n *   method: 'insert',\n *   data: {\n *     fullName: 'Andrew Chilton'\n *   }\n * }, function(err, apiResponse) {});\n */\nDatastoreRequest.prototype.save = function(entities, callback) {\n  entities = arrify(entities);\n\n  var insertIndexes = {};\n  var mutations = [];\n  var methods = {\n    insert: true,\n    update: true,\n    upsert: true\n  };\n\n  // Iterate over the entity objects, build a proto from all keys and values,\n  // then place in the correct mutation array (insert, update, etc).\n  entities.forEach(function(entityObject, index) {\n    entityObject = extend(true, {}, entityObject);\n\n    var mutation = {};\n    var entityProto = {};\n    var method = 'upsert';\n\n    if (entityObject.method) {\n      if (methods[entityObject.method]) {\n        method = entityObject.method;\n      } else {\n        throw new Error('Method ' + entityObject.method + ' not recognized.');\n      }\n    }\n\n    if (!entity.isKeyComplete(entityObject.key)) {\n      insertIndexes[index] = true;\n    }\n\n    if (is.array(entityObject.data)) {\n      entityProto.properties = entityObject.data.reduce(function(acc, data) {\n        var value = entity.encodeValue(data.value);\n\n        if (is.boolean(data.excludeFromIndexes)) {\n          var excluded = data.excludeFromIndexes;\n          var values = value.arrayValue && value.arrayValue.values;\n\n          if (values) {\n            values = values.map(propAssign('excludeFromIndexes', excluded));\n          } else {\n            value.excludeFromIndexes = data.excludeFromIndexes;\n          }\n        }\n\n        acc[data.name] = value;\n\n        return acc;\n      }, {});\n    } else {\n      entityProto = entity.entityToEntityProto(entityObject.data);\n    }\n\n    entityProto.key = entity.keyToKeyProto(entityObject.key);\n\n    mutation[method] = entityProto;\n    mutations.push(mutation);\n  });\n\n  var protoOpts = {\n    service: 'Datastore',\n    method: 'commit'\n  };\n\n  var reqOpts = {\n    mutations: mutations\n  };\n\n  function onCommit(err, resp) {\n    if (err || !resp) {\n      callback(err, resp);\n      return;\n    }\n\n    arrify(resp.mutationResults).forEach(function(result, index) {\n      if (!result.key) {\n        return;\n      }\n\n      if (insertIndexes[index]) {\n        var id = entity.keyFromKeyProto(result.key).id;\n        entities[index].key.id = id;\n      }\n    });\n\n    callback(null, resp);\n  }\n\n  if (this.id) {\n    this.requests_.push(reqOpts);\n    this.requestCallbacks_.push(onCommit);\n    return;\n  }\n\n  this.request_(protoOpts, reqOpts, onCommit);\n};\n\n/**\n * Maps to {module:datastore#save}, forcing the method to be `update`.\n */\nDatastoreRequest.prototype.update = function(entities, callback) {\n  entities = arrify(entities).map(propAssign('method', 'update'));\n  this.save(entities, callback);\n};\n\n/**\n * Maps to {module:datastore#save}, forcing the method to be `upsert`.\n */\nDatastoreRequest.prototype.upsert = function(entities, callback) {\n  entities = arrify(entities).map(propAssign('method', 'upsert'));\n  this.save(entities, callback);\n};\n\n/**\n * Make a request to the API endpoint. Properties to indicate a transactional or\n * non-transactional operation are added automatically.\n *\n * @param {string} method - Datastore action (allocateIds, commit, etc.).\n * @param {object=} body - Request configuration object.\n * @param {function} callback - The callback function.\n *\n * @private\n */\nDatastoreRequest.prototype.request_ = function(protoOpts, reqOpts, callback) {\n  if (!callback) {\n    callback = reqOpts;\n    reqOpts = {};\n  }\n\n  callback = callback || util.noop;\n\n  var isTransaction = is.defined(this.id);\n  var method = protoOpts.method;\n\n  reqOpts.projectId = this.projectId;\n\n  // Set properties to indicate if we're in a transaction or not.\n  if (method === 'commit') {\n    if (isTransaction) {\n      reqOpts.mode = 'TRANSACTIONAL';\n      reqOpts.transaction = this.id;\n    } else {\n      reqOpts.mode = 'NON_TRANSACTIONAL';\n    }\n  }\n\n  if (method === 'rollback') {\n    reqOpts.transaction = this.id;\n  }\n\n  if (isTransaction && (method === 'lookup' || method === 'runQuery')) {\n    if (reqOpts.readOptions && reqOpts.readOptions.readConsistency) {\n      throw new Error('Read consistency cannot be specified in a transaction.');\n    }\n\n    reqOpts.readOptions = {\n      transaction: this.id\n    };\n  }\n\n  this.request(protoOpts, reqOpts, callback);\n};\n\nmodule.exports = DatastoreRequest;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/datastore/entity.js":"/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @private\n * @module datastore/entity\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar createErrorClass = require('create-error-class');\nvar is = require('is');\n\nvar entity = module.exports;\n\nvar InvalidKeyError = createErrorClass('InvalidKey', function(opts) {\n  var errorMessages = {\n    MISSING_KIND: 'A key should contain at least a kind.',\n    MISSING_ANCESTOR_ID: 'Ancestor keys require an id or name.'\n  };\n\n  this.message = errorMessages[opts.code];\n});\n\n/**\n * Build a Datastore Double object.\n *\n * @constructor\n * @param {number} value - The double value.\n *\n * @example\n * var aDouble = new Double(7.3);\n */\nfunction Double(value) {\n  this.value = value;\n}\n\nentity.Double = Double;\n\n/**\n * Build a Datastore Int object.\n *\n * @constructor\n * @param {number} value - The integer value.\n *\n * @example\n * var anInt = new Int(7);\n */\nfunction Int(value) {\n  this.value = value;\n}\n\nentity.Int = Int;\n\n/**\n * Build a Datastore Geo Point object.\n *\n * @constructor\n * @param {object} coordinates - Coordinate value.\n * @param {number} coordinates.latitude - Latitudinal value.\n * @param {number} coordinates.longitude - Longitudinal value.\n *\n * @example\n * var coordinates = {\n *   latitude: 40.6894,\n *   longitude: -74.0447\n * };\n *\n * var geoPoint = new GeoPoint(coordinates);\n */\nfunction GeoPoint(coordindates) {\n  this.value = coordindates;\n}\n\nentity.GeoPoint = GeoPoint;\n\n/**\n * Build a Datastore Key object.\n *\n * @constructor\n * @param {object} - Configuration object.\n * @param {...*} options.path - Key path.\n * @param {string=} options.namespace - Optional namespace.\n *\n * @example\n * var key = new Key({\n *   namespace: 'ns',\n *   path: ['Company', 123]\n * });\n */\nfunction Key(options) {\n  this.namespace = options.namespace;\n\n  if (options.path.length % 2 === 0) {\n    var identifier = options.path.pop();\n\n    if (is.number(identifier)) {\n      this.id = identifier;\n    } else if (is.string(identifier)) {\n      this.name = identifier;\n    }\n  }\n\n  this.kind = options.path.pop();\n\n  if (options.path.length > 0) {\n    this.parent = new Key(options);\n  }\n\n  // `path` is computed on demand to consider any changes that may have been\n  // made to the key.\n  Object.defineProperty(this, 'path', {\n    enumerable: true,\n    get: function() {\n      return arrify(this.parent && this.parent.path)\n        .concat([this.kind, this.name || this.id]);\n    }\n  });\n}\n\nentity.Key = Key;\n\n/**\n * Convert a protobuf Value message to its native value.\n *\n * @param {object} valueProto - The protobuf Value message to convert.\n * @return {*}\n *\n * @example\n * decodeValueProto({\n *   booleanValue: false\n * });\n * // false\n *\n * decodeValueProto({\n *   stringValue: 'Hi'\n * });\n * // 'Hi'\n *\n * decodeValueProto({\n *   blobValue: new Buffer('68656c6c6f')\n * });\n * // <Buffer 68 65 6c 6c 6f>\n */\nfunction decodeValueProto(valueProto) {\n  var valueType = valueProto.value_type;\n  var value = valueProto[valueType];\n\n  switch (valueType) {\n    case 'arrayValue': {\n      return value.values.map(entity.decodeValueProto);\n    }\n\n    case 'blobValue': {\n      return new Buffer(value, 'base64');\n    }\n\n    case 'nullValue': {\n      return null;\n    }\n\n    case 'doubleValue': {\n      return parseFloat(value, 10);\n    }\n\n    case 'integerValue': {\n      return parseInt(value, 10);\n    }\n\n    case 'entityValue': {\n      return entity.entityFromEntityProto(value);\n    }\n\n    case 'keyValue': {\n      return entity.keyFromKeyProto(value);\n    }\n\n    case 'timestampValue': {\n      return new Date(parseInt(value.seconds, 10) * 1000);\n    }\n\n    default: {\n      return value;\n    }\n  }\n}\n\nentity.decodeValueProto = decodeValueProto;\n\n/**\n * Convert any native value to a protobuf Value message object.\n *\n * @param {*} value - Native value.\n * @return {object}\n *\n * @example\n * encodeValue('Hi');\n * // {\n * //   stringValue: 'Hi'\n * // }\n */\nfunction encodeValue(value) {\n  var valueProto = {};\n\n  if (is.boolean(value)) {\n    valueProto.booleanValue = value;\n    return valueProto;\n  }\n\n  if (is.nil(value)) {\n    valueProto.nullValue = 0;\n    return valueProto;\n  }\n\n  if (is.number(value)) {\n    if (value % 1 === 0) {\n      value = new entity.Int(value);\n    } else {\n      value = new entity.Double(value);\n    }\n  }\n\n  if (value instanceof entity.Int) {\n    valueProto.integerValue = value.value;\n    return valueProto;\n  }\n\n  if (value instanceof entity.Double) {\n    valueProto.doubleValue = value.value;\n    return valueProto;\n  }\n\n  if (value instanceof entity.GeoPoint) {\n    valueProto.geoPointValue = value.value;\n    return valueProto;\n  }\n\n  if (value instanceof Date) {\n    var seconds = value.getTime() / 1000;\n    var secondsRounded = Math.floor(seconds);\n\n    valueProto.timestampValue = {\n      seconds: secondsRounded,\n      nanos: Math.floor((seconds - secondsRounded) * 1e9)\n    };\n\n    return valueProto;\n  }\n\n  if (is.string(value)) {\n    valueProto.stringValue = value;\n    return valueProto;\n  }\n\n  if (value instanceof Buffer) {\n    valueProto.blobValue = value.toString('base64');\n    return valueProto;\n  }\n\n  if (is.array(value)) {\n    valueProto.arrayValue = {\n      values: value.map(entity.encodeValue)\n    };\n    return valueProto;\n  }\n\n  if (value instanceof entity.Key) {\n    valueProto.keyValue = entity.keyToKeyProto(value);\n    return valueProto;\n  }\n\n  if (is.object(value) && !is.empty(value)) {\n    for (var prop in value) {\n      if (value.hasOwnProperty(prop)) {\n        value[prop] = entity.encodeValue(value[prop]);\n      }\n    }\n\n    valueProto.entityValue = {\n      properties: value\n    };\n\n    return valueProto;\n  }\n\n  throw new Error('Unsupported field value, ' + value + ', was provided.');\n}\n\nentity.encodeValue = encodeValue;\n\n/**\n * Convert any entity protocol to a plain object.\n *\n * @todo Use registered metadata if provided.\n *\n * @param {object} entityProto - The protocol entity object to convert.\n * @return {object}\n *\n * @example\n * entityFromEntityProto({\n *   properties: {\n *     map: {\n *       name: {\n *         value: {\n *           value_type: 'stringValue',\n *           stringValue: 'Stephen'\n *         }\n *       }\n *     }\n *   }\n * });\n * // {\n * //   name: 'Stephen'\n * // }\n */\nfunction entityFromEntityProto(entityProto) {\n  var entityObject = {};\n\n  var properties = entityProto.properties || {};\n\n  for (var property in properties) {\n    var value = properties[property];\n    entityObject[property] = entity.decodeValueProto(value);\n  }\n\n  return entityObject;\n}\n\nentity.entityFromEntityProto = entityFromEntityProto;\n\n/**\n * Convert an entity object to an entity protocol object.\n *\n * @param {object} entityObject - The entity object to convert.\n * @return {object}\n *\n * @example\n * entityToEntityProto({\n *   name: 'Burcu',\n *   legit: true\n * });\n * // {\n * //   key: null,\n * //   properties: {\n * //     name: {\n * //       stringValue: 'Burcu'\n * //     },\n * //     legit: {\n * //       booleanValue: true\n * //     }\n * //   }\n * // }\n */\nfunction entityToEntityProto(entityObject) {\n  return {\n    key: null,\n\n    properties: Object.keys(entityObject).reduce(function(properties, key) {\n      properties[key] = entity.encodeValue(entityObject[key]);\n      return properties;\n    }, {})\n  };\n}\n\nentity.entityToEntityProto = entityToEntityProto;\n\n/**\n * Convert an API response array to a qualified Key and data object.\n *\n * @param {object[]} results - The response array.\n * @param {object} results.entity - An entity object.\n * @param {object} results.entity.key - The entity's key.\n * @return {object[]}\n *\n * @example\n * request_('runQuery', {}, function(err, response) {\n *   var entityObjects = formatArray(response.batch.entityResults);\n *   // {\n *   //   key: {},\n *   //   data: {\n *   //     fieldName: 'value'\n *   //   }\n *   // }\n *   //\n * });\n */\nfunction formatArray(results) {\n  return results.map(function(result) {\n    return {\n      key: entity.keyFromKeyProto(result.entity.key),\n      data: entity.entityFromEntityProto(result.entity)\n    };\n  });\n}\n\nentity.formatArray = formatArray;\n\n/**\n * Check if a key is complete.\n *\n * @param {Key} key - The Key object.\n * @return {boolean}\n *\n * @example\n * isKeyComplete(new Key(['Company', 'Google'])); // true\n * isKeyComplete(new Key('Company')); // false\n */\nfunction isKeyComplete(key) {\n  var lastPathElement = entity.keyToKeyProto(key).path.pop();\n  return !!(lastPathElement.id || lastPathElement.name);\n}\n\nentity.isKeyComplete = isKeyComplete;\n\n/**\n * Convert a key protocol object to a Key object.\n *\n * @param {object} keyProto - The key protocol object to convert.\n * @return {Key}\n *\n * @example\n * var key = keyFromKeyProto({\n *   partitionId: {\n *     projectId: 'project-id',\n *     namespaceId: ''\n *   },\n *   path: [\n *     {\n *       kind: 'Kind',\n *       id: '4790047639339008'\n *     }\n *   ]\n * });\n */\nfunction keyFromKeyProto(keyProto) {\n  var keyOptions = {\n    path: []\n  };\n\n  if (keyProto.partitionId && keyProto.partitionId.namespaceId) {\n    keyOptions.namespace = keyProto.partitionId.namespaceId;\n  }\n\n  keyProto.path.forEach(function(path, index) {\n    var id = path.name || Number(path.id);\n\n    keyOptions.path.push(path.kind);\n\n    if (id) {\n      keyOptions.path.push(id);\n    } else if (index < keyProto.path.length - 1) {\n      throw new InvalidKeyError({\n        code: 'MISSING_ANCESTOR_ID'\n      });\n    }\n  });\n\n  return new entity.Key(keyOptions);\n}\n\nentity.keyFromKeyProto = keyFromKeyProto;\n\n/**\n * Convert a Key object to a key protocol object.\n *\n * @param {Key} key - The Key object to convert.\n * @return {object}\n *\n * @example\n * var keyProto = keyToKeyProto(new Key(['Company', 1]));\n * // {\n * //   path: [\n * //     {\n * //       kind: 'Company',\n * //       id: 1\n * //     }\n * //   ]\n * // }\n */\nfunction keyToKeyProto(key) {\n  if (!is.string(key.path[0])) {\n    throw new InvalidKeyError({\n      code: 'MISSING_KIND'\n    });\n  }\n\n  var keyProto = {\n    path: []\n  };\n\n  if (key.namespace) {\n    keyProto.partitionId = {\n      namespaceId: key.namespace\n    };\n  }\n\n  for (var i = 0; i < key.path.length; i += 2) {\n    var pathElement = {\n      kind: key.path[i]\n    };\n\n    var value = key.path[i + 1];\n\n    if (value) {\n      if (is.number(value)) {\n        pathElement.id = value;\n      } else {\n        pathElement.name = value;\n      }\n    } else if (i < key.path.length - 2) {\n      // This isn't just an incomplete key. An ancestor key is incomplete.\n      throw new InvalidKeyError({\n        code: 'MISSING_ANCESTOR_ID'\n      });\n    }\n\n    keyProto.path.push(pathElement);\n  }\n\n  return keyProto;\n}\n\nentity.keyToKeyProto = keyToKeyProto;\n\n/**\n * Convert a query object to a query protocol object.\n *\n * @private\n *\n * @param {object} q - The query object to convert.\n * @return {object}\n *\n * @example\n * queryToQueryProto({\n *   namespace: '',\n *   kinds: [\n *     'Kind'\n *   ],\n *   filters: [],\n *   orders: [],\n *   groupByVal: [],\n *   selectVal: [],\n *   startVal: null,\n *   endVal: null,\n *   limitVal: -1,\n *   offsetVal: -1\n * });\n * // {\n * //   projection: [],\n * //   kinds: [\n * //     {\n * //       name: 'Kind'\n * //     }\n * //   ],\n * //   order: [],\n * //   groupBy: []\n * // }\n */\nfunction queryToQueryProto(query) {\n  var OP_TO_OPERATOR = {\n    '=':  'EQUAL',\n    '>':  'GREATER_THAN',\n    '>=': 'GREATER_THAN_OR_EQUAL',\n    '<':  'LESS_THAN',\n    '<=': 'LESS_THAN_OR_EQUAL',\n    HAS_ANCESTOR: 'HAS_ANCESTOR'\n  };\n\n  var SIGN_TO_ORDER = {\n    '-': 'DESCENDING',\n    '+': 'ASCENDING'\n  };\n\n  var queryProto = {\n    distinctOn: query.groupByVal.map(function(groupBy) {\n      return {\n        name: groupBy\n      };\n    }),\n\n    kind: query.kinds.map(function(kind) {\n      return {\n        name: kind\n      };\n    }),\n\n    order: query.orders.map(function(order) {\n      return {\n        property: {\n          name: order.name\n        },\n        direction: SIGN_TO_ORDER[order.sign]\n      };\n    }),\n\n    projection: query.selectVal.map(function(select) {\n      return {\n        property: {\n          name: select\n        }\n      };\n    })\n  };\n\n  if (query.endVal) {\n    if (is.string(query.endVal)) {\n      queryProto.endCursor = query.endVal;\n    } else {\n      queryProto.endCursor = query.endVal.toString('base64');\n    }\n  }\n\n  if (query.limitVal > 0) {\n    queryProto.limit = {\n      value: query.limitVal\n    };\n  }\n\n  if (query.offsetVal > 0) {\n    queryProto.offset = query.offsetVal;\n  }\n\n  if (query.startVal) {\n    if (is.string(query.startVal)) {\n      queryProto.startCursor = query.startVal;\n    } else {\n      queryProto.startCursor = query.startVal.toString('base64');\n    }\n  }\n\n  if (query.filters.length > 0) {\n    var filters = query.filters.map(function(filter) {\n      var value = {};\n\n      if (filter.name === '__key__') {\n        value.keyValue = entity.keyToKeyProto(filter.val);\n      } else {\n        value = entity.encodeValue(filter.val);\n      }\n\n      return {\n        propertyFilter: {\n          property: {\n            name: filter.name\n          },\n          op: OP_TO_OPERATOR[filter.op],\n          value: value\n        }\n      };\n    });\n\n    queryProto.filter = {\n      compositeFilter: {\n        filters: filters,\n        op: 'AND'\n      }\n    };\n  }\n\n  return queryProto;\n}\n\nentity.queryToQueryProto = queryToQueryProto;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/datastore/query.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module datastore/query\n */\n\n'use strict';\n\nvar arrify = require('arrify');\n\n/*! Developer Documentation\n *\n * @param {module:datastore|module:transaction} scope - The parent scope the\n *     query was created from.\n */\n/**\n * Build a Query object.\n *\n * **Queries are built with {module:datastore#createQuery} and\n * {module:transaction#createQuery}.**\n *\n * @resource [Datastore Queries]{@link http://goo.gl/Cag0r6}\n *\n * @constructor\n * @alias module:datastore/query\n *\n * @param {string=} namespace - Namespace to query entities from.\n * @param {string} kind - Kind to query.\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var datastore = gcloud.datastore();\n * var query = datastore.createQuery('AnimalNamespace', 'Lion');\n */\nfunction Query(scope, namespace, kinds) {\n  if (!kinds) {\n    kinds = namespace;\n    namespace = null;\n  }\n\n  this.scope = scope;\n\n  this.namespace = namespace || null;\n  this.kinds = kinds;\n\n  this.filters = [];\n  this.orders = [];\n  this.groupByVal = [];\n  this.selectVal = [];\n\n  // pagination\n  this.startVal = null;\n  this.endVal = null;\n  this.limitVal = -1;\n  this.offsetVal = -1;\n}\n\n/**\n * Datastore allows querying on properties. Supported comparison operators\n * are `=`, `<`, `>`, `<=`, and `>=`. \"Not equal\" and `IN` operators are\n * currently not supported.\n *\n * *To filter by ancestors, see {module:datastore/query#hasAncestor}.*\n *\n * @resource [Datastore Filters]{@link https://cloud.google.com/datastore/docs/concepts/queries#Datastore_Filters}\n *\n * @param {string} property - The field name.\n * @param {string=} operator - Operator (=, <, >, <=, >=). Default: `=`\n * @param {*} value - Value to compare property to.\n * @return {module:datastore/query}\n *\n * @example\n * //-\n * // List all companies that are located in California.\n * //-\n * var caliQuery = query.filter('state', 'CA');\n *\n * //-\n * // List all companies named Google that have less than 400 employees.\n * //-\n * var companyQuery = query\n *   .filter('name', 'Google')\n *   .filter('size', '<', 400);\n *\n * //-\n * // To filter by key, use `__key__` for the property name. Filter on keys\n * // stored as properties is not currently supported.\n * //-\n * var key = datastore.key(['Company', 'Google']);\n * var keyQuery = query.filter('__key__', key);\n */\nQuery.prototype.filter = function(property, operator, value) {\n  if (arguments.length === 2) {\n    value = operator;\n    operator = '=';\n  }\n\n  // TODO: Add filter validation.\n  this.filters.push({\n    name: property.trim(),\n    op: operator.trim(),\n    val: value\n  });\n  return this;\n};\n\n/**\n * Filter a query by ancestors.\n *\n * @resource [Datastore Ancestor Filters]{@link https://cloud.google.com/datastore/docs/concepts/queries#Datastore_Ancestor_filters}\n *\n * @param {Key} key - Key object to filter by.\n * @return {module:datastore/query}\n *\n * @example\n * var ancestoryQuery = query.hasAncestor(datastore.key(['Parent', 123]));\n */\nQuery.prototype.hasAncestor = function(key) {\n  this.filters.push({ name: '__key__', op: 'HAS_ANCESTOR', val: key });\n  return this;\n};\n\n/**\n * Sort the results by a property name in ascending or descending order. By\n * default, an ascending sort order will be used.\n *\n * @resource [Datastore Sort Orders]{@link https://cloud.google.com/datastore/docs/concepts/queries#Datastore_Sort_orders}\n *\n * @param {string} property - The property to order by.\n * @param {object=} options - Options object.\n * @param {boolean} options.descending - Sort the results by a property name\n *     in descending order. Default: `false`.\n * @return {module:datastore/query}\n *\n * @example\n * // Sort by size ascendingly.\n * var companiesAscending = companyQuery.order('size');\n *\n * // Sort by size descendingly.\n * var companiesDescending = companyQuery.order('size', {\n *   descending: true\n * });\n */\nQuery.prototype.order = function(property, options) {\n  var sign = options && options.descending ? '-' : '+';\n\n  this.orders.push({ name: property, sign: sign });\n  return this;\n};\n\n/**\n * Group query results by a list of properties.\n *\n * @param {array} properties - Properties to group by.\n * @return {module:datastore/query}\n *\n * @example\n * var groupedQuery = companyQuery.groupBy(['name', 'size']);\n */\nQuery.prototype.groupBy = function(fieldNames) {\n  this.groupByVal = arrify(fieldNames);\n  return this;\n};\n\n/**\n * Retrieve only select properties from the matched entities.\n *\n * Queries that select a subset of properties are called Projection Queries.\n *\n * @resource [Projection Queries]{@link https://cloud.google.com/datastore/docs/concepts/projectionqueries}\n *\n * @param {string|string[]} fieldNames - Properties to return from the matched\n *     entities.\n * @return {module:datastore/query}\n *\n * @example\n * // Only retrieve the name property.\n * var selectQuery = companyQuery.select('name');\n *\n * // Only retrieve the name and size properties.\n * var selectQuery = companyQuery.select(['name', 'size']);\n */\nQuery.prototype.select = function(fieldNames) {\n  this.selectVal = arrify(fieldNames);\n  return this;\n};\n\n/**\n * Set a starting cursor to a query.\n *\n * @resource [Query Cursors]{@link https://cloud.google.com/datastore/docs/concepts/queries#Datastore_Query_cursors}\n *\n * @param {string} cursorToken - The starting cursor token.\n * @return {module:datastore/query}\n *\n * @example\n * var cursorToken = 'X';\n *\n * // Retrieve results starting from cursorToken.\n * var startQuery = companyQuery.start(cursorToken);\n */\nQuery.prototype.start = function(start) {\n  this.startVal = start;\n  return this;\n};\n\n/**\n * Set an ending cursor to a query.\n *\n * @resource [Query Cursors]{@link https://cloud.google.com/datastore/docs/concepts/queries#Datastore_Query_cursors}\n *\n * @param {string} cursorToken - The ending cursor token.\n * @return {module:datastore/query}\n *\n * @example\n * var cursorToken = 'X';\n *\n * // Retrieve results limited to the extent of cursorToken.\n * var endQuery = companyQuery.end(cursorToken);\n */\nQuery.prototype.end = function(end) {\n  this.endVal = end;\n  return this;\n};\n\n/**\n * Set a limit on a query.\n *\n * @resource [Query Limits]{@link https://cloud.google.com/datastore/docs/concepts/queries#Datastore_Retrieving_results}\n *\n * @param {number} n - The number of results to limit the query to.\n * @return {module:datastore/query}\n *\n * @example\n * // Limit the results to 10 entities.\n * var limitQuery = companyQuery.limit(10);\n */\nQuery.prototype.limit = function(n) {\n  this.limitVal = n;\n  return this;\n};\n\n/**\n * Set an offset on a query.\n *\n * @resource [Query Offsets]{@link https://cloud.google.com/datastore/docs/concepts/queries#Datastore_Retrieving_results}\n *\n * @param {number} n - The offset to start from after the start cursor.\n * @return {module:datastore/query}\n *\n * @example\n * // Start from the 101st result.\n * var offsetQuery = companyQuery.offset(100);\n */\nQuery.prototype.offset = function(n) {\n  this.offsetVal = n;\n  return this;\n};\n\n/**\n * Run the query.\n *\n * @param {object=} options - Optional configuration.\n * @param {string} options.consistency - Specify either `strong` or `eventual`.\n *     If not specified, default values are chosen by Datastore for the\n *     operation. Learn more about strong and eventual consistency\n *     [here](https://cloud.google.com/datastore/docs/articles/balancing-strong-and-eventual-consistency-with-google-cloud-datastore).\n * @param {function=} callback - The callback function. If omitted, a readable\n *     stream instance is returned.\n * @param {?error} callback.err - An error returned while making this request\n * @param {object[]} callback.entities - A list of entities.\n * @param {object} callback.info - An object useful for pagination.\n * @param {?string} callback.info.endCursor - Use this in a follow-up query to\n *     begin from where these results ended.\n * @param {string} callback.info.moreResults - Datastore responds with one of:\n *\n *     - {module:datastore#MORE_RESULTS_AFTER_LIMIT}: There *may* be more\n *       results after the specified limit.\n *     - {module:datastore#MORE_RESULTS_AFTER_CURSOR}: There *may* be more\n *       results after the specified end cursor.\n *     - {module:datastore#NO_MORE_RESULTS}: There are no more results.\n *\n * @example\n * query.run(function(err, entities, info) {});\n *\n * //-\n * // If you omit the callback, you will get the matching entities in a readable\n * // object stream.\n * //-\n * query.run()\n *   .on('error', console.error)\n *   .on('data', function (entity) {})\n *   .on('info', function(info) {})\n *   .on('end', function() {\n *     // All entities retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * query.run()\n *   .on('data', function (entity) {\n *     this.end();\n *   });\n *\n * //-\n * // A keys-only query returns just the keys of the result entities instead of\n * // the entities themselves, at lower latency and cost.\n * //-\n * query.select('__key__');\n *\n * query.run(function(err, entities) {\n *   // entities[].key = Key object\n *   // entities[].data = Empty object\n * });\n */\nQuery.prototype.run = function() {\n  var query = this;\n  var args = [query].concat([].slice.call(arguments));\n\n  return this.scope.runQuery.apply(this.scope, args);\n};\n\nmodule.exports = Query;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/datastore/transaction.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module datastore/transaction\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar flatten = require('lodash.flatten');\nvar nodeutil = require('util');\nvar prop = require('propprop');\n\n/**\n * @type {module:datastore/request}\n * @private\n */\nvar DatastoreRequest = require('./request.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:datastore} datastore - A Datastore instance.\n *\n * @example\n * // This is how to create a transaction object directly using this Transaction\n * // class. The following transaction object is created for use in the examples\n * // in this file below.\n * var datastore = gcloud.datastore({ projectId: 'project-id' });\n * var Transaction = require('gcloud/lib/datastore/transaction');\n * var transaction = new Transaction(datastore, 'my-project-id');\n * transaction.id = '1234'; // Give the transaction an ID.\n */\n/**\n * A transaction is a set of Datastore operations on one or more entities. Each\n * transaction is guaranteed to be atomic, which means that transactions are\n * never partially applied. Either all of the operations in the transaction are\n * applied, or none of them are applied.\n *\n * @resource [Transactions Reference]{@link https://cloud.google.com/datastore/docs/concepts/transactions}\n *\n * @constructor\n * @alias module:datastore/transaction\n * @mixes module:datastore/request\n *\n * @example\n * var datastore = gcloud.datastore({\n *   projectId: 'my-project',\n *   keyFilename: '/path/to/keyfile.json'\n * });\n *\n * var transaction = datastore.transaction();\n */\nfunction Transaction(datastore) {\n  this.datastore = datastore;\n\n  this.projectId = datastore.projectId;\n\n  this.request = datastore.request.bind(datastore);\n\n  // A queue for entity modifications made during the transaction.\n  this.modifiedEntities_ = [];\n\n  // Queue the callbacks that process the API responses.\n  this.requestCallbacks_ = [];\n\n  // Queue the requests to make when we send the transactional commit.\n  this.requests_ = [];\n}\n\nnodeutil.inherits(Transaction, DatastoreRequest);\n\n/*! Developer Documentation\n *\n * Below, we override two methods that we inherit from DatastoreRequest:\n * `delete` and `save`. This is done because:\n *\n *   A) the documentation needs to be different for a transactional save, and\n *   B) we build up a \"modifiedEntities_\" array on this object, used to build\n *      the final commit request with.\n */\n\n/**\n * Commit the remote transaction and finalize the current transaction instance.\n *\n * If the commit request fails, we will automatically rollback the transaction.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n *   If the commit fails, we automatically try to rollback the transaction (see\n *   {module:datastore/transaction#rollback}).\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * transaction.commit(function(err, apiResponse) {\n *   if (err) {\n *     // Transaction could not be committed.\n *   }\n * });\n */\nTransaction.prototype.commit = function(callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  if (this.skipCommit) {\n    setImmediate(callback);\n    return;\n  }\n\n  var keys = {};\n\n  this.modifiedEntities_\n\n    // Reverse the order of the queue to respect the \"last queued request wins\"\n    // behavior.\n    .reverse()\n\n    // Limit the operations we're going to send through to only the most\n    // recently queued operations. E.g., if a user tries to save with the same\n    // key they just asked to be deleted, the delete request will be ignored,\n    // giving preference to the save operation.\n    .filter(function(modifiedEntity) {\n      var key = JSON.stringify(modifiedEntity.entity.key);\n\n      if (!keys[key]) {\n        keys[key] = true;\n        return true;\n      }\n    })\n\n    // Group entities together by method: `save` mutations, then `delete`. Note:\n    // `save` mutations being first is required to maintain order when assigning\n    // IDs to incomplete keys.\n    .sort(function(a, b) {\n      return a.method < b.method ? 1 : a.method > b.method ? -1 : 0;\n    })\n\n    // Group arguments together so that we only make one call to each method.\n    // This is important for `DatastoreRequest.save`, especially, as that method\n    // handles assigning auto-generated IDs to the original keys passed in. When\n    // we eventually execute the `save` method's API callback, having all the\n    // keys together is necessary to maintain order.\n    .reduce(function(acc, entityObject) {\n      var lastEntityObject = acc[acc.length - 1];\n      var sameMethod = lastEntityObject &&\n        entityObject.method === lastEntityObject.method;\n\n      if (!lastEntityObject || !sameMethod) {\n        acc.push(entityObject);\n      } else {\n        lastEntityObject.args = lastEntityObject.args.concat(entityObject.args);\n      }\n\n      return acc;\n    }, [])\n\n    // Call each of the mutational methods (DatastoreRequest[save,delete]) to\n    // build up a `req` array on this instance. This will also build up a\n    // `callbacks` array, that is the same callback that would run if we were\n    // using `save` and `delete` outside of a transaction, to process the\n    // response from the API.\n    .forEach(function(modifiedEntity) {\n      var method = modifiedEntity.method;\n      var args = modifiedEntity.args.reverse();\n\n      DatastoreRequest.prototype[method].call(self, args, util.noop);\n    });\n\n  var protoOpts = {\n    service: 'Datastore',\n    method: 'commit'\n  };\n\n  // Take the `req` array built previously, and merge them into one request to\n  // send as the final transactional commit.\n  var reqOpts = {\n    mutations: flatten(this.requests_.map(prop('mutations')))\n  };\n\n  this.request_(protoOpts, reqOpts, function(err, resp) {\n    if (err) {\n      // Rollback automatically for the user.\n      self.rollback(function() {\n        // Provide the error & API response from the failed commit to the user.\n        // Even a failed rollback should be transparent.\n        // RE: https://github.com/GoogleCloudPlatform/gcloud-node/pull/1369#discussion_r66833976\n        callback(err, resp);\n      });\n      return;\n    }\n\n    // The `callbacks` array was built previously. These are the callbacks that\n    // handle the API response normally when using the DatastoreRequest.save and\n    // .delete methods.\n    self.requestCallbacks_.forEach(function(cb) {\n      cb(null, resp);\n    });\n\n    callback(null, resp);\n  });\n};\n\n/**\n * Create a query for the specified kind. See {module:datastore/query} for all\n * of the available methods.\n *\n * @resource [Datastore Queries]{@link https://cloud.google.com/datastore/docs/concepts/queries}\n *\n * @see {module:datastore/query}\n *\n * @param {string=} namespace - Namespace.\n * @param {string} kind - The kind to query.\n * @return {module:datastore/query}\n *\n * @example\n * // Run the query inside the transaction.\n * transaction.run(function(err) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   var query = transaction.createQuery('Company');\n *\n *   query.run(function(err, entities) {\n *     if (err) {\n *       // Error handling omitted.\n *     }\n *\n *     transaction.commit(function(err) {\n *       if (!err) {\n *         // Transaction committed successfully.\n *       }\n *     });\n *   });\n * });\n */\nTransaction.prototype.createQuery = function() {\n  return this.datastore.createQuery.apply(this, arguments);\n};\n\n/**\n * Delete all entities identified with the specified key(s) in the current\n * transaction.\n *\n * @param {Key|Key[]} key - Datastore key object(s).\n *\n * @example\n * transaction.run(function(err) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   // Delete a single entity.\n *   transaction.delete(datastore.key(['Company', 123]));\n *\n *   // Delete multiple entities at once.\n *   transaction.delete([\n *     datastore.key(['Company', 123]),\n *     datastore.key(['Product', 'Computer'])\n *   ]);\n *\n *   transaction.commit(function(err) {\n *     if (!err) {\n *       // Transaction committed successfully.\n *     }\n *   });\n * });\n */\nTransaction.prototype.delete = function(entities) {\n  var self = this;\n\n  arrify(entities).forEach(function(ent) {\n    self.modifiedEntities_.push({\n      entity: {\n        key: ent\n      },\n      method: 'delete',\n      args: [ent]\n    });\n  });\n};\n\n/**\n * Reverse a transaction remotely and finalize the current transaction instance.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * transaction.run(function(err) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   transaction.rollback(function(err) {\n *     if (!err) {\n *       // Transaction rolled back successfully.\n *     }\n *   });\n * });\n */\nTransaction.prototype.rollback = function(callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  var protoOpts = {\n    service: 'Datastore',\n    method: 'rollback'\n  };\n\n  this.request_(protoOpts, function(err, resp) {\n    self.skipCommit = true;\n\n    callback(err || null, resp);\n  });\n};\n\n/**\n * Begin a remote transaction. In the callback provided, run your transactional\n * commands.\n *\n * @param {function} callback - The function to execute within the context of\n *     a transaction.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:datastore/transaction} callback.transaction - This transaction\n *     instance.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * transaction.run(function(err, transaction) {\n *   // Perform Datastore transactional operations.\n *   var key = datastore.key(['Company', 123]);\n *\n *   transaction.get(key, function(err, data) {\n *     data.name = 'Google';\n *\n *     transaction.save({\n *       key: key,\n *       data: data\n *     });\n *\n *     transaction.commit(function(err) {\n *       if (!err) {\n *         // Data saved successfully.\n *       }\n *     });\n *   });\n * });\n */\nTransaction.prototype.run = function(callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  var protoOpts = {\n    service: 'Datastore',\n    method: 'beginTransaction'\n  };\n\n  this.request_(protoOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    self.id = resp.transaction;\n\n    callback(null, self, resp);\n  });\n};\n\n/**\n * Insert or update the specified object(s) in the current transaction. If a key\n * is incomplete, its associated object is inserted and the original Key object\n * is updated to contain the generated ID.\n *\n * This method will determine the correct Datastore method to execute (`upsert`,\n * `insert`, or `update`) by using the key(s) provided. For example, if you\n * provide an incomplete key (one without an ID), the request will create a new\n * entity and have its ID automatically assigned. If you provide a complete key,\n * the entity will be updated with the data specified.\n *\n * By default, all properties are indexed. To prevent a property from being\n * included in *all* indexes, you must supply an entity's `data` property as an\n * array. See below for an example.\n *\n * @param {object|object[]} entities - Datastore key object(s).\n * @param {Key} entities.key - Datastore key object.\n * @param {object|object[]} entities.data - Data to save with the provided key.\n *     If you provide an array of objects, you must use the explicit syntax:\n *     `name` for the name of the property and `value` for its value. You may\n *     also specify an `excludeFromIndexes` property, set to `true` or `false`.\n *\n * @example\n * //-\n * // Save a single entity.\n * //\n * // Notice that we are providing an incomplete key. After the transaction is\n * // committed, the Key object held by the `key` variable will be populated\n * // with a path containing its generated ID.\n * //-\n * var key = datastore.key('Company');\n *\n * transaction.run(function(err) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   transaction.save({\n *     key: key,\n *     data: {\n *       rating: '10'\n *     }\n *   });\n *\n *   transaction.commit(function(err) {\n *     if (!err) {\n *       // Data saved successfully.\n *     }\n *   });\n * });\n *\n * //-\n * // To specify an `excludeFromIndexes` value for a Datastore entity, pass in\n * // an array for the key's data. The above example would then look like:\n * //-\n * transaction.run(function(err) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   transaction.save({\n *     key: key,\n *     data: [\n *       {\n *         name: 'rating',\n *         value: '10',\n *         excludeFromIndexes: false\n *       }\n *     ]\n *   });\n *\n *   transaction.commit(function(err) {\n *     if (!err) {\n *       // Data saved successfully.\n *     }\n *   });\n * });\n *\n * //-\n * // Save multiple entities at once.\n * //-\n * var companyKey = datastore.key(['Company', 123]);\n * var productKey = datastore.key(['Product', 'Computer']);\n *\n * transaction.run(function(err) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   transaction.save([\n *     {\n *       key: companyKey,\n *       data: {\n *         HQ: 'Dallas, TX'\n *       }\n *     },\n *     {\n *       key: productKey,\n *       data: {\n *         vendor: 'Dell'\n *       }\n *     }\n *   ]);\n *\n *   transaction.commit(function(err) {\n *     if (!err) {\n *       // Data saved successfully.\n *     }\n *   });\n * });\n */\nTransaction.prototype.save = function(entities) {\n  var self = this;\n\n  arrify(entities).forEach(function(ent) {\n    self.modifiedEntities_.push({\n      entity: {\n        key: ent.key\n      },\n      method: 'save',\n      args: [ent]\n    });\n  });\n};\n\nmodule.exports = Transaction;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/dns/index.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module dns\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar extend = require('extend');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service}\n * @private\n */\nvar Service = require('../common/service.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * @type {module:dns/zone}\n * @private\n */\nvar Zone = require('./zone.js');\n\n/**\n * [Google Cloud DNS](https://cloud.google.com/dns/what-is-cloud-dns) is a high-\n * performance, resilient, global DNS service that provides a cost-effective way\n * to make your applications and services available to your users. This\n * programmable, authoritative DNS service can be used to easily publish and\n * manage DNS records using the same infrastructure relied upon by Google.\n *\n * @constructor\n * @alias module:dns\n *\n * @classdesc\n * The object returned from `gcloud.dns` gives you complete control over your\n * managed zones.\n *\n * To learn more about Google Cloud DNS, see\n * [What is Google Cloud DNS?](https://cloud.google.com/dns/what-is-cloud-dns)\n *\n * @param {object} options - [Configuration object](#/docs).\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var dns = gcloud.dns();\n */\nfunction DNS(options) {\n  if (!(this instanceof DNS)) {\n    options = util.normalizeArguments(this, options);\n    return new DNS(options);\n  }\n\n  var config = {\n    baseUrl: 'https://www.googleapis.com/dns/v1',\n    scopes: [\n      'https://www.googleapis.com/auth/ndev.clouddns.readwrite',\n      'https://www.googleapis.com/auth/cloud-platform'\n    ]\n  };\n\n  Service.call(this, config, options);\n}\n\nnodeutil.inherits(DNS, Service);\n\n/**\n * Create a managed zone.\n *\n * @resource [ManagedZones: create API Documentation]{@link https://cloud.google.com/dns/api/v1/managedZones/create}\n *\n * @throws {error} If a zone name is not provided.\n * @throws {error} If a zone dnsName is not provided.\n *\n * @param {string} name - Unique name for the zone. E.g. \"my-zone\"\n * @param {object} config - Configuration object.\n * @param {string} config.dnsName - DNS name for the zone. E.g. \"example.com.\"\n * @param {string=} config.description - Description text for the zone.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?module:dns/zone} callback.zone - A new {module:dns/zone} object.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * dns.createZone('my-awesome-zone', {\n *   dnsName: 'example.com.', // note the period at the end of the domain.\n *   description: 'This zone is awesome!'\n * }, function(err, zone, apiResponse) {\n *   if (!err) {\n *     // The zone was created successfully.\n *   }\n * });\n */\nDNS.prototype.createZone = function(name, config, callback) {\n  var self = this;\n\n  if (!name) {\n    throw new Error('A zone name is required.');\n  }\n\n  if (!config || !config.dnsName) {\n    throw new Error('A zone dnsName is required.');\n  }\n\n  config.name = name;\n\n  // Required by the API.\n  config.description = config.description || '';\n\n  this.request({\n    method: 'POST',\n    uri: '/managedZones',\n    json: config\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var zone = self.zone(resp.name);\n    zone.metadata = resp;\n\n    callback(null, zone, resp);\n  });\n};\n\n/**\n * Gets a list of managed zones for the project.\n *\n * @resource [ManagedZones: list API Documentation]{@link https://cloud.google.com/dns/api/v1/managedZones/list}\n *\n * @param {object=} query - Query object.\n * @param {number} query.maxApiCalls - Maximum number of API calls to make.\n * @param {number} query.maxResults - Maximum number of results to return.\n * @param {string} query.pageToken - Page token.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?module:dns/zone[]} callback.zones - An array of {module:dns/zone}\n *     objects.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * dns.getZones(function(err, zones, apiResponse) {});\n *\n * //-\n * // Get the zones from your project as a readable object stream.\n * //-\n * dns.getZones()\n *   .on('error', console.error)\n *   .on('data', function(zone) {\n *     // zone is a Zone object.\n *   })\n *   .on('end', function() {\n *     // All zones retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * dns.getZones()\n *   .on('data', function(zone) {\n *     this.end();\n *   });\n */\nDNS.prototype.getZones = function(query, callback) {\n  var self = this;\n\n  if (is.fn(query)) {\n    callback = query;\n    query = {};\n  }\n\n  this.request({\n    uri: '/managedZones',\n    qs: query\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var zones = arrify(resp.managedZones).map(function(zone) {\n      var zoneInstance = self.zone(zone.name);\n      zoneInstance.metadata = zone;\n      return zoneInstance;\n    });\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, query, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    callback(null, zones, nextQuery, resp);\n  });\n};\n\n/**\n * Create a zone object representing a managed zone.\n *\n * @throws {error} If a zone name is not provided.\n *\n * @param  {string} name - The unique name of the zone.\n * @return {module:dns/zone}\n *\n * @example\n * var zone = dns.zone('my-zone');\n */\nDNS.prototype.zone = function(name) {\n  if (!name) {\n    throw new Error('A zone name is required.');\n  }\n\n  return new Zone(this, name);\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(DNS, 'getZones');\n\nmodule.exports = DNS;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/dns/zone.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module dns/zone\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar exec = require('methmeth');\nvar extend = require('extend');\nvar fs = require('fs');\nvar is = require('is');\nvar nodeutil = require('util');\nvar zonefile = require('dns-zonefile');\n\n/**\n * @type {module:dns/change}\n * @private\n */\nvar Change = require('./change.js');\n\n/**\n * @type {module:dns/record}\n * @private\n */\nvar Record = require('./record.js');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * A Zone object is used to interact with your project's managed zone. It will\n * help you add or delete records, delete your zone, and many other convenience\n * methods.\n *\n * @constructor\n * @alias module:dns/zone\n *\n * @example\n * var gcloud = require('gcloud');\n *\n * var dns = gcloud.dns({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var zone = dns.zone('zone-id');\n */\nfunction Zone(dns, name) {\n  var methods = {\n    /**\n     * Create a zone.\n     *\n     * @param {object} config - See {module:dns#createZone}.\n     *\n     * @example\n     * var config = {\n     *   dnsName: 'example.com.',\n     *   // ...\n     * };\n     *\n     * zone.create(config, function(err, zone, apiResponse) {\n     *   if (!err) {\n     *     // The zone was created successfully.\n     *   }\n     * });\n     */\n    create: true,\n\n    /**\n     * Check if the zone exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the zone exists or not.\n     *\n     * @example\n     * zone.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a zone if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * zone.get(function(err, zone, apiResponse) {\n     *   // `zone.metadata` has been populated.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the metadata for the zone.\n     *\n     * @resource [ManagedZones: get API Documentation]{@link https://cloud.google.com/dns/api/v1/managedZones/get}\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An API error.\n     * @param {?object} callback.metadata - Metadata of the zone from the API.\n     * @param {object} callback.apiResponse - Raw API response.\n     *\n     * @example\n     * zone.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: dns,\n    baseUrl: '/managedZones',\n    id: name,\n    createMethod: dns.createZone.bind(dns),\n    methods: methods\n  });\n\n  this.name = name;\n}\n\nnodeutil.inherits(Zone, ServiceObject);\n\n/**\n * Add records to this zone. This is a convenience wrapper around\n * {module:dns/zone#createChange}.\n *\n * @resource [ManagedZones: create API Documentation]{@link https://cloud.google.com/dns/api/v1/managedZones/create}\n *\n * @param {module:dns/record|module:dns/record[]} record - The record objects to\n *     add.\n * @param {?error} callback.err - An API error.\n * @param {?module:dns/change} callback.change - A {module:dns/change} object.\n * @param {object} callback.apiResponse - Raw API response.\n */\nZone.prototype.addRecords = function(records, callback) {\n  this.createChange({\n    add: records\n  }, callback);\n};\n\n/**\n * Create a reference to a change object in this zone.\n *\n * @param {string} id - The change id.\n * @return {module:dns/change}\n *\n * @example\n * var change = zone.change('change-id');\n */\nZone.prototype.change = function(id) {\n  return new Change(this, id);\n};\n\n/**\n * Create a change of resource record sets for the zone.\n *\n * @resource [ManagedZones: create API Documentation]{@link https://cloud.google.com/dns/api/v1/managedZones/create}\n *\n * @param {object} config - The configuration object.\n * @param {module:dns/record|module:dns/record[]} config.add - Record objects\n *     to add to this zone.\n * @param {module:dns/record|module:dns/record[]} config.delete - Record\n *     objects to delete from this zone. Be aware that the resource records here\n *     must match exactly to be deleted.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?module:dns/change} callback.change - A {module:dns/change} object.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * var oldARecord = zone.record('a', {\n *   name: 'example.com.',\n *   data: '1.2.3.4',\n *   ttl: 86400\n * });\n *\n * var newARecord = zone.record('a', {\n *   name: 'example.com.',\n *   data: '5.6.7.8',\n *   ttl: 86400\n * });\n *\n * zone.createChange({\n *   add: newARecord,\n *   delete: oldARecord\n * }, function(err, change, apiResponse) {\n *   if (!err) {\n *     // The change was created successfully.\n *   }\n * });\n */\nZone.prototype.createChange = function(config, callback) {\n  var self = this;\n\n  if (!config || !config.add && !config.delete) {\n    throw new Error('Cannot create a change with no additions or deletions.');\n  }\n\n  var body = extend({}, config, {\n    additions: arrify(config.add).map(exec('toJSON')),\n    deletions: arrify(config.delete).map(exec('toJSON'))\n  });\n\n  delete body.add;\n  delete body.delete;\n\n  this.request({\n    method: 'POST',\n    uri: '/changes',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var change = self.change(resp.id);\n    change.metadata = resp;\n\n    callback(null, change, resp);\n  });\n};\n\n/**\n * Delete the zone.\n *\n * Only empty zones can be deleted. Set options.force to `true` to call\n * {module:dns/zone#empty} before deleting the zone. Two API calls will then be\n * made (one to empty, another to delete), which means <strong> this is not an\n * atomic request</strong>.\n *\n * @resource [ManagedZones: delete API Documentation]{@link https://cloud.google.com/dns/api/v1/managedZones/delete}\n *\n * @param {object=} options - Configuration object.\n * @param {boolean} options.force - Empty the zone before deleting.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * zone.delete(function(err, apiResponse) {\n *   if (!err) {\n *     // The zone is now deleted.\n *   }\n * });\n *\n * //-\n * // Use `force` to first empty the zone before deleting it.\n * //-\n * zone.delete({\n *   force: true\n * }, function(err, apiResponse) {\n *   if (!err) {\n *     // The zone is now deleted.\n *   }\n * });\n */\nZone.prototype.delete = function(options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  if (options.force) {\n    this.empty(this.delete.bind(this, callback));\n    return;\n  }\n\n  ServiceObject.prototype.delete.call(this, callback);\n};\n\n/**\n * Delete records from this zone. This is a convenience wrapper around\n * {module:dns/zone#createChange}.\n *\n * This method accepts {module:dns/record} objects or string record types in\n * its place. This means that you can delete all A records or NS records, etc.\n * If used this way, two API requests are made (one to get, then another to\n * delete), which means <strong>the operation is not atomic</strong> and could\n * result in unexpected changes.\n *\n * @resource [ManagedZones: create API Documentation]{@link https://cloud.google.com/dns/api/v1/managedZones/create}\n *\n * @param {module:dns/record|module:dns/record[]|string} record - If given a\n *     string, it is interpreted as a record type. All records that match that\n *     type will be retrieved and then deleted. You can also provide a\n *     {module:dns/record} object or array of objects.\n * @param {?error} callback.err - An API error.\n * @param {?module:dns/change} callback.change - A {module:dns/change} object.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * var oldARecord = zone.record('a', {\n *   name: 'example.com.',\n *   data: '1.2.3.4',\n *   ttl: 86400\n * });\n *\n * var callback = function(err, change, apiResponse) {\n *   if (!err) {\n *     // Delete change modification was created.\n *   }\n * };\n *\n * zone.deleteRecords(oldARecord, callback);\n *\n * //-\n * // Delete multiple records at once.\n * //-\n * var oldNs1Record = zone.record('ns', {\n *   name: 'example.com.',\n *   data: 'ns-cloud1.googledomains.com.',\n *   ttl: 86400\n * });\n *\n * var oldNs2Record = zone.record('ns', {\n *   name: 'example.com.',\n *   data: 'ns-cloud2.googledomains.com.',\n *   ttl: 86400\n * });\n *\n * zone.deleteRecords([\n *   oldNs1Record,\n *   oldNs2Record\n * ], callback);\n *\n * //-\n * // Possibly a simpler way to perform the above change is deleting records by\n * // type.\n * //-\n * zone.deleteRecords('ns', callback);\n *\n * //-\n * // You can also delete records of multiple types.\n * //-\n * zone.deleteRecords(['ns', 'a'], callback);\n */\nZone.prototype.deleteRecords = function(records, callback) {\n  records = arrify(records);\n\n  if (is.string(records[0])) {\n    this.deleteRecordsByType_(records, callback);\n    return;\n  }\n\n  this.createChange({\n    delete: records\n  }, callback);\n};\n\n/**\n * Emptying your zone means leaving only 'NS' and 'SOA' records. This method\n * will first fetch the non-NS and non-SOA records from your zone using\n * {module:dns/zone#getRecords}, then use {module:dns/zone#createChange} to\n * create a deletion change.\n *\n * @resource [ManagedZones: create API Documentation]{@link https://cloud.google.com/dns/api/v1/managedZones/create}\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?module:dns/change} callback.change - A {module:dns/change} object.\n * @param {object} callback.apiResponse - Raw API response.\n */\nZone.prototype.empty = function(callback) {\n  var self = this;\n\n  this.getRecords(function(err, records) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var recordsToDelete = records.filter(function(record) {\n      return record.type !== 'NS' && record.type !== 'SOA';\n    });\n\n    if (recordsToDelete.length === 0) {\n      callback();\n    } else {\n      self.deleteRecords(recordsToDelete, callback);\n    }\n  });\n};\n\n/**\n * Provide a path to a zone file to copy records into the zone.\n *\n * @resource [ResourceRecordSets: list API Documentation]{@link https://cloud.google.com/dns/api/v1/resourceRecordSets/list}\n *\n * @param {string} localPath - The fully qualified path to the zone file.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API or file system error.\n *\n * @example\n * var zoneFilename = '/Users/stephen/zonefile.zone';\n *\n * zone.export(zoneFilename, function(err) {\n *   if (!err) {\n *     // The zone file was created successfully.\n *   }\n * });\n */\nZone.prototype.export = function(localPath, callback) {\n  this.getRecords(function(err, records) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var stringRecords = records.map(exec('toString')).join('\\n');\n\n    fs.writeFile(localPath, stringRecords, 'utf-8', function(err) {\n      callback(err || null);\n    });\n  });\n};\n\n/**\n * Get the list of changes associated with this zone. A change is an atomic\n * update to a collection of records.\n *\n * @resource [Changes: get API Documentation]{@link https://cloud.google.com/dns/api/v1/changes/get}\n *\n * @param {object=} query - The query object.\n * @param {number} query.maxApiCalls - Maximum number of API calls to make.\n * @param {number} query.maxResults - Maximum number of results to return.\n * @param {string} query.pageToken - The page token.\n * @param {string} query.sort - Set to 'asc' for ascending, and 'desc' for\n *     descending or omit for no sorting.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?module:dns/change[]} callback.changes - An array of\n *     {module:dns/change} objects.\n * @param {?object} callback.nextQuery - A query object representing the next\n *     page of results.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * var callback = function(err, changes, nextQuery, apiResponse) {\n *   // The `metadata` property is populated for you with the metadata at the\n *   // time of fetching.\n *   changes[0].metadata;\n *\n *   // However, in cases where you are concerned the metadata could have\n *   // changed, use the `getMetadata` method.\n *   changes[0].getMetadata(function(err, metadata) {});\n\n *   if (nextQuery) {\n *     // nextQuery will be non-null if there are more results.\n *     zone.getChanges(nextQuery, callback);\n *   }\n * };\n *\n * zone.getChanges(callback);\n *\n * //-\n * // Get the changes from your zone as a readable object stream.\n * //-\n * zone.getChanges()\n *   .on('error', console.error)\n *   .on('data', function(change) {\n *     // change is a Change object.\n *   })\n *   .on('end', function() {\n *     // All changes retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * zone.getChanges()\n *   .on('data', function(change) {\n *     this.end();\n *   });\n */\nZone.prototype.getChanges = function(query, callback) {\n  var self = this;\n\n  if (is.fn(query)) {\n    callback = query;\n    query = {};\n  }\n\n  if (query.sort) {\n    query.sortOrder = query.sort === 'asc' ? 'ascending' : 'descending';\n    delete query.sort;\n  }\n\n  this.request({\n    uri: '/changes',\n    qs: query\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var changes = (resp.changes || []).map(function(change) {\n      var changeInstance = self.change(change.id);\n      changeInstance.metadata = change;\n      return changeInstance;\n    });\n\n    var nextQuery = null;\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, query, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    callback(null, changes, nextQuery, resp);\n  });\n};\n\n/**\n * Get the list of records for this zone.\n *\n * @resource [ResourceRecordSets: list API Documentation]{@link https://cloud.google.com/dns/api/v1/resourceRecordSets/list}\n *\n * @param {object=} query - The query object.\n * @param {number} query.maxApiCalls - Maximum number of API calls to make.\n * @param {number} query.maxResults - Maximum number of results to be returned.\n * @param {string} query.name - Restricts the list to return only records with\n *     this fully qualified domain name.\n * @param {string} query.pageToken - The page token.\n * @param {string} query.type - Restricts the list to return only records of\n *     this type. If present, the \"name\" parameter must also be present.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?module:dns/record[]} callback.records - An array of\n *     {module:dns/record} objects.\n * @param {?object} callback.nextQuery - A query object representing the next\n *     page of results.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * var callback = function(err, records, nextQuery, apiResponse) {\n *   if (!err) {\n *     // records is an array of Record objects.\n *   }\n *\n *   if (nextQuery) {\n *     zone.getRecords(nextQuery, callback);\n *   }\n * };\n *\n * zone.getRecords(callback);\n *\n * //-\n * // Provide a query for further customization.\n * //-\n *\n * // Get the namespace records for example.com.\n * var query = {\n *   name: 'example.com.',\n *   type: 'NS'\n * };\n *\n * zone.getRecords(query, callback);\n *\n * //-\n * // Get the records from your zone as a readable object stream.\n * //-\n * zone.getRecords()\n *   .on('error', console.error)\n *   .on('data', function(record) {\n *     // record is a Record object.\n *   })\n *   .on('end', function() {\n *     // All records retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * zone.getRecords()\n *   .on('data', function(change) {\n *     this.end();\n *   });\n *\n * //-\n * // If you only want records of a specific type or types, provide them in\n * // place of the query object.\n * //-\n * zone.getRecords('ns', function(err, records) {\n *   if (!err) {\n *     // records is an array of NS Record objects in your zone.\n *   }\n * });\n *\n * //-\n * // You can also specify multiple record types.\n * //-\n * zone.getRecords(['ns', 'a', 'cname'], function(err, records) {\n *   if (!err) {\n *     // records is an array of NS, A, and CNAME records in your zone.\n *   }\n * });\n */\nZone.prototype.getRecords = function(query, callback) {\n  var self = this;\n\n  if (is.fn(query)) {\n    callback = query;\n    query = {};\n  }\n\n  if (is.string(query) || is.array(query)) {\n    var filterByTypes_ = {};\n\n    // For faster lookups, store the record types the user wants in an object.\n    arrify(query).forEach(function(type) {\n      filterByTypes_[type.toUpperCase()] = true;\n    });\n\n    query = {\n      filterByTypes_: filterByTypes_\n    };\n  }\n\n  var requestQuery = extend({}, query);\n  delete requestQuery.filterByTypes_;\n\n  this.request({\n    uri: '/rrsets',\n    qs: requestQuery\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var records = (resp.rrsets || []).map(function(record) {\n      return self.record(record.type, record);\n    });\n\n    if (query.filterByTypes_) {\n      records = records.filter(function(record) {\n        return query.filterByTypes_[record.type];\n      });\n    }\n\n    var nextQuery = null;\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, query, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    callback(null, records, nextQuery, resp);\n  });\n};\n\n/**\n * Copy the records from a zone file into this zone.\n *\n * @resource [ManagedZones: create API Documentation]{@link https://cloud.google.com/dns/api/v1/managedZones/create}\n *\n * @param {string} localPath - The fully qualified path to the zone file.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API or file system error.\n * @param {?module:dns/change} callback.change - A {module:dns/change} object.\n * @param {?object} callback.apiResponse - Raw API response.\n *\n * @example\n * var zoneFilename = '/Users/dave/zonefile.zone';\n *\n * zone.import(zoneFilename, function(err, change, apiResponse) {\n *   if (!err) {\n *     // The change was created successfully.\n *   }\n * });\n */\nZone.prototype.import = function(localPath, callback) {\n  var self = this;\n\n  fs.readFile(localPath, 'utf-8', function(err, file) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var parsedZonefile = zonefile.parse(file);\n    var recordTypes = Object.keys(parsedZonefile);\n    var recordsToCreate = [];\n\n    recordTypes.forEach(function(recordType) {\n      var recordTypeSet = arrify(parsedZonefile[recordType]);\n\n      recordTypeSet.forEach(function(record) {\n        recordsToCreate.push(Record.fromZoneRecord_(self, recordType, record));\n      });\n    });\n\n    self.addRecords(recordsToCreate, callback);\n  });\n};\n\n/**\n * A {module:dns/record} object can be used to construct a record you want to\n * add to your zone, or to refer to an existing one.\n *\n * Note that using this method will not itself make any API requests. You will\n * use the object returned in other API calls, for example to add a record to\n * your zone or to delete an existing one.\n *\n * @param {string} type - The type of record to construct or the type of record\n *     you are referencing.\n * @param {object} metadata - The metadata of this record.\n * @param {string} metadata.name - The name of the record, e.g.\n *     `www.example.com.`.\n * @param {string[]} metadata.data - Defined in\n *     [RFC 1035, section 5](https://goo.gl/9EiM0e) and\n *     [RFC 1034, section 3.6.1](https://goo.gl/Hwhsu9).\n * @param {number} metadata.ttl - Seconds that the resource is cached by\n *     resolvers.\n * @return {module:dns/record}\n *\n * @example\n * //-\n * // Reference an existing record to delete from your zone.\n * //-\n * var oldARecord = zone.record('a', {\n *   name: 'example.com.',\n *   data: '1.2.3.4',\n *   ttl: 86400\n * });\n *\n * //-\n * // Construct a record to add to your zone.\n * //-\n * var newARecord = zone.record('a', {\n *   name: 'example.com.',\n *   data: '5.6.7.8',\n *   ttl: 86400\n * });\n *\n * //-\n * // Use these records together to create a change.\n * //-\n * zone.createChange({\n *   add: newARecord,\n *   delete: oldARecord\n * }, function(err, change, apiResponse) {});\n */\nZone.prototype.record = function(type, metadata) {\n  return new Record(this, type, metadata);\n};\n\n/**\n * Provide a record type that should be deleted and replaced with other records.\n *\n * <strong>This is not an atomic request.</strong> Two API requests are made\n * (one to get records of the type that you've requested, then another to\n * replace them), which means the operation is not atomic and could result in\n * unexpected changes.\n *\n * @resource [ManagedZones: create API Documentation]{@link https://cloud.google.com/dns/api/v1/managedZones/create}\n *\n * @param {string|string[]} recordTypes - Type(s) of records to replace.\n * @param {module:dns/record|module:dns/record[]} newRecords - The record\n *     objects to add.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?module:dns/change} callback.change - A {module:dns/change} object.\n * @param {?object} callback.apiResponse - Raw API response.\n *\n * @example\n * var newNs1Record = zone.record('ns', {\n *   name: 'example.com.',\n *   data: 'ns-cloud1.googledomains.com.',\n *   ttl: 86400\n * });\n *\n * var newNs2Record = zone.record('ns', {\n *   name: 'example.com.',\n *   data: 'ns-cloud2.googledomains.com.',\n *   ttl: 86400\n * });\n *\n * var newNsRecords = [\n *   newNs1Record,\n *   newNs2Record\n * ];\n *\n * zone.replaceRecords('ns', newNsRecords, function(err, change, apiResponse) {\n *   if (!err) {\n *     // The change was created successfully.\n *   }\n * });\n */\nZone.prototype.replaceRecords = function(recordType, newRecords, callback) {\n  var self = this;\n\n  this.getRecords(recordType, function(err, recordsToDelete) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    self.createChange({\n      add: newRecords,\n      delete: recordsToDelete\n    }, callback);\n  });\n};\n\n/**\n * Delete records from the zone matching an array of types.\n *\n * @private\n *\n * @param {string[]} recordTypes - Types of records to delete. Ex: 'NS', 'A'.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?module:dns/change} callback.change - A {module:dns/change} object.\n * @param {?object} callback.apiResponse - Raw API response.\n *\n * @example\n * zone.deleteRecordsByType_(['NS', 'A'], function(err, change, apiResponse) {\n *   if (!err) {\n *     // The change was created successfully.\n *   }\n * });\n */\nZone.prototype.deleteRecordsByType_ = function(recordTypes, callback) {\n  var self = this;\n\n  this.getRecords(recordTypes, function(err, records) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (records.length === 0) {\n      callback();\n      return;\n    }\n\n    self.deleteRecords(records, callback);\n  });\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(Zone, ['getChanges', 'getRecords']);\n\nmodule.exports = Zone;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/dns/change.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module dns/change\n */\n\n'use strict';\n\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @constructor\n * @alias module:dns/change\n *\n * @param {module:dns/zone} zone - The parent zone object.\n * @param {string} id - ID of the change.\n *\n * @example\n * var gcloud = require('gcloud');\n *\n * var dns = gcloud.dns({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var zone = dns.zone('zone-id');\n * var change = zone.change('change-id');\n */\nfunction Change(zone, id) {\n  var methods = {\n    /**\n     * Check if the change exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the change exists or not.\n     *\n     * @example\n     * change.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a change if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * change.get(function(err, change, apiResponse) {\n     *   // `change.metadata` has been populated.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the metadata for the change in the zone.\n     *\n     * @resource [Changes: get API Documentation]{@link https://cloud.google.com/dns/api/v1/changes/get}\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An API error.\n     * @param {?object} callback.metadata - Metadata of the change from the API.\n     * @param {object} callback.apiResponse - Raw API response.\n     *\n     * @example\n     * change.getMetadata(function(err, metadata, apiResponse) {\n     *   if (!err) {\n     *     // metadata = {\n     *     //   kind: 'dns#change',\n     *     //   additions: [{...}],\n     *     //   deletions: [{...}],\n     *     //   startTime: '2015-07-21T14:40:06.056Z',\n     *     //   id: '1',\n     *     //   status: 'done'\n     *     // }\n     *   }\n     * });\n     */\n    getMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: zone,\n    baseUrl: '/changes',\n    id: id,\n    methods: methods\n  });\n}\n\nnodeutil.inherits(Change, ServiceObject);\n\n/**\n * Create a change.\n *\n * @param {object} config - See {module:dns/zone#createChange}.\n *\n * @example\n * var config = {\n *   add: {\n *     // ...\n *   }\n * };\n *\n * change.create(config, function(err, change, apiResponse) {\n *   if (!err) {\n *     // The change was created successfully.\n *   }\n * });\n */\nChange.prototype.create = function(config, callback) {\n  var self = this;\n\n  this.parent.createChange(config, function(err, change, apiResponse) {\n    if (err) {\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    self.id = change.id;\n    self.metadata = change.metadata;\n\n    callback(null, self, apiResponse);\n  });\n};\n\nmodule.exports = Change;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/dns/record.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module dns/record\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar extend = require('extend');\nvar format = require('string-format-obj');\n\n/**\n * Create a Resource Record object.\n *\n * @constructor\n * @alias module:dns/record\n *\n * @param {object} type - The record type, e.g. `A`, `AAAA`, `MX`.\n * @param {object} metadata - The metadata of this record.\n * @param {string} metadata.name - The name of the record, e.g.\n *     `www.example.com.`.\n * @param {string[]} metadata.data - Defined in\n *     [RFC 1035, section 5](https://goo.gl/9EiM0e) and\n *     [RFC 1034, section 3.6.1](https://goo.gl/Hwhsu9).\n * @param {number} metadata.ttl - Seconds that the resource is cached by\n *     resolvers.\n *\n * @example\n * var gcloud = require('gcloud');\n *\n * var dns = gcloud.dns({\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var zone = dns.zone('my-awesome-zone');\n *\n * var record = zone.record('a', {\n *   name: 'example.com.',\n *   ttl: 86400,\n *   data: '1.2.3.4'\n * });\n */\nfunction Record(zone, type, metadata) {\n  this.zone_ = zone;\n\n  this.type = type;\n  this.metadata = metadata;\n\n  extend(this, this.toJSON());\n\n  if (this.rrdatas) {\n    this.data = this.rrdatas;\n    delete this.rrdatas;\n  }\n}\n\n/**\n * Create a Record instance from a resource record set in a zone file.\n *\n * @private\n *\n * @param {module:dns/zone} zone     [description]\n * @param {string} type - The record type, e.g. `A`, `AAAA`, `MX`.\n * @param {object} bindData - Metadata parsed from dns-zonefile. Properties vary\n *     based on the type of record.\n * @return {module:dns/record}\n */\nRecord.fromZoneRecord_ = function(zone, type, bindData) {\n  var typeToZoneFormat = {\n    a: '{ip}',\n    aaaa: '{ip}',\n    cname: '{alias}',\n    mx: '{preference} {host}',\n    ns: '{host}',\n    soa: '{mname} {rname} {serial} {retry} {refresh} {expire} {minimum}',\n    spf: '{data}',\n    srv: '{priority} {weight} {port} {target}',\n    txt: '{txt}'\n  };\n\n  var metadata = {\n    data: format(typeToZoneFormat[type.toLowerCase()], bindData),\n    name: bindData.name,\n    ttl: bindData.ttl\n  };\n\n  return new Record(zone, type, metadata);\n};\n\n/**\n * Delete this record by creating a change on your zone. This is a convenience\n * method for:\n *\n *     zone.createChange({\n *       delete: record\n *     }, function(err, change, apiResponse) {});\n *\n * @resource [ManagedZones: create API Documentation]{@link https://cloud.google.com/dns/api/v1/managedZones/create}\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?module:dns/change} callback.change - A {module:dns/change} object.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * record.delete(function(err, change, apiResponse) {\n *   if (!err) {\n *     // Delete change modification was created.\n *   }\n * });\n */\nRecord.prototype.delete = function(callback) {\n  this.zone_.deleteRecords(this, callback);\n};\n\n/**\n * Serialize the record instance to the format the API expects.\n *\n * @private\n */\nRecord.prototype.toJSON = function() {\n  var recordObject = extend({}, this.metadata, {\n    type: this.type.toUpperCase()\n  });\n\n  if (recordObject.data) {\n    recordObject.rrdatas = arrify(recordObject.data);\n    delete recordObject.data;\n  }\n\n  return recordObject;\n};\n\n/**\n * Convert the record to a string, formatted for a zone file.\n *\n * @private\n *\n * @return {string}\n */\nRecord.prototype.toString = function() {\n  var json = this.toJSON();\n\n  return (json.rrdatas || [{}]).map(function(data) {\n    json.rrdata = data;\n    return format('{name} {ttl} IN {type} {rrdata}', json);\n  }).join('\\n');\n};\n\nmodule.exports = Record;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/prediction/index.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module prediction\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar extend = require('extend');\nvar format = require('string-format-obj');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:prediction/model}\n * @private\n */\nvar Model = require('./model.js');\n\n/**\n * @type {module:common/service}\n * @private\n */\nvar Service = require('../common/service.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * The [Google Prediction API](https://cloud.google.com/prediction/docs/getting-started)\n * provides pattern-matching and machine learning capabilities. Given a set of\n * data examples to train against, you can create applications that can perform\n * the following tasks:\n *\n *   - Given a user's past viewing habits, predict what other movies or products\n *   a user might like.\n *   - Categorize emails as spam or non-spam.\n *   - Analyze posted comments about your product to determine whether they have\n *   a positive or negative tone.\n *   - Guess how much a user might spend on a given day, given his spending\n *   history.\n *\n * @resource [Hello Prediction! Example]{@link https://cloud.google.com/prediction/docs/hello_world}\n * @resource [What is the Google Prediction API?]{@link https://cloud.google.com/prediction/docs/getting-started}\n * @resource [Developers Guide]{@link https://cloud.google.com/prediction/docs/developer-guide}\n *\n * @constructor\n * @alias module:prediction\n *\n * @classdesc\n * The `gcloud.prediction` method will return a `prediction` object, allowing\n * you to create models, train them, and query them.\n *\n * To learn more about the Prediction API, see\n * [What is the Google Prediction API?](https://cloud.google.com/prediction/docs/getting-started)\n *\n * @param {object} options - [Configuration object](#/docs).\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var prediction = gcloud.prediction();\n */\nfunction Prediction(options) {\n  if (!(this instanceof Prediction)) {\n    options = util.normalizeArguments(this, options);\n    return new Prediction(options);\n  }\n\n  var config = {\n    baseUrl: 'https://www.googleapis.com/prediction/v1.6',\n    scopes: [\n      'https://www.googleapis.com/auth/prediction',\n      'https://www.googleapis.com/auth/devstorage.read_only'\n    ]\n  };\n\n  Service.call(this, config, options);\n}\n\nnodeutil.inherits(Prediction, Service);\n\n/**\n * Create a trained model.\n *\n * You may optionally provide a {module:storage/file} as a data source to train\n * the new model. If you have a CSV file, but haven't put it in a bucket yet,\n * you will need to reference a bucket with {module:storage/bucket}, a file with\n * {module:storage/file}, and upload it with {module:storage/file#upload}.\n *\n * @resource [Trainedmodels: insert API Documentation]{@link https://cloud.google.com/prediction/docs/reference/v1.6/trainedmodels/insert}\n *\n * @throws {error} If a model ID is not provided.\n *\n * @param {string} id - Unique name for the model. E.g. \"my-model\"\n * @param {object=} options - See the\n *     [Trainedmodels: insert API Documentation](https://cloud.google.com/prediction/docs/reference/v1.6/trainedmodels/insert)\n *     request body.\n * @param {module:storage/file} options.data - A CSV file to use as training\n *     data.\n * @param {string} options.type - The type of model, `classification`\n *     (categorical, text labels) or `regression` (numeric labels). Learn more\n *     about these options in the [Developers Guide](https://cloud.google.com/prediction/docs/developer-guide#examples).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?module:prediction/model} callback.model - A new\n *     {module:prediction/model} object.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * prediction.createModel('my-model', function(err, model, apiResponse) {\n *   // `model` is a Model object.\n * });\n *\n * //-\n * // Create a model, using an existing CSV file in a Google Cloud Storage\n * // bucket as training data.\n * //-\n * var gcs = gcloud.storage();\n * var bucket = gcs.bucket('my-bucket');\n * var modelDataCsv = bucket.file('my-model.csv');\n *\n * prediction.createModel('my-model', {\n *   data: modelDataCsv\n * }, function(err, model, apiResponse) {});\n */\nPrediction.prototype.createModel = function(id, options, callback) {\n  var self = this;\n\n  if (!id) {\n    throw new Error('A model ID is required.');\n  }\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var body = extend({}, options, {\n    id: id\n  });\n\n  if (body.data) {\n    var file = body.data;\n\n    body.storageDataLocation = format('{bucket}/{fileName}', {\n      bucket: file.parent.name,\n      fileName: file.name\n    });\n\n    delete body.data;\n  }\n\n  if (body.type) {\n    body.modelType = body.type.toUpperCase();\n    delete body.type;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/trainedmodels',\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var model = self.model(resp.id);\n    model.metadata = resp;\n\n    callback(null, model, resp);\n  });\n};\n\n/**\n * Gets a list of trained models for the project.\n *\n * @resource [Trainedmodels: list API Documentation]{@link https://cloud.google.com/prediction/docs/reference/v1.6/trainedmodels/list}\n *\n * @param {object=} query - Query object.\n * @param {boolean} query.autoPaginate - Have pagination handled automatically.\n *     Default: true.\n * @param {number} query.maxApiCalls - Maximum number of API calls to make.\n * @param {number} query.maxResults - Maximum number of results to return.\n * @param {string} query.pageToken - Page token.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {?module:prediction/model[]} callback.models - An array of\n *     {module:prediction/model} objects.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * prediction.getModels(function(err, models) {\n *   if (!err) {\n *     // models is an array of Model objects.\n *   }\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * var callback = function(err, models, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     prediction.getModels(nextQuery, callback);\n *   }\n *\n *   // The `metadata` property is populated for you with the metadata at the\n *   // time of fetching.\n *   models[0].metadata;\n *\n *   // However, in cases where you are concerned the metadata could have\n *   // changed, use the `getMetadata` method.\n *   models[0].getMetadata(function(err, metadata) {});\n * };\n *\n * prediction.getModels({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the models from your project as a readable object stream.\n * //-\n * prediction.getModels()\n *   .on('error', console.error)\n *   .on('data', function(model) {\n *     // model is a Model object.\n *   })\n *   .on('end', function() {\n *     // All models retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * prediction.getModels()\n *   .on('data', function(model) {\n *     this.end();\n *   });\n */\nPrediction.prototype.getModels = function(query, callback) {\n  var self = this;\n\n  if (is.fn(query)) {\n    callback = query;\n    query = {};\n  }\n\n  this.request({\n    uri: '/trainedmodels/list',\n    qs: query\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var models = arrify(resp.items).map(function(model) {\n      var modelInstance = self.model(model.id);\n      modelInstance.metadata = model;\n      return modelInstance;\n    });\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, query, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    callback(null, models, nextQuery, resp);\n  });\n};\n\n/**\n * Create a model object representing a trained model.\n *\n * @throws {error} If a model ID is not provided.\n *\n * @param {string} id - The unique ID of the trained model.\n * @return {module:prediction/model}\n *\n * @example\n * var model = prediction.model('my-model');\n */\nPrediction.prototype.model = function(id) {\n  if (!id) {\n    throw new Error('A model ID is required.');\n  }\n\n  return new Model(this, id);\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(Prediction, 'getModels');\n\nmodule.exports = Prediction;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/prediction/model.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module prediction/model\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar JSONStream = require('JSONStream');\nvar nodeutil = require('util');\nvar pumpify = require('pumpify');\nvar streamEvents = require('stream-events');\nvar through = require('through2');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:prediction} prediction - Prediction this model belongs to.\n * @param {string} id - The ID of the model.\n */\n/**\n * A Model object represents a trained model. You can train it by using\n * {module:prediction/model#train} or ask for predictions with\n * {module:prediction/model#query}.\n *\n * @resource [Developer's Guide: Training Your Model]{@link https://cloud.google.com/prediction/docs/developer-guide#trainingtheapi}\n * @resource [Model Resource]{@link https://cloud.google.com/prediction/docs/reference/v1.6/trainedmodels}\n *\n * @constructor\n * @alias module:compute/address\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var prediction = gcloud.prediction();\n *\n * var model = prediction.model('my-model');\n */\nfunction Model(prediction, id) {\n  var methods = {\n    /**\n     * Create a trained model.\n     *\n     * @param {object=} options - See {module:prediction#createModel}.\n     *\n     * @example\n     * model.create(function(err, model, apiResponse) {\n     *   if (!err) {\n     *     // The model was created successfully.\n     *   }\n     * });\n     */\n    create: true,\n\n    /**\n     * Delete the model.\n     *\n     * @resource [Trainedmodels: delete API Documentation]{@link https://cloud.google.com/prediction/docs/reference/v1.6/trainedmodels/delete}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * model.delete(function(err, apiResponse) {});\n     */\n    delete: true,\n\n    /**\n     * Check if the model exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the model exists or not.\n     *\n     * @example\n     * model.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a model if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * model.get(function(err, model, apiResponse) {\n     *   // `model.metadata` has been populated.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the metadata for the model.\n     *\n     * @resource [Trainedmodels: get API Documentation]{@link https://cloud.google.com/prediction/docs/reference/v1.6/trainedmodels/get}\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An API error.\n     * @param {?object} callback.metadata - Metadata of the model from the API.\n     * @param {object} callback.apiResponse - Raw API response.\n     *\n     * @example\n     * model.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true,\n\n    /**\n     * Sets the metadata of the Model object.\n     *\n     * NOTE: What you probably want is {module:prediction/model#train}, which\n     * wraps this method.\n     *\n     * @resource [Trainedmodels: update API Documentation]{@link https://cloud.google.com/prediction/docs/reference/v1.6/trainedmodels/update}\n     *\n     * @param {object} metadata - Metadata to save on the Model.\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * var metadata = {\n     *   output: 'english',\n     *   csvInstance: [\n     *     'Hello, this is an English sentence!'\n     *   ]\n     * };\n     *\n     * model.setMetadata(metadata, function(err, apiResponse) {});\n     */\n    setMetadata: {\n      reqOpts: {\n        method: 'PUT'\n      }\n    }\n  };\n\n  ServiceObject.call(this, {\n    parent: prediction,\n    baseUrl: '/trainedmodels',\n    id: id,\n    createMethod: prediction.createModel.bind(prediction),\n    methods: methods\n  });\n}\n\nnodeutil.inherits(Model, ServiceObject);\n\n/**\n * Get an analysis of the model and the data it was trained on.\n *\n * @resource [Trainedmodels: analyze API Documentation]{@link https://cloud.google.com/prediction/docs/reference/v1.6/trainedmodels/analyze}\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?object} callback.analysis - The results of the analysis. See a\n *     [Trainedmodels: analyze response object](https://cloud.google.com/prediction/docs/reference/v1.6/trainedmodels/analyze#response).\n * @param {object} callback.analysis.data - Analysis of the data stored in this\n *     model.\n * @param {object} callback.analysis.model - Analysis of the model.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * model.analyze(function(err, analysis, apiResponse) {\n *   if (!err) {\n *     // `analysis.data` == {...}\n *     // `analysis.model` == {...}\n *   }\n * });\n */\nModel.prototype.analyze = function(callback) {\n  this.request({\n    uri: '/analyze'\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var analysis = {\n      data: resp.dataDescription || {},\n      model: resp.modelDescription || {}\n    };\n\n    callback(null, analysis, resp);\n  });\n};\n\n/**\n * Create a writable stream to train the model with new data.\n *\n * This is a wrapper around {module:prediction/model#train}.\n *\n * @param {string|number} label - The output value, either a regression or class\n *     label.\n * @return {WritableStream}\n *\n * @example\n * var stream = model.createWriteStream('english');\n *\n * stream\n *   .on('error', function(err) {\n *     // Uh oh, an error occurred!\n *   })\n *   .on('finish', function() {\n *     // The model will now be processing the new data.\n *   });\n *\n * stream.write('Hello, this is an English sentence!');\n * stream.write('...yeah, I assumed that when I was able to read it.');\n * stream.end();\n */\nModel.prototype.createWriteStream = function(label) {\n  var self = this;\n  var writeStream = streamEvents(pumpify());\n\n  writeStream.once('writing', function() {\n    var template = JSON.stringify({\n      output: label,\n      csvInstance: [[]]\n    }).split('[]');\n\n    var requestStream = self.request({\n      method: 'PUT',\n      uri: '',\n      headers: {\n        accept: 'application/json',\n        'content-type': 'application/json'\n      }\n    });\n\n    requestStream\n      .on('response', function(resp) {\n        writeStream.emit('response', resp);\n      })\n      .on('prefinish', function() {\n        writeStream.cork();\n      })\n      .on('complete', function(resp) {\n        util.handleResp(null, resp, resp.body, function(err) {\n          if (err) {\n            writeStream.destroy(err);\n            return;\n          }\n\n          writeStream.uncork();\n        });\n      });\n\n    writeStream.setPipeline([\n      through({ encoding: 'utf-8' }),\n      JSONStream.stringify(template[0], ',', template[1]),\n      requestStream\n    ]);\n  });\n\n  return writeStream;\n};\n\n/**\n * Query the stored data in your model.\n *\n * @resource [Trainedmodels:predict API Documentation]{@link https://cloud.google.com/prediction/docs/reference/v1.6/trainedmodels/predict}\n *\n * @param {string|string[]} input - Input feature(s) to query on the model.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {?object} callback.results - An organized set of results from the\n *     prediction.\n * @param {string} callback.results.winner - The matching result's label.\n * @param {?object[]} callback.results.scores - Sorted from highest-to-lowest,\n *     all of the results that matched the query. This will not be present if\n *         querying a regression model.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * //-\n * // Assuming this is a model used to return a language name that matches any\n * // given input, this will ask for the prediction results of an english\n * // sentence.\n * //-\n * model.query('Hello', function(err, results) {\n *   if (!err) {\n *     // `results.winner` == 'english'\n *     // `results.scores` == [\n *     //   {\n *     //     label: 'english',\n *     //     score: 1\n *     //   },\n *     //   ...other results and their scores are listed here.\n *     // ]\n *   }\n * });\n */\nModel.prototype.query = function(input, callback) {\n  this.request({\n    method: 'POST',\n    uri: '/predict',\n    json: {\n      input: {\n        csvInstance: arrify(input)\n      }\n    }\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var results = {\n      winner: resp.outputLabel || resp.outputValue,\n    };\n\n    if (resp.outputMulti) {\n      results.scores = resp.outputMulti\n        .sort(function(a, b) {\n          return a.score < b.score ? 1 : a.score > b.score ? -1 : 0;\n        })\n        .map(function(scoreObject) {\n          scoreObject.score = parseFloat(scoreObject.score);\n          return scoreObject;\n        });\n    }\n\n    callback(null, results, resp);\n  });\n};\n\n/**\n * Update the stored data with new input.\n *\n * @resource [Trainedmodels: update API Documentation]{@link https://cloud.google.com/prediction/docs/reference/v1.6/trainedmodels/update}\n *\n * @param {string|number} label - The output value, either a regression or class\n *     label.\n * @param {string|string[]} input - The input features for this data entry.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An API error.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * model.train('english', 'Hello from Stephen!', function(err, apiResponse) {\n *   if (!err) {\n *     // New data was inserted successfully.\n *   }\n * });\n */\nModel.prototype.train = function(label, input, callback) {\n  this.setMetadata({\n    output: label,\n    csvInstance: arrify(input)\n  }, callback);\n};\n\nmodule.exports = Model;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/logging/index.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module logging\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar extend = require('extend');\nvar format = require('string-format-obj');\nvar googleProtoFiles = require('google-proto-files');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:storage/bucket}\n * @private\n */\nvar Bucket = require('../storage/bucket.js');\n\n/**\n * @type {module:bigquery/dataset}\n * @private\n */\nvar Dataset = require('../bigquery/dataset.js');\n\n/**\n * @type {module:logging/entry}\n * @private\n */\nvar Entry = require('./entry.js');\n\n/**\n * @type {module:common/grpc-service}\n * @private\n */\nvar GrpcService = require('../common/grpc-service.js');\n\n/**\n * @type {module:logging/log}\n * @private\n */\nvar Log = require('./log.js');\n\n/**\n * @type {module:logging/sink}\n * @private\n */\nvar Sink = require('./sink.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:pubsub/topic}\n * @private\n */\nvar Topic = require('../pubsub/topic.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * [Google Cloud Logging](https://cloud.google.com/logging/docs) collects and\n * stores logs from applications and services on the Google Cloud Platform:\n *\n *   - Export your logs to Google Cloud Storage, Google BigQuery, or Google\n *     Cloud Pub/Sub.\n *   - Integrate third-party logs from your virtual machine instances by\n *     installing the logging agent, `google-fluentd`.\n *\n * @alias module:logging\n * @constructor\n *\n * @classdesc\n * <p class=\"notice\">\n *   **This is a Beta release of Google Cloud Logging.** This API is not covered\n *   by any SLA or deprecation policy and may be subject to\n *   backward-incompatible changes.\n * </p>\n *\n * The `gcloud.logging` method will return a `logging` object, allowing you to\n * create sinks, write log entries, and more.\n *\n * To learn more about Logging, see the\n * [What is Google Cloud Logging?](https://cloud.google.com/logging/docs)\n *\n * @resource [What is Google Cloud Logging?]{@link https://cloud.google.com/logging/docs}\n * @resource [Introduction to the Cloud Logging API]{@link https://cloud.google.com/logging/docs/api}\n *\n * @param {object} options - [Configuration object](#/docs).\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var logging = gcloud.logging();\n */\nfunction Logging(options) {\n  if (!(this instanceof Logging)) {\n    options = util.normalizeArguments(this, options);\n    return new Logging(options);\n  }\n\n  var config = {\n    baseUrl: 'logging.googleapis.com',\n    service: 'logging',\n    apiVersion: 'v2',\n    protoServices: {\n      ConfigServiceV2:\n        googleProtoFiles('logging', 'v2', 'logging_config.proto'),\n      LoggingServiceV2: googleProtoFiles.logging.v2\n    },\n    scopes: [\n      'https://www.googleapis.com/auth/cloud-platform'\n    ]\n  };\n\n  GrpcService.call(this, config, options);\n}\n\nnodeutil.inherits(Logging, GrpcService);\n\n// jscs:disable maximumLineLength\n/**\n * Create a sink.\n *\n * @resource [Sink Overview]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.sinks}\n * @resource [Advanced Logs Filters]{@link https://cloud.google.com/logging/docs/view/advanced_filters}\n * @resource [projects.sinks.create API Documentation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.sinks/create}\n *\n * @throws {Error} if a name is not provided.\n * @throws {Error} if a config object is not provided.\n *\n * @param {string} name - Name of the sink.\n * @param {object} config - See a\n *     [Sink resource](https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.sinks#LogSink).\n * @param {module:storage/bucket|module:bigquery/dataset|module:pubsub/topic} config.destination -\n *     The destination. The proper ACL scopes will be granted to the provided\n *     destination.\n * @param {string=} config.filter - An advanced logs filter. Only log entries\n *     matching the filter are written.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:logging/sink} callback.sink - The created Sink object.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var gcs = gcloud.storage();\n *\n * var config = {\n *   destination: gcs.bucket('logging-bucket'),\n *   filter: 'severity = ALERT'\n * };\n *\n * function callback(err, sink, apiResponse) {\n *   // `sink` is a Sink object.\n * }\n *\n * logging.createSink('new-sink-name', config, callback);\n */\nLogging.prototype.createSink = function(name, config, callback) {\n  // jscs:enable maximumLineLength\n  var self = this;\n\n  if (!is.string(name)) {\n    throw new Error('A sink name must be provided.');\n  }\n\n  if (!is.object(config)) {\n    throw new Error('A sink configuration object must be provided.');\n  }\n\n  if (config.destination instanceof Bucket) {\n    this.setAclForBucket_(name, config, callback);\n    return;\n  }\n\n  if (config.destination instanceof Dataset) {\n    this.setAclForDataset_(name, config, callback);\n    return;\n  }\n\n  if (config.destination instanceof Topic) {\n    this.setAclForTopic_(name, config, callback);\n    return;\n  }\n\n  var protoOpts = {\n    service: 'ConfigServiceV2',\n    method: 'createSink'\n  };\n\n  var reqOpts = {\n    parent: 'projects/' + this.projectId,\n    sink: extend({}, config, { name: name })\n  };\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var sink = self.sink(resp.name);\n    sink.metadata = resp;\n\n    callback(null, sink, resp);\n  });\n};\n\n/**\n * Create an entry object.\n *\n * Note that using this method will not itself make any API requests. You will\n * use the object returned in other API calls, such as\n * {module:logging/log#write}.\n *\n * @resource [LogEntry JSON representation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/LogEntry}\n *\n * @param {object=|string=} resource - See a\n *     [Monitored Resource](https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/MonitoredResource).\n * @param {object|string} data - The data to use as the value for this log\n *     entry.\n * @return {module:logging/entry}\n *\n * @example\n * var resource = {\n *   type: 'gce_instance',\n *   labels: {\n *     zone: 'global',\n *     instance_id: '3'\n *   }\n * };\n *\n * var entry = logging.entry(resource, {\n *   delegate: 'my_username'\n * });\n *\n * entry.toJSON();\n * // {\n * //   resource: {\n * //     type: 'gce_instance',\n * //     labels: {\n * //       zone: 'global',\n * //       instance_id: '3'\n * //     }\n * //   },\n * //   jsonPayload: {\n * //     delegate: 'my_username'\n * //   }\n * // }\n */\nLogging.prototype.entry = function(resource, data) {\n  return new Entry(resource, data);\n};\n\n/**\n * List the entries in your logs.\n *\n * @resource [entries.list API Documentation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/entries/list}\n *\n * @param {object=} options - Filtering options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - An\n *     [advanced logs filter](https://cloud.google.com/logging/docs/view/advanced_filters).\n *     An empty filter matches all log entries.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of results to return.\n * @param {string} options.orderBy - How the results should be sorted,\n *     `timestamp` (oldest first) and `timestamp desc` (newest first,\n *     **default**).\n * @param {number} options.pageSize - Maximum number of logs to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:logging/entry[]} callback.entries - Entries from your logs.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * logging.getEntries(function(err, entries) {\n *   // `entries` is an array of Cloud Logging entry objects.\n *   // See the `data` property to read the data from the entry.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, entries, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     logging.getEntries(nextQuery, callback);\n *   }\n * }\n *\n * logging.getEntries({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the entries from your project as a readable object stream.\n * //-\n * logging.getEntries()\n *   .on('error', console.error)\n *   .on('data', function(entry) {\n *     // `entry` is a Cloud Logging entry object.\n *     // See the `data` property to read the data from the entry.\n *   })\n *   .on('end', function() {\n *     // All entries retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * logging.getEntries()\n *   .on('data', function(entry) {\n *     this.end();\n *   });\n */\nLogging.prototype.getEntries = function(options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var protoOpts = {\n    service: 'LoggingServiceV2',\n    method: 'listLogEntries'\n  };\n\n  var reqOpts = extend({\n    orderBy: 'timestamp desc'\n  }, options);\n  reqOpts.projectIds = arrify(reqOpts.projectIds);\n  reqOpts.projectIds.push(this.projectId);\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, reqOpts, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var entries = arrify(resp.entries).map(Entry.fromApiResponse_);\n\n    callback(null, entries, nextQuery, resp);\n  });\n};\n\n/**\n * Get the sinks associated with this project.\n *\n * @resource [projects.sinks.list API Documentation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.sinks/list}\n *\n * @param {object=} options - Configuration object.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of results to return.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:logging/sink[]} callback.sinks - Sink objects.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * logging.getSinks(function(err, sinks) {\n *   // sinks is an array of Sink objects.\n * });\n *\n * //-\n * // Get the sinks from your project as a readable object stream.\n * //-\n * logging.getSinks()\n *   .on('error', console.error)\n *   .on('data', function(sink) {\n *     // `sink` is a Sink object.\n *   })\n *   .on('end', function() {\n *     // All sinks retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * logging.getSinks()\n *   .on('data', function(sink) {\n *     this.end();\n *   });\n */\nLogging.prototype.getSinks = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var protoOpts = {\n    service: 'ConfigServiceV2',\n    method: 'listSinks'\n  };\n\n  var reqOpts = extend({}, options, {\n    parent: 'projects/' + this.projectId\n  });\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var sinks = arrify(resp.sinks).map(function(sink) {\n      var sinkInstance = self.sink(sink.name);\n      sinkInstance.metadata = sink;\n      return sinkInstance;\n    });\n\n    callback(null, sinks, nextQuery, resp);\n  });\n};\n\n/**\n * Get a reference to a Cloud Logging log.\n *\n * @resource [Log Overview]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.logs}\n *\n * @param {string} name - Name of the existing log.\n * @return {module:logging/log}\n *\n * @example\n * var log = logging.log('my-log');\n */\nLogging.prototype.log = function(name) {\n  return new Log(this, name);\n};\n\n/**\n * Get a reference to a Cloud Logging sink.\n *\n * @resource [Sink Overview]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.sinks}\n *\n * @param {string} name - Name of the existing sink.\n * @return {module:logging/sink}\n *\n * @example\n * var sink = logging.sink('my-sink');\n */\nLogging.prototype.sink = function(name) {\n  return new Sink(this, name);\n};\n\n/**\n * This method is called when creating a sink with a Bucket destination. The\n * bucket must first grant proper ACL access to the Cloud Logging account.\n *\n * The parameters are the same as what {module:logging#createSink} accepts.\n *\n * @private\n */\nLogging.prototype.setAclForBucket_ = function(name, config, callback) {\n  var self = this;\n  var bucket = config.destination;\n\n  bucket.acl.owners.addGroup('cloud-logs@google.com', function(err, apiResp) {\n    if (err) {\n      callback(err, null, apiResp);\n      return;\n    }\n\n    config.destination = 'storage.googleapis.com/' + bucket.name;\n\n    self.createSink(name, config, callback);\n  });\n};\n\n/**\n * This method is called when creating a sink with a Dataset destination. The\n * dataset must first grant proper ACL access to the Cloud Logging account.\n *\n * The parameters are the same as what {module:logging#createSink} accepts.\n *\n * @private\n */\nLogging.prototype.setAclForDataset_ = function(name, config, callback) {\n  var self = this;\n  var dataset = config.destination;\n\n  dataset.getMetadata(function(err, metadata, apiResp) {\n    if (err) {\n      callback(err, null, apiResp);\n      return;\n    }\n\n    var access = [].slice.call(arrify(metadata.access));\n\n    access.push({\n      role: 'WRITER',\n      groupByEmail: 'cloud-logs@google.com'\n    });\n\n    dataset.setMetadata({\n      access: access\n    }, function(err, apiResp) {\n      if (err) {\n        callback(err, null, apiResp);\n        return;\n      }\n\n      config.destination = format('{baseUrl}/projects/{pId}/datasets/{dId}', {\n        baseUrl: 'bigquery.googleapis.com',\n        pId: dataset.parent.projectId,\n        dId: dataset.id\n      });\n\n      self.createSink(name, config, callback);\n    });\n  });\n};\n\n/**\n * This method is called when creating a sink with a Topic destination. The\n * topic must first grant proper ACL access to the Cloud Logging account.\n *\n * The parameters are the same as what {module:logging#createSink} accepts.\n *\n * @private\n */\nLogging.prototype.setAclForTopic_ = function(name, config, callback) {\n  var self = this;\n  var topic = config.destination;\n\n  topic.iam.getPolicy(function(err, policy, apiResp) {\n    if (err) {\n      callback(err, null, apiResp);\n      return;\n    }\n\n    policy.bindings = arrify(policy.bindings);\n\n    policy.bindings.push({\n      role: 'roles/pubsub.publisher',\n      members: [\n        'serviceAccount:cloud-logs@system.gserviceaccount.com'\n      ]\n    });\n\n    topic.iam.setPolicy(policy, function(err, policy, apiResp) {\n      if (err) {\n        callback(err, null, apiResp);\n        return;\n      }\n\n      config.destination = format('{baseUrl}/{topicName}', {\n        baseUrl: 'pubsub.googleapis.com',\n        topicName: topic.name\n      });\n\n      self.createSink(name, config, callback);\n    });\n  });\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(Logging, ['getEntries', 'getSinks']);\n\nmodule.exports = Logging;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/storage/bucket.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module storage/bucket\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar async = require('async');\nvar extend = require('extend');\nvar fs = require('fs');\nvar is = require('is');\nvar mime = require('mime-types');\nvar nodeutil = require('util');\nvar path = require('path');\n\n/**\n * @type {module:storage/acl}\n * @private\n */\nvar Acl = require('./acl.js');\n\n/**\n * @type {module:storage/file}\n * @private\n */\nvar File = require('./file.js');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * The size of a file (in bytes) must be greater than this number to\n * automatically trigger a resumable upload.\n *\n * @const {number}\n * @private\n */\nvar RESUMABLE_THRESHOLD = 5000000;\n\n/**\n * Create a Bucket object to interact with a Google Cloud Storage bucket.\n *\n * @constructor\n * @alias module:storage/bucket\n *\n * @param {object} options - Configuration options.\n * @param {string} options.bucketName - Name of the bucket.\n * @param {string=} options.keyFilename - Full path to the JSON key downloaded\n *     from the Google Developers Console. Alternatively, you may provide a\n *     `credentials` object.\n * @param {object=} options.credentials - Credentials object, used in place of\n *     a `keyFilename`.\n *\n * @example\n * var gcloud = require('gcloud');\n *\n * var gcs = gcloud.storage({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var bucket = gcs.bucket('albums');\n */\nfunction Bucket(storage, name) {\n  var methods = {\n    /**\n     * Create a bucket.\n     *\n     * @param {object=} config - See {module:storage#createBucket}.\n     *\n     * @example\n     * bucket.create(function(err, zone, apiResponse) {\n     *   if (!err) {\n     *     // The zone was created successfully.\n     *   }\n     * });\n     */\n    create: true,\n\n    /**\n     * Delete the bucket.\n     *\n     * @resource [Buckets: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/delete}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * bucket.delete(function(err, apiResponse) {});\n     */\n    delete: true,\n\n    /**\n     * Check if the bucket exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the bucket exists or not.\n     *\n     * @example\n     * bucket.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a bucket if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * bucket.get(function(err, bucket, apiResponse) {\n     *   // `bucket.metadata` has been populated.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the bucket's metadata.\n     *\n     * To set metadata, see {module:storage/bucket#setMetadata}.\n     *\n     * @resource [Buckets: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The bucket's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * bucket.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true,\n\n    /**\n     * Set the bucket's metadata.\n     *\n     * @resource [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n     *\n     * @param {object} metadata - The metadata you wish to set.\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * //-\n     * // Set website metadata field on the bucket.\n     * //-\n     * bucket.setMetadata({\n     *   website: {\n     *     mainPageSuffix: 'http://example.com',\n     *     notFoundPage: 'http://example.com/404.html'\n     *   }\n     * }, function(err, apiResponse) {});\n     *\n     * //-\n     * // Enable versioning for your bucket.\n     * //-\n     * bucket.setMetadata({\n     *   versioning: {\n     *     enabled: true\n     *   }\n     * }, function(err, apiResponse) {});\n     */\n    setMetadata: true\n  };\n\n  ServiceObject.call(this, {\n    parent: storage,\n    baseUrl: '/b',\n    id: name,\n    createMethod: storage.createBucket.bind(storage),\n    methods: methods\n  });\n\n  this.name = name;\n  this.storage = storage;\n\n  /**\n   * Google Cloud Storage uses access control lists (ACLs) to manage object and\n   * bucket access. ACLs are the mechanism you use to share objects with other\n   * users and allow other users to access your buckets and objects.\n   *\n   * An ACL consists of one or more entries, where each entry grants permissions\n   * to an entity. Permissions define the actions that can be performed against\n   * an object or bucket (for example, `READ` or `WRITE`); the entity defines\n   * who the permission applies to (for example, a specific user or group of\n   * users).\n   *\n   * The `acl` object on a Bucket instance provides methods to get you a list of\n   * the ACLs defined on your bucket, as well as set, update, and delete them.\n   *\n   * Buckets also have\n   * [default ACLs](https://cloud.google.com/storage/docs/accesscontrol#default)\n   * for all created files. Default ACLs specify permissions that all new\n   * objects added to the bucket will inherit by default. You can add, delete,\n   * get, and update entities and permissions for these as well with\n   * {module:storage/bucket#acl.default}.\n   *\n   * @resource [About Access Control Lists]{@link http://goo.gl/6qBBPO}\n   * @resource [Default ACLs]{@link https://cloud.google.com/storage/docs/accesscontrol#default}\n   *\n   * @mixes module:storage/acl\n   *\n   * @example\n   * //-\n   * // Make a bucket's contents publicly readable.\n   * //-\n   * var myBucket = gcs.bucket('my-bucket');\n   * myBucket.acl.add({\n   *   entity: 'allUsers',\n   *   role: gcs.acl.READER_ROLE\n   * }, function(err, aclObject) {});\n   */\n  this.acl = new Acl({\n    request: this.request.bind(this),\n    pathPrefix: '/acl'\n  });\n\n  /**\n   * Google Cloud Storage Buckets have [default ACLs](http://goo.gl/YpGdyv) for\n   * all created files. You can add, delete, get, and update entities and\n   * permissions for these as well. The method signatures and examples are all\n   * the same, after only prefixing the method call with `default`.\n   *\n   * @mixes module:storage/acl\n   * @alias acl.default\n   */\n  this.acl.default = new Acl({\n    request: this.request.bind(this),\n    pathPrefix: '/defaultObjectAcl'\n  });\n}\n\nnodeutil.inherits(Bucket, ServiceObject);\n\n/**\n * Combine multiple files into one new file.\n *\n * @resource [Objects: compose API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/compose}\n *\n * @throws {Error} if a non-array is provided as sources argument.\n * @throws {Error} if less than two sources are provided.\n * @throws {Error} if no destination is provided.\n * @throws {Error} if content type can't be determined for the destination file.\n *\n * @param {string[]|module:storage/file} sources - The source files that will be\n *     combined.\n * @param {string|module:storage/file} destination - The file you would like the\n *     source files combined into.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:storage/file} callback.newFile - The combined file.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var logBucket = gcs.bucket('log-bucket');\n *\n * var logs2013 = logBucket.file('2013-logs.txt');\n * var logs2014 = logBucket.file('2014-logs.txt');\n *\n * var allLogs = logBucket.file('all-logs.txt');\n *\n * logBucket.combine([\n *   logs2013,\n *   logs2014\n * ], allLogs, function(err, newFile, apiResponse) {\n *   // newFile === allLogs\n * });\n */\nBucket.prototype.combine = function(sources, destination, callback) {\n  if (!is.array(sources) || sources.length < 2) {\n    throw new Error('You must provide at least two source files.');\n  }\n\n  if (!destination) {\n    throw new Error('A destination file must be specified.');\n  }\n\n  var self = this;\n\n  sources = sources.map(convertToFile);\n  destination = convertToFile(destination);\n  callback = callback || util.noop;\n\n  if (!destination.metadata.contentType) {\n    var destinationContentType = mime.contentType(destination.name);\n\n    if (destinationContentType) {\n      destination.metadata.contentType = destinationContentType;\n    } else {\n      throw new Error(\n        'A content type could not be detected for the destination file.');\n    }\n  }\n\n  // Make the request from the destination File object.\n  destination.request({\n    method: 'POST',\n    uri: '/compose',\n    json: {\n      destination: {\n        contentType: destination.metadata.contentType\n      },\n      sourceObjects: sources.map(function(source) {\n        var sourceObject = {\n          name: source.name\n        };\n\n        if (source.metadata && source.metadata.generation) {\n          sourceObject.generation = source.metadata.generation;\n        }\n\n        return sourceObject;\n      })\n    }\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    callback(null, destination, resp);\n  });\n\n  function convertToFile(file) {\n    if (file instanceof File) {\n      return file;\n    }\n\n    return self.file(file);\n  }\n};\n\n/**\n * Create a channel that will be notified when objects in this bucket changes.\n *\n * @throws {Error} If an ID is not provided.\n * @throws {Error} If an address is not provided.\n *\n * @resource [Objects: watchAll API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll}\n *\n * @param {string} id - The ID of the channel to create.\n * @param {object} config - See a\n *     [Objects: watchAll request body](https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll).\n * @param {string} config.address - The address where notifications are\n *     delivered for this channel.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:storage/channel} callback.channel - The created Channel\n *     object.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var id = 'new-channel-id';\n *\n * var config = {\n *   address: 'https://...'\n * };\n *\n * bucket.createChannel(id, config, function(err, channel, apiResponse) {\n *   if (!err) {\n *     // Channel created successfully.\n *   }\n * });\n */\nBucket.prototype.createChannel = function(id, config, callback) {\n  var self = this;\n\n  if (!is.string(id)) {\n    throw new Error('An ID is required to create a channel.');\n  }\n\n  if (!is.string(config.address)) {\n    throw new Error('An address is required to create a channel.');\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/o/watch',\n    json: extend({\n      id: id,\n      type: 'web_hook'\n    }, config)\n  }, function(err, apiResponse) {\n    if (err) {\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    var resourceId = apiResponse.resourceId;\n    var channel = self.storage.channel(id, resourceId);\n\n    channel.metadata = apiResponse;\n\n    callback(null, channel, apiResponse);\n  });\n};\n\n/**\n * Iterate over the bucket's files, calling `file.delete()` on each.\n *\n * <strong>This is not an atomic request.</strong> A delete attempt will be made\n * for each file individually. Any one can fail, in which case only a portion of\n * the files you intended to be deleted would have.\n *\n * Operations are performed in parallel, up to 10 at once. The first error\n * breaks the loop and will execute the provided callback with it. Specify\n * `{ force: true }` to suppress the errors until all files have had a chance to\n * be processed.\n *\n * The `query` object passed as the first argument will also be passed to\n * {module:storage/bucket#getFiles}.\n *\n * @resource [Objects: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/delete}\n *\n * @param {object=} query - Query object. See {module:storage/bucket#getFiles}\n *     for all of the supported properties.\n * @param {boolean} query.force - Suppress errors until all files have been\n *     processed.\n * @param {function} callback - The callback function.\n * @param {?error|?error[]} callback.err - An API error or array of errors from\n *     files that were not able to be deleted.\n *\n * @example\n * //-\n * // Delete all of the files in the bucket.\n * //-\n * bucket.deleteFiles(function(err) {});\n *\n * //-\n * // By default, if a file cannot be deleted, this method will stop deleting\n * // files from your bucket. You can override this setting with `force: true`.\n * //-\n * bucket.deleteFiles({\n *   force: true\n * }, function(errors) {\n *   // `errors`:\n *   //    Array of errors if any occurred, otherwise null.\n * });\n *\n * //-\n * // The first argument to this method acts as a query to\n * // {module:storage/bucket#getFiles}. As an example, you can delete files\n * // which match a prefix.\n * //-\n * bucket.deleteFiles({\n *   prefix: 'images/'\n * }, function(err) {\n *   if (!err) {\n *     // All files in the `images` directory have been deleted.\n *   }\n * });\n */\nBucket.prototype.deleteFiles = function(query, callback) {\n  if (is.fn(query)) {\n    callback = query;\n    query = {};\n  }\n\n  query = query || {};\n\n  var MAX_PARALLEL_LIMIT = 10;\n  var errors = [];\n\n  this.getFiles(query, function(err, files) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    function deleteFile(file, callback) {\n      file.delete(function(err) {\n        if (err) {\n          if (query.force) {\n            errors.push(err);\n            callback();\n            return;\n          }\n\n          callback(err);\n          return;\n        }\n\n        callback();\n      });\n    }\n\n    // Iterate through each file and attempt to delete it.\n    async.eachLimit(files, MAX_PARALLEL_LIMIT, deleteFile, function(err) {\n      if (err || errors.length > 0) {\n        callback(err || errors);\n        return;\n      }\n\n      callback();\n    });\n  });\n};\n\n/**\n * Create a File object. See {module:storage/file} to see how to handle\n * the different use cases you may have.\n *\n * @param {string} name - The name of the file in this bucket.\n * @param {object=} options - Configuration options.\n * @param {string|number} options.generation - Only use a specific revision of\n *     this file.\n * @param {string} options.key - A custom encryption key. See\n *     [Customer-supplied Encryption Keys](https://cloud.google.com/storage/docs/encryption#customer-supplied).\n * @return {module:storage/file}\n *\n * @example\n * var file = bucket.file('my-existing-file.png');\n */\nBucket.prototype.file = function(name, options) {\n  if (!name) {\n    throw Error('A file name must be specified.');\n  }\n\n  return new File(this, name, options);\n};\n\n/**\n * Get File objects for the files currently in the bucket.\n *\n * @resource [Objects: list API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/list}\n *\n * @param {object=} query - Query object.\n * @param {boolean} query.autoPaginate - Have pagination handled automatically.\n *     Default: true.\n * @param {string} query.delimiter - Results will contain only objects whose\n *     names, aside from the prefix, do not contain delimiter. Objects whose\n *     names, aside from the prefix, contain delimiter will have their name\n *     truncated after the delimiter, returned in `apiResponse.prefixes`.\n *     Duplicate prefixes are omitted.\n * @param {string} query.prefix - Filter results to objects whose names begin\n *     with this prefix.\n * @param {number} query.maxApiCalls - Maximum number of API calls to make.\n * @param {number} query.maxResults - Maximum number of items plus prefixes to\n *     return.\n * @param {string} query.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {boolean} query.versions - If true, returns File objects scoped to\n *     their versions.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:storage/file[]} callback.files - List of files.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * bucket.getFiles(function(err, files) {\n *   if (!err) {\n *     // files is an array of File objects.\n *   }\n * });\n *\n * //-\n * // If your bucket has versioning enabled, you can get all of your files\n * // scoped to their generation.\n * //-\n * bucket.getFiles({\n *   versions: true\n * }, function(err, files) {\n *   // Each file is scoped to its generation.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * var callback = function(err, files, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     bucket.getFiles(nextQuery, callback);\n *   }\n *\n *   // The `metadata` property is populated for you with the metadata at the\n *   // time of fetching.\n *   files[0].metadata;\n *\n *   // However, in cases where you are concerned the metadata could have\n *   // changed, use the `getMetadata` method.\n *   files[0].getMetadata(function(err, metadata) {});\n * };\n *\n * bucket.getFiles({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the files from your bucket as a readable object stream.\n * //-\n * bucket.getFiles()\n *   .on('error', console.error)\n *   .on('data', function(file) {\n *     // file is a File object.\n *   })\n *   .on('end', function() {\n *     // All files retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * bucket.getFiles()\n *   .on('data', function(file) {\n *     this.end();\n *   });\n */\nBucket.prototype.getFiles = function(query, callback) {\n  var self = this;\n\n  if (!callback) {\n    callback = query;\n    query = {};\n  }\n\n  this.request({\n    uri: '/o',\n    qs: query\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var files = arrify(resp.items).map(function(file) {\n      var options = {};\n\n      if (query.versions) {\n        options.generation = file.generation;\n      }\n\n      var fileInstance = self.file(file.name, options);\n      fileInstance.metadata = file;\n\n      return fileInstance;\n    });\n\n    var nextQuery = null;\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, query, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    callback(null, files, nextQuery, resp);\n  });\n};\n\n/**\n * Make the bucket listing private.\n *\n * You may also choose to make the contents of the bucket private by specifying\n * `includeFiles: true`. This will automatically run\n * {module:storage/file#makePrivate} for every file in the bucket.\n *\n * When specifying `includeFiles: true`, use `force: true` to delay execution of\n * your callback until all files have been processed. By default, the callback\n * is executed after the first error. Use `force` to queue such errors until all\n * files have been processed, after which they will be returned as an array as\n * the first argument to your callback.\n *\n * NOTE: This may cause the process to be long-running and use a high number of\n * requests. Use with caution.\n *\n * @resource [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n *\n * @param {object=} options - The configuration object.\n * @param {boolean} options.includeFiles - Make each file in the bucket private.\n *     Default: `false`.\n * @param {boolean} options.force - Queue errors occurred while making files\n *     private until all files have been processed.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:storage/file[]} callback.files - List of files made private.\n *\n * @example\n * //-\n * // Make the bucket private.\n * //-\n * bucket.makePrivate(function(err) {});\n *\n * //-\n * // Make the bucket and its contents private.\n * //-\n * var opts = {\n *   includeFiles: true\n * };\n *\n * bucket.makePrivate(opts, function(err, files) {\n *   // `err`:\n *   //    The first error to occur, otherwise null.\n *   //\n *   // `files`:\n *   //    Array of files successfully made private in the bucket.\n * });\n *\n * //-\n * // Make the bucket and its contents private, using force to suppress errors\n * // until all files have been processed.\n * //-\n * var opts = {\n *   includeFiles: true,\n *   force: true\n * };\n *\n * bucket.makePrivate(opts, function(errors, files) {\n *   // `errors`:\n *   //    Array of errors if any occurred, otherwise null.\n *   //\n *   // `files`:\n *   //    Array of files successfully made private in the bucket.\n * });\n */\nBucket.prototype.makePrivate = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  options.private = true;\n\n  async.series([setPredefinedAcl, makeFilesPrivate], callback);\n\n  function setPredefinedAcl(done) {\n    var query = {\n      predefinedAcl: 'projectPrivate'\n    };\n\n    // You aren't allowed to set both predefinedAcl & acl properties on a bucket\n    // so acl must explicitly be nullified.\n    var metadata = {\n      acl: null\n    };\n\n    self.request({\n      method: 'PATCH',\n      uri: '',\n      qs: query,\n      json: metadata\n    }, function(err, resp) {\n      if (err) {\n        done(err);\n        return;\n      }\n\n      self.metadata = resp;\n\n      done();\n    });\n  }\n\n  function makeFilesPrivate(done) {\n    if (!options.includeFiles) {\n      done();\n      return;\n    }\n\n    self.makeAllFilesPublicPrivate_(options, done);\n  }\n};\n\n/**\n * Make the bucket publicly readable.\n *\n * You may also choose to make the contents of the bucket publicly readable by\n * specifying `includeFiles: true`. This will automatically run\n * {module:storage/file#makePublic} for every file in the bucket.\n *\n * When specifying `includeFiles: true`, use `force: true` to delay execution of\n * your callback until all files have been processed. By default, the callback\n * is executed after the first error. Use `force` to queue such errors until all\n * files have been processed, after which they will be returned as an array as\n * the first argument to your callback.\n *\n * NOTE: This may cause the process to be long-running and use a high number of\n * requests. Use with caution.\n *\n * @resource [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n *\n * @param {object=} options - The configuration object.\n * @param {boolean} options.includeFiles - Make each file in the bucket publicly\n *     readable. Default: `false`.\n * @param {boolean} options.force - Queue errors occurred while making files\n *     public until all files have been processed.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:storage/file[]} callback.files - List of files made public.\n *\n * @example\n * //-\n * // Make the bucket publicly readable.\n * //-\n * bucket.makePublic(function(err) {});\n *\n * //-\n * // Make the bucket and its contents publicly readable.\n * //-\n * var opts = {\n *   includeFiles: true\n * };\n *\n * bucket.makePublic(opts, function(err, files) {\n *   // `err`:\n *   //    The first error to occur, otherwise null.\n *   //\n *   // `files`:\n *   //    Array of files successfully made public in the bucket.\n * });\n *\n * //-\n * // Make the bucket and its contents publicly readable, using force to\n * // suppress errors until all files have been processed.\n * //-\n * var opts = {\n *   includeFiles: true,\n *   force: true\n * };\n *\n * bucket.makePublic(opts, function(errors, files) {\n *   // `errors`:\n *   //    Array of errors if any occurred, otherwise null.\n *   //\n *   // `files`:\n *   //    Array of files successfully made public in the bucket.\n * });\n */\nBucket.prototype.makePublic = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  options.public = true;\n\n  async.series([\n    addAclPermissions,\n    addDefaultAclPermissions,\n    makeFilesPublic\n  ], callback);\n\n  function addAclPermissions(done) {\n    // Allow reading bucket contents while preserving original permissions.\n    self.acl.add({\n      entity: 'allUsers',\n      role: 'READER'\n    }, done);\n  }\n\n  function addDefaultAclPermissions(done) {\n    self.acl.default.add({\n      entity: 'allUsers',\n      role: 'READER'\n    }, done);\n  }\n\n  function makeFilesPublic(done) {\n    if (!options.includeFiles) {\n      done();\n      return;\n    }\n\n    self.makeAllFilesPublicPrivate_(options, done);\n  }\n};\n\n/**\n * Upload a file to the bucket. This is a convenience method that wraps\n * {module:storage/file#createWriteStream}.\n *\n * You can specify whether or not an upload is resumable by setting\n * `options.resumable`. *Resumable uploads are enabled by default if your input\n * file is larger than 5 MB.*\n *\n * For faster crc32c computation, you must manually install\n * [`fast-crc32c`](http://www.gitnpm.com/fast-crc32c):\n *\n *     $ npm install --save fast-crc32c\n *\n * @resource [Upload Options (Simple or Resumable)]{@link https://cloud.google.com/storage/docs/json_api/v1/how-tos/upload#uploads}\n * @resource [Objects: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/insert}\n *\n * @param {string} localPath - The fully qualified path to the file you wish to\n *     upload to your bucket.\n * @param {object=} options - Configuration options.\n * @param {string|module:storage/file} options.destination - The place to save\n *     your file. If given a string, the file will be uploaded to the bucket\n *     using the string as a filename. When given a File object, your local file\n *     will be uploaded to the File object's bucket and under the File object's\n *     name. Lastly, when this argument is omitted, the file is uploaded to your\n *     bucket using the name of the local file.\n * @param {string} options.encryptionKey - A custom encryption key. See\n *     [Customer-supplied Encryption Keys](https://cloud.google.com/storage/docs/encryption#customer-supplied).\n * @param {boolean} options.gzip - Automatically gzip the file. This will set\n *     `options.metadata.contentEncoding` to `gzip`.\n * @param {object} options.metadata - See an\n *     [Objects: insert request body](https://cloud.google.com/storage/docs/json_api/v1/objects/insert#request_properties_JSON).\n * @param {string} options.offset - The starting byte of the upload stream, for\n *     resuming an interrupted upload. Defaults to 0.\n * @param {string} options.predefinedAcl - Apply a predefined set of access\n *     controls to this object.\n *\n *     Acceptable values are:\n *     - **`authenticatedRead`** - Object owner gets `OWNER` access, and\n *       `allAuthenticatedUsers` get `READER` access.\n *\n *     - **`bucketOwnerFullControl`** - Object owner gets `OWNER` access, and\n *       project team owners get `OWNER` access.\n *\n *     - **`bucketOwnerRead`** - Object owner gets `OWNER` access, and project\n *       team owners get `READER` access.\n *\n *     - **`private`** - Object owner gets `OWNER` access.\n *\n *     - **`projectPrivate`** - Object owner gets `OWNER` access, and project\n *       team members get access according to their roles.\n *\n *     - **`publicRead`** - Object owner gets `OWNER` access, and `allUsers` get\n *       `READER` access.\n * @param {boolean} options.private - Make the uploaded file private. (Alias for\n *     `options.predefinedAcl = 'private'`)\n * @param {boolean} options.public - Make the uploaded file public. (Alias for\n *     `options.predefinedAcl = 'publicRead'`)\n * @param {boolean} options.resumable - Force a resumable upload. (default:\n *     true for files larger than 5 MB).\n * @param {string} options.uri - The URI for an already-created resumable\n *     upload. See {module:storage/file#createResumableUpload}.\n * @param {string|boolean} options.validation - Possible values: `\"md5\"`,\n *     `\"crc32c\"`, or `false`. By default, data integrity is validated with an\n *     MD5 checksum for maximum reliability. CRC32c will provide better\n *     performance with less reliability. You may also choose to skip validation\n *     completely, however this is **not recommended**.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:storage/file} callback.file - The uploaded File.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // The easiest way to upload a file.\n * //-\n * bucket.upload('/local/path/image.png', function(err, file, apiResponse) {\n *   // Your bucket now contains:\n *   // - \"image.png\" (with the contents of `/local/path/image.png')\n *\n *   // `file` is an instance of a File object that refers to your new file.\n * });\n *\n * //-\n * // It's not always that easy. You will likely want to specify the filename\n * // used when your new file lands in your bucket.\n * //\n * // You may also want to set metadata or customize other options.\n * //-\n * var options = {\n *   destination: 'new-image.png',\n *   resumable: true,\n *   validation: 'crc32c',\n *   metadata: {\n *     event: 'Fall trip to the zoo'\n *   }\n * };\n *\n * bucket.upload('local-image.png', options, function(err, file) {\n *   // Your bucket now contains:\n *   // - \"new-image.png\" (with the contents of `local-image.png')\n *\n *   // `file` is an instance of a File object that refers to your new file.\n * });\n *\n * //-\n * // You can also have a file gzip'd on the fly.\n * //-\n * bucket.upload('index.html', { gzip: true }, function(err, file) {\n *   // Your bucket now contains:\n *   // - \"index.html\" (automatically compressed with gzip)\n *\n *   // Downloading the file with `file.download` will automatically decode the\n *   // file.\n * });\n *\n * //-\n * // You may also re-use a File object, {module:storage/file}, that references\n * // the file you wish to create or overwrite.\n * //-\n * var options = {\n *   destination: bucket.file('existing-file.png'),\n *   resumable: false\n * };\n *\n * bucket.upload('local-img.png', options, function(err, newFile) {\n *   // Your bucket now contains:\n *   // - \"existing-file.png\" (with the contents of `local-img.png')\n *\n *   // Note:\n *   // The `newFile` parameter is equal to `file`.\n * });\n *\n * //-\n * // To use\n * // <a href=\"https://cloud.google.com/storage/docs/encryption#customer-supplied\">\n * // Customer-supplied Encryption Keys</a>, provide the `encryptionKey` option.\n * //-\n * var crypto = require('crypto');\n * var encryptionKey = crypto.randomBytes(32);\n *\n * bucket.upload('img.png', {\n *   encryptionKey: encryptionKey\n * }, function(err, newFile) {\n *   // `img.png` was uploaded with your custom encryption key.\n *\n *   // `newFile` is already configured to use the encryption key when making\n *   // operations on the remote object.\n *\n *   // However, to use your encryption key later, you must create a `File`\n *   // instance with the `key` supplied:\n *   var file = bucket.file('img.png', {\n *     encryptionKey: encryptionKey\n *   });\n *\n *   // Or with `file#setEncryptionKey`:\n *   var file = bucket.file('img.png');\n *   file.setEncryptionKey(encryptionKey);\n * });\n */\nBucket.prototype.upload = function(localPath, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({\n    metadata: {}\n  }, options);\n\n  var newFile;\n  if (options.destination instanceof File) {\n    newFile = options.destination;\n  } else if (is.string(options.destination)) {\n    // Use the string as the name of the file.\n    newFile = this.file(options.destination, {\n      encryptionKey: options.encryptionKey\n    });\n  } else {\n    // Resort to using the name of the incoming file.\n    newFile = this.file(path.basename(localPath), {\n      encryptionKey: options.encryptionKey\n    });\n  }\n\n  var contentType = mime.contentType(path.basename(localPath));\n\n  if (contentType && !options.metadata.contentType) {\n    options.metadata.contentType = contentType;\n  }\n\n  if (is.boolean(options.resumable)) {\n    upload();\n  } else {\n    // Determine if the upload should be resumable if it's over the threshold.\n    fs.stat(localPath, function(err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      options.resumable = fd.size > RESUMABLE_THRESHOLD;\n\n      upload();\n    });\n  }\n\n  function upload() {\n    fs.createReadStream(localPath)\n      .pipe(newFile.createWriteStream(options))\n      .on('error', function(err) {\n        callback(err);\n      })\n      .on('finish', function() {\n        callback(null, newFile);\n      });\n  }\n};\n\n/**\n * Iterate over all of a bucket's files, calling `file.makePublic()` (public)\n * or `file.makePrivate()` (private) on each.\n *\n * Operations are performed in parallel, up to 10 at once. The first error\n * breaks the loop, and will execute the provided callback with it. Specify\n * `{ force: true }` to suppress the errors.\n *\n * @private\n *\n * @param {object} options - Configuration object.\n * @param {boolean} options.force - Suppress errors until all files have been\n *     processed.\n * @param {boolean} options.private - Make files private.\n * @param {boolean} options.public - Make files public.\n * @param {function} callback - The callback function.\n */\nBucket.prototype.makeAllFilesPublicPrivate_ = function(options, callback) {\n  var MAX_PARALLEL_LIMIT = 10;\n  var errors = [];\n  var updatedFiles = [];\n\n  this.getFiles(function(err, files) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    function processFile(file, callback) {\n      if (options.public) {\n        file.makePublic(processedCallback);\n      } else if (options.private) {\n        file.makePrivate(processedCallback);\n      }\n\n      function processedCallback(err) {\n        if (err) {\n          if (options.force) {\n            errors.push(err);\n            callback();\n            return;\n          }\n\n          callback(err);\n          return;\n        }\n\n        updatedFiles.push(file);\n        callback();\n      }\n    }\n\n    // Iterate through each file and make it public or private.\n    async.eachLimit(files, MAX_PARALLEL_LIMIT, processFile, function(err) {\n      if (err || errors.length > 0) {\n        callback(err || errors, updatedFiles);\n        return;\n      }\n\n      callback(null, updatedFiles);\n    });\n  });\n};\n\n/*! Developer Documentation\n *\n * This method can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(Bucket, 'getFiles');\n\nmodule.exports = Bucket;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/logging/entry.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module logging/entry\n */\n\n'use strict';\n\nvar extend = require('extend');\nvar is = require('is');\n\n/**\n * @type {module:common/grpc-service}\n * @private\n */\nvar GrpcService = require('../common/grpc-service.js');\n\n/**\n * Create an entry object to define new data to insert into a log.\n *\n * @resource [LogEntry JSON representation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/LogEntry}\n *\n * @alias module:logging/entry\n * @constructor\n *\n * @param {object=|string=} resource - See a\n *     [Monitored Resource](https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/MonitoredResource).\n * @param {object|string} data - The data to use as the value for this log\n *     entry.\n *\n *     If providing an object, these value types are supported:\n *     - `String`\n *     - `Number`\n *     - `Boolean`\n *     - `Buffer`\n *     - `Object`\n *     - `Array`\n *\n *     Any other types are stringified with `String(value)`.\n * @return {module:logging/entry}\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var logging = gcloud.logging();\n *\n * var syslog = logging.log('syslog');\n *\n * var resource = {\n *   type: 'gce_instance',\n *   labels: {\n *     zone: 'global',\n *     instance_id: '3'\n *   }\n * };\n *\n * var entry = syslog.entry(resource, {\n *   delegate: 'my_username'\n * });\n *\n * syslog.alert(entry, function(err, apiResponse) {\n *   if (!error) {\n *     // Log entry inserted successfully.\n *   }\n * });\n *\n * //-\n * // You will also receive `Entry` objects when using\n * // {module:logging#getEntries} and {module:logging/log#getEntries}.\n * //-\n * logging.getEntries(function(err, entries) {\n *   if (!err) {\n *     // entries[0].data = The data value from the log entry.\n *   }\n * });\n */\nfunction Entry(resource, data) {\n  if (!data) {\n    this.data = resource;\n    return;\n  }\n\n  this.resource = resource;\n  this.data = data;\n}\n\n/**\n * Create an Entry object from an API response, such as `entries:list`.\n *\n * @private\n *\n * @param {object} entry - An API representation of an entry. See a\n *     [LogEntry](https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/LogEntry).\n * @return {module:logging/entry}\n */\nEntry.fromApiResponse_ = function(entry) {\n  var data = entry[entry.payload];\n\n  if (entry.payload === 'jsonPayload') {\n    data = GrpcService.structToObj_(data);\n  }\n\n  var serializedEntry = extend(new Entry(entry.resource, data), entry);\n\n  if (serializedEntry.timestamp) {\n    var ms = serializedEntry.timestamp.seconds * 1000;\n    ms += serializedEntry.timestamp.nanos / 1e6;\n    serializedEntry.timestamp = new Date(ms);\n  }\n\n  return serializedEntry;\n};\n\n/**\n * Serialize an entry to the format the API expects.\n *\n * @private\n */\nEntry.prototype.toJSON = function() {\n  var entry = extend(true, {}, this);\n\n  var whitelist = [\n    'logName',\n    'resource',\n    'timestamp',\n    'severity',\n    'insertId',\n    'httpRequest',\n    'labels',\n    'operation'\n  ];\n\n  for (var prop in entry) {\n    if (whitelist.indexOf(prop) === -1) {\n      delete entry[prop];\n    }\n  }\n\n  if (is.string(this.resource)) {\n    entry.resource = {\n      type: this.resource\n    };\n  }\n\n  if (is.object(this.data)) {\n    entry.jsonPayload = GrpcService.objToStruct_(this.data, {\n      stringify: true\n    });\n  } else if (is.string(this.data)) {\n    entry.textPayload = this.data;\n  }\n\n  if (is.date(entry.timestamp)) {\n    var seconds = entry.timestamp.getTime() / 1000;\n    var secondsRounded = Math.floor(seconds);\n\n    entry.timestamp = {\n      seconds: secondsRounded,\n      nanos: Math.floor((seconds - secondsRounded) * 1e9)\n    };\n  }\n\n  return entry;\n};\n\nmodule.exports = Entry;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/logging/log.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module logging/log\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar extend = require('extend');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:logging/entry}\n * @private\n */\nvar Entry = require('./entry.js');\n\n/**\n * @type {module:common/grpc-service-object}\n * @private\n */\nvar GrpcServiceObject = require('../common/grpc-service-object.js');\n\n/**\n * A log is a named collection of entries, each entry representing a timestamped\n * event. Logs can be produced by Google Cloud Platform services, by third-party\n * services, or by your applications. For example, the log `apache-access` is\n * produced by the Apache Web Server, but the log\n * `compute.googleapis.com/activity_log` is produced by Google Compute Engine.\n *\n * @resource [Introduction to Logs]{@link https://cloud.google.com/logging/docs/api/#logs}\n *\n * @alias module:logging/log\n * @constructor\n *\n * @param {object} options - [Configuration object](#/docs).\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var logging = gcloud.logging();\n * var log = logging.log('syslog');\n */\nfunction Log(logging, name) {\n  this.formattedName_ = Log.formatName_(logging.projectId, name);\n  this.name = this.formattedName_.split('/').pop();\n\n  var methods = {\n    /**\n     * Delete the log.\n     *\n     * @resource [projects.logs.delete API Documentation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.logs/delete}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * log.delete(function(err, apiResponse) {\n     *   if (!err) {\n     *     // The log was deleted.\n     *   }\n     * });\n     */\n    delete: {\n      protoOpts: {\n        service: 'LoggingServiceV2',\n        method: 'deleteLog'\n      },\n      reqOpts: {\n        logName: this.formattedName_\n      }\n    }\n  };\n\n  GrpcServiceObject.call(this, {\n    parent: logging,\n    id: this.name,\n    methods: methods\n  });\n}\n\nnodeutil.inherits(Log, GrpcServiceObject);\n\n/**\n * Return an array of log entries with the desired severity assigned.\n *\n * @private\n *\n * @param {object|object[]} entries - Log entries.\n * @param {string} severity - The desired severity level.\n */\nLog.assignSeverityToEntries_ = function(entries, severity) {\n  return arrify(entries).map(function(entry) {\n    return extend(new Entry(), entry, {\n      severity: severity\n    });\n  });\n};\n\n/**\n * Format the name of a log. A log's full name is in the format of\n * 'projects/{projectId}/logs/{logName}'.\n *\n * @private\n *\n * @return {string}\n */\nLog.formatName_ = function(projectId, name) {\n  var path = 'projects/' + projectId + '/logs/';\n  name = name.replace(path, '');\n\n  if (decodeURIComponent(name) === name) {\n    // The name has not been encoded yet.\n    name = encodeURIComponent(name);\n  }\n\n  return path + name;\n};\n\n/**\n * Write a log entry with a severity of \"ALERT\".\n *\n * This is a simple wrapper around {module:logging/log#write}. All arguments are\n * the same as documented there.\n *\n * @example\n * var entry = log.entry('compute.googleapis.com', {\n *   user: 'my_username'\n * });\n *\n * log.alert(entry, function(err, apiResponse) {});\n */\nLog.prototype.alert = function(entry, options, callback) {\n  this.write(Log.assignSeverityToEntries_(entry, 'ALERT'), options, callback);\n};\n\n/**\n * Write a log entry with a severity of \"CRITICAL\".\n *\n * This is a simple wrapper around {module:logging/log#write}. All arguments are\n * the same as documented there.\n *\n * @example\n * var entry = log.entry('compute.googleapis.com', {\n *   user: 'my_username'\n * });\n *\n * log.critical(entry, function(err, apiResponse) {});\n */\nLog.prototype.critical = function(entry, options, callback) {\n  var entries = Log.assignSeverityToEntries_(entry, 'CRITICAL');\n  this.write(entries, options, callback);\n};\n\n/**\n * Write a log entry with a severity of \"DEBUG\".\n *\n * This is a simple wrapper around {module:logging/log#write}. All arguments are\n * the same as documented there.\n *\n * @example\n * var entry = log.entry('compute.googleapis.com', {\n *   user: 'my_username'\n * });\n *\n * log.debug(entry, function(err, apiResponse) {});\n */\nLog.prototype.debug = function(entry, options, callback) {\n  this.write(Log.assignSeverityToEntries_(entry, 'DEBUG'), options, callback);\n};\n\n/**\n * Write a log entry with a severity of \"EMERGENCY\".\n *\n * This is a simple wrapper around {module:logging/log#write}. All arguments are\n * the same as documented there.\n *\n * @example\n * var entry = log.entry('compute.googleapis.com', {\n *   user: 'my_username'\n * });\n *\n * log.emergency(entry, function(err, apiResponse) {});\n */\nLog.prototype.emergency = function(entry, options, callback) {\n  var entries = Log.assignSeverityToEntries_(entry, 'EMERGENCY');\n  this.write(entries, options, callback);\n};\n\n/**\n * Create an entry object for this log.\n *\n * Note that using this method will not itself make any API requests. You will\n * use the object returned in other API calls, such as\n * {module:logging/log#write}.\n *\n * @resource [LogEntry JSON representation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/LogEntry}\n *\n * @param {object=|string=} resource - See a\n *     [Monitored Resource](https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/MonitoredResource).\n * @param {object|string} data - The data to use as the value for this log\n *     entry.\n * @return {module:logging/entry}\n *\n * @example\n * var resource = {\n *   type: 'gce_instance',\n *   labels: {\n *     zone: 'global',\n *     instance_id: '3'\n *   }\n * };\n *\n * var entry = log.entry(resource, {\n *   delegate: 'my_username'\n * });\n *\n * entry.toJSON();\n * // {\n * //   logName: 'projects/grape-spaceship-123/logs/syslog',\n * //   resource: {\n * //     type: 'gce_instance',\n * //     labels: {\n * //       zone: 'global',\n * //       instance_id: '3'\n * //     }\n * //   },\n * //   jsonPayload: {\n * //     delegate: 'my_username'\n * //   }\n * // }\n */\nLog.prototype.entry = function(resource, data) {\n  var entryInstance = this.parent.entry(resource, data);\n  entryInstance.logName = this.formattedName_;\n  return entryInstance;\n};\n\n/**\n * Write a log entry with a severity of \"ERROR\".\n *\n * This is a simple wrapper around {module:logging/log#write}. All arguments are\n * the same as documented there.\n *\n * @example\n * var entry = log.entry('compute.googleapis.com', {\n *   user: 'my_username'\n * });\n *\n * log.error(entry, function(err, apiResponse) {});\n */\nLog.prototype.error = function(entry, options, callback) {\n  this.write(Log.assignSeverityToEntries_(entry, 'ERROR'), options, callback);\n};\n\n/**\n * This method is a wrapper around {module:logging#getEntries}, but with a\n * filter specified to only return entries from this log.\n *\n * @resource [entries.list API Documentation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/entries/list}\n *\n * @param {object=} options - Filtering options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - An\n *     [advanced logs filter](https://cloud.google.com/logging/docs/view/advanced_filters).\n *     An empty filter matches all log entries.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of results to return.\n * @param {string} options.orderBy - How the results should be sorted,\n *     `timestamp` (oldest first) and `timestamp desc` (newest first,\n *     **default**).\n * @param {number} options.pageSize - Maximum number of logs to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:logging/entry[]} callback.entries - Entries from this log.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * log.getEntries(function(err, entries) {\n *   // `entries` is an array of Cloud Logging entry objects.\n *   // See the `data` property to read the data from the entry.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, entries, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     log.getEntries(nextQuery, callback);\n *   }\n * }\n *\n * log.getEntries({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the entries from your project as a readable object stream.\n * //-\n * log.getEntries()\n *   .on('error', console.error)\n *   .on('data', function(entry) {\n *     // `entry` is a Cloud Logging entry object.\n *     // See the `data` property to read the data from the entry.\n *   })\n *   .on('end', function() {\n *     // All entries retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * log.getEntries()\n *   .on('data', function(entry) {\n *     this.end();\n *   });\n */\nLog.prototype.getEntries = function(options, callback) {\n  if (is.function(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({\n    filter: 'logName=\"' + this.formattedName_ + '\"'\n  }, options);\n\n  return this.parent.getEntries(options, callback);\n};\n\n/**\n * Write a log entry with a severity of \"INFO\".\n *\n * This is a simple wrapper around {module:logging/log#write}. All arguments are\n * the same as documented there.\n *\n * @example\n * var entry = log.entry('compute.googleapis.com', {\n *   user: 'my_username'\n * });\n *\n * log.info(entry, function(err, apiResponse) {});\n */\nLog.prototype.info = function(entry, options, callback) {\n  this.write(Log.assignSeverityToEntries_(entry, 'INFO'), options, callback);\n};\n\n/**\n * Write a log entry with a severity of \"NOTICE\".\n *\n * This is a simple wrapper around {module:logging/log#write}. All arguments are\n * the same as documented there.\n *\n * @example\n * var entry = log.entry('compute.googleapis.com', {\n *   user: 'my_username'\n * });\n *\n * log.notice(entry, function(err, apiResponse) {});\n */\nLog.prototype.notice = function(entry, options, callback) {\n  this.write(Log.assignSeverityToEntries_(entry, 'NOTICE'), options, callback);\n};\n\n/**\n * Write a log entry with a severity of \"WARNING\".\n *\n * This is a simple wrapper around {module:logging/log#write}. All arguments are\n * the same as documented there.\n *\n * @example\n * var entry = log.entry('compute.googleapis.com', {\n *   user: 'my_username'\n * });\n *\n * log.warning(entry, function(err, apiResponse) {});\n */\nLog.prototype.warning = function(entry, options, callback) {\n  this.write(Log.assignSeverityToEntries_(entry, 'WARNING'), options, callback);\n};\n\n/**\n * Write log entries to Cloud Logging.\n *\n * While you may write a single entry at a time, batching multiple entries\n * together is preferred to avoid reaching the queries per second limit.\n *\n * @resource [entries.write API Documentation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/entries/write}\n *\n * @param {module:logging/entry|module:logging/entry[]} entry - A log entry, or\n *     array of entries, to write.\n * @param {object=} options - Configuration object.\n * @param {object[]} options.labels - Labels to set on the log.\n * @param {object} options.resource - A default monitored resource for entries\n *     where one isn't specified.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var entry = log.entry('compute.googleapis.com', {\n *   user: 'my_username'\n * });\n *\n * log.write(entry, function(err, apiResponse) {\n *   if (!err) {\n *     // The log entry was written.\n *   }\n * });\n *\n * //-\n * // You may also pass multiple log entries to write.\n * //-\n * var secondEntry = log.entry('compute.googleapis.com', {\n *   user: 'my_username'\n * });\n *\n * log.write([\n *   entry,\n *   secondEntry\n * ], function(err, apiResponse) {\n *   if (!err) {\n *     // The log entries were written.\n *   }\n * });\n *\n * //-\n * // To save some steps, you can also pass in plain values as your entries.\n * // Note, however, that you must provide a configuration object to specify the\n * // resource.\n * //-\n * var entries = [\n *   {\n *     user: 'my_username'\n *   },\n *   {\n *     home: process.env.HOME\n *   }\n * ];\n *\n * var options = {\n *   resource: 'compute.googleapis.com'\n * };\n *\n * log.write(entries, options, function(err, apiResponse) {});\n */\nLog.prototype.write = function(entry, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var protoOpts = {\n    service: 'LoggingServiceV2',\n    method: 'writeLogEntries'\n  };\n\n  var reqOpts = extend({\n    logName: this.formattedName_,\n    entries: arrify(entry).map(this.formatEntryForApi_.bind(this))\n  }, options);\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    callback(err, resp);\n  });\n};\n\n/**\n * All entries are passed through here to make sure this log is attached to the\n * entry.\n *\n * @private\n *\n * @param {object} entry - An entry object.\n */\nLog.prototype.formatEntryForApi_ = function(entry) {\n  if (!(entry instanceof Entry)) {\n    entry = this.entry(entry);\n  }\n\n  var formattedEntry = entry.toJSON();\n  formattedEntry.logName = this.formattedName_;\n  return formattedEntry;\n};\n\nmodule.exports = Log;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/logging/sink.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module logging/sink\n */\n\n'use strict';\n\nvar extend = require('extend');\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/grpc-service-object}\n * @private\n */\nvar GrpcServiceObject = require('../common/grpc-service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:logging} logging - The Logging instance.\n */\n/**\n * A sink is an object that lets you to specify a set of log entries to export\n * to a particular destination. Cloud Logging lets you export log entries to\n * destinations including Google Cloud Storage buckets (for long term log\n * storage), Google BigQuery datasets (for log analysis), Google Pub/Sub (for\n * streaming to other applications).\n *\n * @resource [Introduction to Sinks]{@link https://cloud.google.com/logging/docs/api/#sinks}\n *\n * @alias module:logging/sink\n * @constructor\n *\n * @param {object} options - [Configuration object](#/docs).\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var logging = gcloud.logging();\n * var sink = logging.sink('my-sink');\n */\nfunction Sink(logging, name) {\n  this.name = name;\n  this.formattedName_ = 'projects/' + logging.projectId + '/sinks/' + name;\n\n  var methods = {\n    /**\n     * Create a sink.\n     *\n     * @param {object} config - See {module:logging#createSink}.\n     *\n     * @example\n     * var config = {\n     *   // ...\n     * };\n     *\n     * sink.create(config, function(err, sink, apiResponse) {\n     *   if (!err) {\n     *     // The sink was created successfully.\n     *   }\n     * });\n     */\n    create: true,\n\n    /**\n     * Delete the sink.\n     *\n     * @resource [projects.sink.delete API Documentation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.sinks/delete}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * sink.delete(function(err, apiResponse) {\n     *   if (!err) {\n     *     // The log was deleted.\n     *   }\n     * });\n     */\n    delete: {\n      protoOpts: {\n        service: 'ConfigServiceV2',\n        method: 'deleteSink'\n      },\n      reqOpts: {\n        sinkName: this.formattedName_\n      }\n    },\n\n    /**\n     * Get the sink's metadata.\n     *\n     * @resource [Sink Resource]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.sinks#LogSink}\n     * @resource [projects.sink.get API Documentation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.sinks/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The sink's metadata.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * sink.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: {\n      protoOpts: {\n        service: 'ConfigServiceV2',\n        method: 'getSink'\n      },\n      reqOpts: {\n        sinkName: this.formattedName_\n      }\n    }\n  };\n\n  GrpcServiceObject.call(this, {\n    parent: logging,\n    baseUrl: '/sinks',\n    id: name,\n    createMethod: logging.createSink.bind(logging),\n    methods: methods\n  });\n}\n\nnodeutil.inherits(Sink, GrpcServiceObject);\n\n/**\n * Set the sink's filter.\n *\n * This will override any filter that was previously set.\n *\n * @resource [Advanced Logs Filters]{@link https://cloud.google.com/logging/docs/view/advanced_filters}\n *\n * @param {string} filter - The new filter.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * sink.setFilter('metadata.severity = ALERT', function(err, apiResponse) {});\n */\nSink.prototype.setFilter = function(filter, callback) {\n  this.setMetadata({\n    filter: filter\n  }, callback);\n};\n\n/**\n * Set the sink's metadata.\n *\n * @resource [Sink Resource]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.sinks#LogSink}\n * @resource [projects.sink.update API Documentation]{@link https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.sinks/update}\n *\n * @param {object} metadata - See a\n *     [Sink resource](https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/projects.sinks#LogSink).\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var metadata = {\n *   filter: 'metadata.severity = ALERT'\n * };\n *\n * sink.setMetadata(metadata, function(err, apiResponse) {});\n */\nSink.prototype.setMetadata = function(metadata, callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  this.getMetadata(function(err, currentMetadata, apiResponse) {\n    if (err) {\n      callback(err, apiResponse);\n      return;\n    }\n\n    var protoOpts = {\n      service: 'ConfigServiceV2',\n      method: 'updateSink'\n    };\n\n    var reqOpts = {\n      sinkName: self.formattedName_,\n      sink: extend({}, currentMetadata, metadata)\n    };\n\n    self.request(protoOpts, reqOpts, function(err, apiResponse) {\n      if (err) {\n        callback(err, apiResponse);\n        return;\n      }\n\n      self.metadata = apiResponse;\n\n      callback(null, apiResponse);\n    });\n  });\n};\n\nmodule.exports = Sink;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/pubsub/topic.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module pubsub/topic\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar is = require('is');\nvar nodeutil = require('util');\nvar prop = require('propprop');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * @type {module:pubsub/iam}\n * @private\n */\nvar IAM = require('./iam.js');\n\n/**\n * @type {module:common/grpc-service-object}\n * @private\n */\nvar GrpcServiceObject = require('../common/grpc-service-object.js');\n\n/*! Developer Documentation\n *\n * @param {module:pubsub} pubsub - PubSub object.\n * @param {string} name - Name of the topic.\n */\n/**\n * A Topic object allows you to interact with a Google Cloud Pub/Sub topic.\n *\n * @constructor\n * @alias module:pubsub/topic\n *\n * @example\n * var pubsub = gcloud.pubsub({\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var topic = pubsub.topic('my-topic');\n */\nfunction Topic(pubsub, name) {\n  this.name = Topic.formatName_(pubsub.projectId, name);\n  this.pubsub = pubsub;\n\n  var methods = {\n    /**\n     * Create a topic.\n     *\n     * @param {object=} config - See {module:pubsub#createTopic}.\n     *\n     * @example\n     * topic.create(function(err, topic, apiResponse) {\n     *   if (!err) {\n     *     // The topic was created successfully.\n     *   }\n     * });\n     */\n    create: true,\n\n    /**\n     * Delete the topic. This will not delete subscriptions to this topic.\n     *\n     * @resource [Topics: delete API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.topics/delete}\n     *\n     * @param {function=} callback - The callback function.\n     *\n     * @example\n     * topic.delete(function(err, apiResponse) {});\n     */\n    delete: {\n      protoOpts: {\n        service: 'Publisher',\n        method: 'deleteTopic'\n      },\n      reqOpts: {\n        topic: this.name\n      }\n    },\n\n    /**\n     * Check if the topic exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the topic exists or not.\n     *\n     * @example\n     * topic.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a topic if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * topic.get(function(err, topic, apiResponse) {\n     *   // `topic.metadata` has been populated.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the official representation of this topic from the API.\n     *\n     * @resource [Topics: get API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.topics/get}\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.metadata - The metadata of the Topic.\n     * @param {object} callback.apiResponse - The full API response.\n     */\n    getMetadata: {\n      protoOpts: {\n        service: 'Publisher',\n        method: 'getTopic'\n      },\n      reqOpts: {\n        topic: this.name\n      }\n    }\n  };\n\n  GrpcServiceObject.call(this, {\n    parent: pubsub,\n    id: this.name,\n    createMethod: pubsub.createTopic.bind(pubsub),\n    methods: methods\n  });\n\n  /**\n   * [IAM (Identity and Access Management)](https://cloud.google.com/pubsub/access_control)\n   * allows you to set permissions on individual resources and offers a wider\n   * range of roles: editor, owner, publisher, subscriber, and viewer. This\n   * gives you greater flexibility and allows you to set more fine-grained\n   * access control.\n   *\n   * *The IAM access control features described in this document are Beta,\n   * including the API methods to get and set IAM policies, and to test IAM\n   * permissions. Google Cloud Pub/Sub's use of IAM features is not covered by\n   * any SLA or deprecation policy, and may be subject to backward-incompatible\n   * changes.*\n   *\n   * @mixes module:pubsub/iam\n   *\n   * @resource [Access Control Overview]{@link https://cloud.google.com/pubsub/access_control}\n   * @resource [What is Cloud IAM?]{@link https://cloud.google.com/iam/}\n   *\n   * @example\n   * //-\n   * // Get the IAM policy for your topic.\n   * //-\n   * topic.iam.getPolicy(function(err, policy) {\n   *   console.log(policy);\n   * });\n   */\n  this.iam = new IAM(pubsub, this.name);\n}\n\nnodeutil.inherits(Topic, GrpcServiceObject);\n\n/**\n * Format a message object as the upstream API expects it.\n *\n * @private\n *\n * @return {object}\n */\nTopic.formatMessage_ = function(message) {\n  if (!(message.data instanceof Buffer)) {\n    message.data = new Buffer(JSON.stringify(message.data));\n  }\n\n  message.data = message.data.toString('base64');\n\n  return message;\n};\n\n/**\n * Format the name of a topic. A Topic's full name is in the format of\n * 'projects/{projectId}/topics/{topicName}'.\n *\n * @private\n *\n * @return {string}\n */\nTopic.formatName_ = function(projectId, name) {\n  // Simple check if the name is already formatted.\n  if (name.indexOf('/') > -1) {\n    return name;\n  }\n  return 'projects/' + projectId + '/topics/' + name;\n};\n\n/**\n * Get a list of the subscriptions registered to this topic. You may optionally\n * provide a query object as the first argument to customize the response.\n *\n * Your provided callback will be invoked with an error object if an API error\n * occurred or an array of {module:pubsub/subscription} objects.\n *\n * @resource [Subscriptions: list API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.topics.subscriptions/list}\n *\n * @param {object=} options - Configuration object.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of results to return.\n * @param {number} options.pageSize - Maximum number of results to return.\n * @param {string} options.pageToken - Page token.\n * @param {function} callback - The callback function.\n *\n * @example\n * var callback = function(err, subscriptions, nextQuery, apiResponse) {\n *   // If `nextQuery` is non-null, there may be more results to fetch. To do\n *   // so, run `topic.getSubscriptions(nextQuery, callback);`.\n * };\n *\n * // Get all subscriptions for this topic.\n * topic.getSubscriptions(callback);\n *\n * // Customize the query.\n * topic.getSubscriptions({\n *   pageSize: 3\n * }, callback);\n *\n * //-\n * // Get the subscriptions for this topic as a readable object stream.\n * //-\n * topic.getSubscriptions()\n *   .on('error', console.error)\n *   .on('data', function(subscription) {\n *     // subscription is a Subscription object.\n *   })\n *   .on('end', function() {\n *     // All subscriptions retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * topic.getSubscriptions()\n *   .on('data', function(subscription) {\n *     this.end();\n *   });\n */\nTopic.prototype.getSubscriptions = function(options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  options.topic = this;\n\n  return this.pubsub.getSubscriptions(options, callback);\n};\n\n/**\n * Publish the provided message or array of messages. On success, an array of\n * messageIds is returned in the response.\n *\n * @resource [Topics: publish API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.topics/publish}\n *\n * @throws {Error} If no message is provided.\n * @throws {Error} If a message is missing a data property.\n *\n * @param {object|object[]} message - The message(s) to publish.\n * @param {*} message.data - The contents of the message.\n * @param {array=} message.attributes - Key/value pair of attributes to apply to\n *     the message. All values must be strings.\n * @param {function=} callback - The callback function.\n *\n * @example\n * topic.publish({\n *   data: 'Hello, world!'\n * }, function(err, messageIds, apiResponse) {});\n *\n * //-\n * // The data property can be a JSON object as well.\n * //-\n * var registerMessage = {\n *   data: {\n *     userId: 3,\n *     name: 'Stephen',\n *     event: 'new user'\n *   },\n *   attributes: {\n *     key: 'value',\n *     hello: 'world'\n *   }\n * };\n *\n * topic.publish(registerMessage, function(err, messageIds, apiResponse) {});\n *\n * //-\n * // You can publish a batch of messages at once by supplying an array.\n * //-\n * var purchaseMessage = {\n *   data: {\n *     userId: 3,\n *     product: 'computer',\n *     event: 'purchase'\n *   }\n * };\n *\n * topic.publish([\n *   registerMessage,\n *   purchaseMessage\n * ], function(err, messageIds, apiResponse) {});\n */\nTopic.prototype.publish = function(messages, callback) {\n  messages = arrify(messages);\n\n  if (messages.length === 0) {\n    throw new Error('Cannot publish without a message.');\n  }\n\n  if (!messages.every(prop('data'))) {\n    throw new Error('Cannot publish message without a `data` property.');\n  }\n\n  callback = callback || util.noop;\n\n  var protoOpts = {\n    service: 'Publisher',\n    method: 'publish',\n  };\n\n  var reqOpts = {\n    topic: this.name,\n    messages: messages.map(Topic.formatMessage_)\n  };\n\n  this.request(protoOpts, reqOpts, function(err, result) {\n    if (err) {\n      callback(err, null, result);\n      return;\n    }\n\n    callback(null, arrify(result.messageIds), result);\n  });\n};\n\n/**\n * Create a subscription to this topic. You may optionally provide an object to\n * customize the subscription.\n *\n * Your provided callback will be invoked with an error object if an API error\n * occurred or a {module:pubsub/subscription} object.\n *\n * @resource [Subscriptions: create API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions/create}\n *\n * @param {string} subName - The name of the subscription.\n * @param {object=} options - Configuration object.\n * @param {number=} options.ackDeadlineSeconds - The maximum time after\n *     receiving a message that you must ack a message before it is redelivered.\n * @param {boolean=} options.autoAck - Automatically acknowledge the message\n *     once it's pulled. (default: false)\n * @param {string} options.encoding - When pulling for messages, this type is\n *     used when converting a message's data to a string. (default: 'utf-8')\n * @param {number=} options.interval - Interval in milliseconds to check for new\n *     messages. (default: 10)\n * @param {number} options.maxInProgress - Maximum messages to consume\n *     simultaneously.\n * @param {boolean=} options.reuseExisting - If the subscription already exists,\n *     reuse it. The options of the existing subscription are not changed. If\n *     false, attempting to create a subscription that already exists will fail.\n *     (default: false)\n * @param {number} options.timeout - Set a maximum amount of time in\n *     milliseconds on an HTTP request to pull new messages to wait for a\n *     response before the connection is broken.\n * @param {function} callback - The callback function.\n *\n * @example\n * // Without specifying any options.\n * topic.subscribe('newMessages', function(err, subscription, apiResponse) {});\n *\n * // With options.\n * topic.subscribe('newMessages', {\n *   ackDeadlineSeconds: 90,\n *   autoAck: true,\n *   interval: 30\n * }, function(err, subscription, apiResponse) {});\n */\nTopic.prototype.subscribe = function(subName, options, callback) {\n  this.pubsub.subscribe(this, subName, options, callback);\n};\n\n/**\n * Create a Subscription object. This command by itself will not run any API\n * requests. You will receive a {module:pubsub/subscription} object,\n * which will allow you to interact with a subscription.\n *\n * @param {string} name - Name of the subscription.\n * @param {object=} options - Configuration object.\n * @param {boolean=} options.autoAck - Automatically acknowledge the message\n *     once it's pulled.\n * @param {number=} options.interval - Interval in milliseconds to check for new\n *     messages.\n * @return {module:pubsub/subscription}\n *\n * @example\n * var subscription = topic.subscription('my-subscription');\n *\n * // Register a listener for `message` events.\n * subscription.on('message', function(message) {\n *   // Called every time a message is received.\n *   // message.id = ID used to acknowledge its receival.\n *   // message.data = Contents of the message.\n *   // message.attributes = Attributes of the message.\n * });\n */\nTopic.prototype.subscription = function(name, options) {\n  options = options || {};\n  options.topic = this;\n\n  return this.pubsub.subscription(name, options);\n};\n\nmodule.exports = Topic;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/pubsub/iam.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module pubsub/iam\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/grpc-service}\n * @private\n */\nvar GrpcService = require('../common/grpc-service.js');\n\n/*! Developer Documentation\n *\n * @param {module:pubsub} pubsub - PubSub Object.\n * @param {object} config - Configuration object.\n * @param {string} config.baseUrl - The base URL to apply to API requests.\n * @param {string} config.id - The name of the topic or subscription.\n */\n/**\n * [IAM (Identity and Access Management)](https://cloud.google.com/pubsub/access_control)\n * allows you to set permissions on invidual resources and offers a wider range\n * of roles: editor, owner, publisher, subscriber, and viewer. This gives you\n * greater flexibility and allows you to set more fine-grained access control.\n *\n * For example:\n *   * Grant access on a per-topic or per-subscription basis, rather than for\n *     the whole Cloud project.\n *   * Grant access with limited capabilities, such as to only publish messages\n *     to a topic, or to only to consume messages from a subscription, but not\n *     to delete the topic or subscription.\n *\n *\n * *The IAM access control features described in this document are Beta,\n * including the API methods to get and set IAM policies, and to test IAM\n * permissions. Google Cloud Pub/Sub's use of IAM features is not covered by any\n * SLA or deprecation policy, and may be subject to backward-incompatible\n * changes.*\n *\n * @constructor\n * @alias module:pubsub/iam\n *\n * @resource [Access Control Overview]{@link https://cloud.google.com/pubsub/access_control}\n * @resource [What is Cloud IAM?]{@link https://cloud.google.com/iam/}\n *\n * @example\n * var pubsub = gcloud.pubsub({\n *   projectId: 'grape-spaceship-123',\n *   keyFilename: '/path/to/keyfile.json'\n * });\n *\n * var topic = pubsub.topic('my-topic');\n * // topic.iam\n *\n * var subscription = pubsub.subscription('my-subscription');\n * // subscription.iam\n */\nfunction IAM(pubsub, id) {\n  var config = {\n    baseUrl: pubsub.defaultBaseUrl_,\n    service: 'iam',\n    apiVersion: 'v1',\n    scopes: [\n      'https://www.googleapis.com/auth/pubsub',\n      'https://www.googleapis.com/auth/cloud-platform'\n    ]\n  };\n\n  this.id = id;\n\n  GrpcService.call(this, config, pubsub.options);\n}\n\nnodeutil.inherits(IAM, GrpcService);\n\n/**\n * Get the IAM policy\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.policy - The [policy](https://cloud.google.com/pubsub/reference/rest/Shared.Types/Policy).\n * @param {object} callback.apiResponse - The full API response.\n *\n * @resource [Topics: getIamPolicy API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.topics/getIamPolicy}\n * @resource [Subscriptions: getIamPolicy API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions/getIamPolicy}\n *\n * @example\n * topic.iam.getPolicy(function(err, policy, apiResponse) {});\n *\n * subscription.iam.getPolicy(function(err, policy, apiResponse) {});\n */\nIAM.prototype.getPolicy = function(callback) {\n  var protoOpts = {\n    service: 'IAMPolicy',\n    method: 'getIamPolicy'\n  };\n\n  var reqOpts = {\n    resource: this.id\n  };\n\n  this.request(protoOpts, reqOpts, callback);\n};\n\n/**\n * Set the IAM policy\n *\n * @throws {Error} If no policy is provided.\n *\n * @param {object} policy - The [policy](https://cloud.google.com/pubsub/reference/rest/Shared.Types/Policy).\n * @param {array=} policy.bindings - Bindings associate members with roles.\n * @param {object[]=} policy.rules - Rules to be applied to the policy.\n * @param {string=} policy.etag - Etags are used to perform a read-modify-write.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.policy - The updated policy.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @resource [Topics: setIamPolicy API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.topics/setIamPolicy}\n * @resource [Subscriptions: setIamPolicy API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions/setIamPolicy}\n * @resource [Policy]{@link https://cloud.google.com/pubsub/reference/rest/Shared.Types/Policy}\n *\n * @example\n * var myPolicy = {\n *   bindings: [\n *     {\n *       role: 'roles/pubsub.subscriber',\n *       members: ['serviceAccount:myotherproject@appspot.gserviceaccount.com']\n *     }\n *   ]\n * };\n *\n * topic.iam.setPolicy(myPolicy, function(err, policy, apiResponse) {});\n *\n * subscription.iam.setPolicy(myPolicy, function(err, policy, apiResponse) {});\n */\nIAM.prototype.setPolicy = function(policy, callback) {\n  if (!is.object(policy)) {\n    throw new Error('A policy object is required.');\n  }\n\n  var protoOpts = {\n    service: 'IAMPolicy',\n    method: 'setIamPolicy'\n  };\n\n  var reqOpts = {\n    resource: this.id,\n    policy: policy\n  };\n\n  this.request(protoOpts, reqOpts, callback);\n};\n\n/**\n * Test a set of permissions for a resource.\n *\n * Permissions with wildcards such as `*` or `storage.*` are not allowed.\n *\n * @throws {Error} If permissions are not provided.\n *\n * @param {string|string[]} permissions - The permission(s) to test for.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {array} callback.permissions - A subset of permissions that the caller\n *     is allowed\n * @param {object} callback.apiResponse - The full API response.\n *\n * @resource [Topics: testIamPermissions API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.topics/testIamPermissions}\n * @resource [Subscriptions: testIamPermissions API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions/testIamPermissions}\n * @resource [Permissions Reference]{@link https://cloud.google.com/pubsub/access_control#permissions}\n *\n * @example\n * //-\n * // Test a single permission.\n * //-\n * var test = 'pubsub.topics.update';\n *\n * topic.iam.testPermissions(test, function(err, permissions, apiResponse) {\n *   console.log(permissions);\n *   // {\n *   //   \"pubsub.topics.update\": true\n *   // }\n * });\n *\n * //-\n * // Test several permissions at once.\n * //-\n * var tests = [\n *   'pubsub.subscriptions.consume',\n *   'pubsub.subscriptions.update'\n * ];\n *\n * subscription.iam.testPermissions(tests, function(err, permissions) {\n *   console.log(permissions);\n *   // {\n *   //   \"pubsub.subscriptions.consume\": true,\n *   //   \"pubsub.subscriptions.update\": false\n *   // }\n * });\n */\nIAM.prototype.testPermissions = function(permissions, callback) {\n  if (!is.array(permissions) && !is.string(permissions)) {\n    throw new Error('Permissions are required.');\n  }\n\n  permissions = arrify(permissions);\n\n  var protoOpts = {\n    service: 'IAMPolicy',\n    method: 'testIamPermissions'\n  };\n\n  var reqOpts = {\n    resource: this.id,\n    permissions: permissions\n  };\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var availablePermissions = arrify(resp.permissions);\n\n    var permissionsHash = permissions.reduce(function(acc, permission) {\n      acc[permission] = availablePermissions.indexOf(permission) > -1;\n      return acc;\n    }, {});\n\n    callback(null, permissionsHash, resp);\n  });\n};\n\nmodule.exports = IAM;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/pubsub/index.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module pubsub\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar extend = require('extend');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/grpc-service}\n * @private\n */\nvar GrpcService = require('../common/grpc-service.js');\n\n/**\n * @type {module:pubsub/subscription}\n * @private\n */\nvar Subscription = require('./subscription.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:pubsub/topic}\n * @private\n */\nvar Topic = require('./topic.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * [Google Cloud Pub/Sub](https://developers.google.com/pubsub/overview) is a\n * reliable, many-to-many, asynchronous messaging service from Google Cloud\n * Platform.\n *\n * The `PUBSUB_EMULATOR_HOST` environment variable from the gcloud SDK is\n * honored, otherwise the actual API endpoint will be used.\n *\n * @constructor\n * @alias module:pubsub\n *\n * The `gcloud.pubsub` method will return a `pubsub` object, allowing you to\n * create topics, publish messages, subscribe to topics, and more.\n *\n * To learn more about Pub/Sub, see the\n * [Google Cloud Pub/Sub overview](https://developers.google.com/pubsub/overview).\n *\n * @param {object} options - [Configuration object](#/docs).\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'my-project'\n * });\n *\n * var pubsub = gcloud.pubsub();\n */\nfunction PubSub(options) {\n  if (!(this instanceof PubSub)) {\n    options = util.normalizeArguments(this, options);\n    return new PubSub(options);\n  }\n\n  this.defaultBaseUrl_ = 'pubsub.googleapis.com';\n  this.determineBaseUrl_();\n\n  var config = {\n    baseUrl: this.baseUrl_,\n    customEndpoint: this.customEndpoint_,\n    service: 'pubsub',\n    apiVersion: 'v1',\n    scopes: [\n      'https://www.googleapis.com/auth/pubsub',\n      'https://www.googleapis.com/auth/cloud-platform'\n    ]\n  };\n\n  this.options = options;\n\n  GrpcService.call(this, config, options);\n}\n\nnodeutil.inherits(PubSub, GrpcService);\n\n/**\n * Create a topic with the given name.\n *\n * @resource [Topics: create API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.topics/create}\n *\n * @param {string} name - Name of the topic.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error from the API call, may be null.\n * @param {module:pubsub/topic} callback.topic - The newly created topic.\n * @param {object} callback.apiResponse - The full API response from the\n *     service.\n *\n * @example\n * pubsub.createTopic('my-new-topic', function(err, topic, apiResponse) {\n *   if (!err) {\n *     // The topic was created successfully.\n *   }\n * });\n */\nPubSub.prototype.createTopic = function(name, callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  var protoOpts = {\n    service: 'Publisher',\n    method: 'createTopic'\n  };\n\n  var reqOpts = {\n    name: Topic.formatName_(this.projectId, name)\n  };\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var topic = self.topic(name);\n    topic.metadata = resp;\n\n    callback(null, topic, resp);\n  });\n};\n\n/**\n * Get a list of the subscriptions registered to all of your project's topics.\n * You may optionally provide a query object as the first argument to customize\n * the response.\n *\n * Your provided callback will be invoked with an error object if an API error\n * occurred or an array of {module:pubsub/subscription} objects.\n *\n * To get subscriptions for a topic, see {module:pubsub/topic}.\n *\n * @resource [Subscriptions: list API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions/list}\n *\n * @param {object=} options - Configuration object.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of results to return.\n * @param {number} options.pageSize - Maximum number of results to return.\n * @param {string} options.pageToken - Page token.\n * @param {string|module:pubsub/topic} options.topic - The name of the topic to\n *     list subscriptions from.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error from the API call, may be null.\n * @param {module:pubsub/subscription[]} callback.subscriptions - The list of\n *     subscriptions returned.\n * @param {?object} callback.nextQuery - A query object representing the next\n *     page of topics.\n * @param {object} callback.apiResponse - The full API response from the\n *     service.\n *\n * @example\n * pubsub.getSubscriptions(function(err, subscriptions) {\n *   if (!err) {\n *     // subscriptions is an array of Subscription objects.\n *   }\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * var callback = function(err, subscriptions, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     pubsub.getSubscriptions(nextQuery, callback);\n *   }\n * };\n *\n * pubsub.getSubscriptions({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the subscriptions as a readable object stream.\n * //-\n * pubsub.getSubscriptions()\n *   .on('error', console.error)\n *   .on('data', function(subscription) {\n *     // subscription is a Subscription object.\n *   })\n *   .on('end', function() {\n *     // All subscriptions retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * pubsub.getSubscriptions()\n *   .on('data', function(topic) {\n *     this.end();\n *   });\n */\nPubSub.prototype.getSubscriptions = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var protoOpts = {};\n  var reqOpts = extend({}, options);\n\n  if (options.topic) {\n    protoOpts = {\n      service: 'Publisher',\n      method: 'listTopicSubscriptions'\n    };\n\n    if (options.topic instanceof Topic) {\n      reqOpts.topic = options.topic.name;\n    } else {\n      reqOpts.topic = options.topic;\n    }\n  } else {\n    protoOpts = {\n      service: 'Subscriber',\n      method: 'listSubscriptions'\n    };\n\n    reqOpts.project = 'projects/' + this.projectId;\n  }\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var subscriptions = arrify(resp.subscriptions).map(function(sub) {\n      // Depending on if we're using a subscriptions.list or\n      // topics.subscriptions.list API endpoint, we will get back a\n      // Subscription resource or just the name of the subscription.\n      var subscriptionInstance = self.subscription(sub.name || sub);\n\n      if (sub.name) {\n        subscriptionInstance.metadata = sub;\n      }\n\n      return subscriptionInstance;\n    });\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = options;\n      nextQuery.pageToken = resp.nextPageToken;\n    }\n\n    callback(null, subscriptions, nextQuery, resp);\n  });\n};\n\n/**\n * Get a list of the topics registered to your project. You may optionally\n * provide a query object as the first argument to customize the response.\n *\n * @resource [Topics: list API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.topics/list}\n *\n * @param {object=} query - Query object.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of results to return.\n * @param {number} query.pageSize - Max number of results to return.\n * @param {string} query.pageToken - Page token.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error from the API call, may be null.\n * @param {module:pubsub/topic[]} callback.topics - The list of topics returned.\n * @param {?object} callback.nextQuery - A query object representing the next\n *     page of topics.\n * @param {object} callback.apiResponse - The full API response from the\n *     service.\n *\n * @example\n * pubsub.getTopics(function(err, topics) {\n *   if (!err) {\n *     // topics is an array of Topic objects.\n *   }\n * });\n *\n * //-\n * // Customize the query.\n * //-\n * pubsub.getTopics({\n *   pageSize: 3\n * }, function(err, topics) {});\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * var callback = function(err, rows, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     pubsub.getTopics(nextQuery, callback);\n *   }\n * };\n *\n * pubsub.getTopics({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the topics as a readable object stream.\n * //-\n * pubsub.getTopics()\n *   .on('error', console.error)\n *   .on('data', function(topic) {\n *     // topic is a Topic object.\n *   })\n *   .on('end', function() {\n *     // All topics retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * pubsub.getTopics()\n *   .on('data', function(topic) {\n *     this.end();\n *   });\n */\nPubSub.prototype.getTopics = function(query, callback) {\n  var self = this;\n\n  if (!callback) {\n    callback = query;\n    query = {};\n  }\n\n  var protoOpts = {\n    service: 'Publisher',\n    method: 'listTopics'\n  };\n\n  var reqOpts = extend({\n    project: 'projects/' + this.projectId\n  }, query);\n\n  this.request(protoOpts, reqOpts, function(err, result) {\n    if (err) {\n      callback(err, null, result);\n      return;\n    }\n\n    var topics = arrify(result.topics).map(function(topic) {\n      var topicInstance = self.topic(topic.name);\n      topicInstance.metadata = topic;\n      return topicInstance;\n    });\n\n    var nextQuery = null;\n    if (result.nextPageToken) {\n      nextQuery = query;\n      nextQuery.pageToken = result.nextPageToken;\n    }\n\n    callback(null, topics, nextQuery, result);\n  });\n};\n\n/**\n * Create a subscription to a topic. You may optionally provide an object to\n * customize the subscription.\n *\n * Your provided callback will be invoked with an error object if an API error\n * occurred or a {module:pubsub/subscription} object.\n *\n * @resource [Subscriptions: create API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions/create}\n *\n * @throws {Error} If a Topic instance or topic name is not provided.\n * @throws {Error} If a subName is not provided.\n *\n * @param {module:pubsub/topic|string} topic - The Topic to create a\n *     subscription to.\n * @param {string} subName - The name of the subscription.\n * @param {object=} options - See a\n *     [Subscription resource](https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions)\n * @param {number} options.ackDeadlineSeconds - The maximum time after receiving\n *     a message that you must ack a message before it is redelivered.\n * @param {boolean} options.autoAck - Automatically acknowledge the message once\n *     it's pulled. (default: false)\n * @param {string} options.encoding - When pulling for messages, this type is\n *     used when converting a message's data to a string. (default: 'utf-8')\n * @param {number} options.interval - Interval in milliseconds to check for new\n *     messages. (default: 10)\n * @param {number} options.maxInProgress - Maximum messages to consume\n *     simultaneously.\n * @param {boolean} options.reuseExisting - If the subscription already exists,\n *     reuse it. The options of the existing subscription are not changed. If\n *     false, attempting to create a subscription that already exists will fail.\n *     (default: false)\n * @param {number} options.timeout - Set a maximum amount of time in\n *     milliseconds on an HTTP request to pull new messages to wait for a\n *     response before the connection is broken.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:pubsub/subscription} callback.subscription - The subscription.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * //-\n * // Subscribe to a topic. (Also see {module:pubsub/topic#subscribe}).\n * //-\n * var topic = 'messageCenter';\n * var name = 'newMessages';\n *\n * pubsub.subscribe(topic, name, function(err, subscription, apiResponse) {});\n *\n * //-\n * // Customize the subscription.\n * //-\n * pubsub.subscribe(topic, name, {\n *   ackDeadlineSeconds: 90,\n *   autoAck: true,\n *   interval: 30\n * }, function(err, subscription, apiResponse) {});\n *\n * //-\n * // Create a subscription to a topic from another project.\n * //-\n * var anotherProject = gcloud.pubsub({\n *   projectId: 'another-project'\n * });\n *\n * var topic = anotherProject.topic('messageCenter');\n *\n * pubsub.subscribe(topic, name, function(err, subscription, apiResponse) {});\n */\nPubSub.prototype.subscribe = function(topic, subName, options, callback) {\n  if (!is.string(topic) && !(topic instanceof Topic)) {\n    throw new Error('A Topic is required for a new subscription.');\n  }\n\n  if (!is.string(subName)) {\n    throw new Error('A subscription name is required for a new subscription.');\n  }\n\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  if (is.string(topic)) {\n    topic = this.topic(topic);\n  }\n\n  var subscription = this.subscription(subName, options);\n\n  var protoOpts = {\n    service: 'Subscriber',\n    method: 'createSubscription',\n    timeout: options.timeout\n  };\n\n  var reqOpts = extend(true, {}, options, {\n    topic: topic.name,\n    name: subscription.name\n  });\n\n  delete reqOpts.autoAck;\n  delete reqOpts.encoding;\n  delete reqOpts.interval;\n  delete reqOpts.maxInProgress;\n  delete reqOpts.reuseExisting;\n  delete reqOpts.timeout;\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    if (err && !(err.code === 409 && options.reuseExisting)) {\n      callback(err, null, resp);\n      return;\n    }\n\n    callback(null, subscription, resp);\n  });\n};\n\n/**\n * Create a Subscription object. This command by itself will not run any API\n * requests. You will receive a {module:pubsub/subscription} object,\n * which will allow you to interact with a subscription.\n *\n * @throws {Error} If a name is not provided.\n *\n * @param {string} name - The name of the subscription.\n * @param {object=} options - Configuration object.\n * @param {boolean} options.autoAck - Automatically acknowledge the message once\n *     it's pulled. (default: false)\n * @param {string} options.encoding - When pulling for messages, this type is\n *     used when converting a message's data to a string. (default: 'utf-8')\n * @param {number} options.interval - Interval in milliseconds to check for new\n *     messages. (default: 10)\n * @param {number} options.maxInProgress - Maximum messages to consume\n *     simultaneously.\n * @param {number} options.timeout - Set a maximum amount of time in\n *     milliseconds on an HTTP request to pull new messages to wait for a\n *     response before the connection is broken.\n * @return {module:pubsub/subscription}\n *\n * @example\n * var subscription = pubsub.subscription('my-subscription');\n *\n * // Register a listener for `message` events.\n * subscription.on('message', function(message) {\n *   // Called every time a message is received.\n *   // message.id = ID used to acknowledge its receival.\n *   // message.data = Contents of the message.\n *   // message.attributes = Attributes of the message.\n * });\n */\nPubSub.prototype.subscription = function(name, options) {\n  if (!name) {\n    throw new Error('The name of a subscription is required.');\n  }\n\n  options = options || {};\n  options.name = name;\n  return new Subscription(this, options);\n};\n\n/**\n * Create a Topic object. See {module:pubsub/createTopic} to create a topic.\n *\n * @throws {Error} If a name is not provided.\n *\n * @param {string} name - The name of the topic.\n * @return {module:pubsub/topic}\n *\n * @example\n * var topic = pubsub.topic('my-topic');\n *\n * topic.publish({\n *   data: 'New message!'\n * }, function(err) {});\n */\nPubSub.prototype.topic = function(name) {\n  if (!name) {\n    throw new Error('A name must be specified for a new topic.');\n  }\n\n  return new Topic(this, name);\n};\n\n/**\n * Determine the appropriate endpoint to use for API requests, first trying the\n * local Pub/Sub emulator environment variable (PUBSUB_EMULATOR_HOST), otherwise\n * the default JSON API.\n *\n * @private\n */\nPubSub.prototype.determineBaseUrl_ = function() {\n  var baseUrl = this.defaultBaseUrl_;\n  var leadingProtocol = new RegExp('^https*://');\n  var trailingSlashes = new RegExp('/*$');\n\n  if (process.env.PUBSUB_EMULATOR_HOST) {\n    this.customEndpoint_ = true;\n    baseUrl = process.env.PUBSUB_EMULATOR_HOST;\n  }\n\n  this.baseUrl_ = baseUrl\n    .replace(leadingProtocol, '')\n    .replace(trailingSlashes, '');\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(PubSub, ['getSubscriptions', 'getTopics']);\n\nmodule.exports = PubSub;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/pubsub/subscription.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module pubsub/subscription\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar events = require('events');\nvar is = require('is');\nvar modelo = require('modelo');\nvar prop = require('propprop');\n\n/**\n * @type {module:common/grpc-service-object}\n * @private\n */\nvar GrpcServiceObject = require('../common/grpc-service-object.js');\n\n/**\n * @type {module:pubsub/iam}\n * @private\n */\nvar IAM = require('./iam.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * @const {number} - The amount of time a subscription pull HTTP connection to\n *     Pub/Sub stays open.\n * @private\n */\nvar PUBSUB_API_TIMEOUT = 90000;\n\n/*! Developer Documentation\n *\n * @param {module:pubsub} pubsub - PubSub object.\n * @param {object} options - Configuration object.\n * @param {boolean} options.autoAck - Automatically acknowledge the message once\n *     it's pulled. (default: false)\n * @param {string} options.encoding - When pulling for messages, this type is\n *     used when converting a message's data to a string. (default: 'utf-8')\n * @param {number} options.interval - Interval in milliseconds to check for new\n *     messages. (default: 10)\n * @param {string} options.name - Name of the subscription.\n * @param {number} options.maxInProgress - Maximum messages to consume\n *     simultaneously.\n * @param {number} options.timeout - Set a maximum amount of time in\n *     milliseconds on an HTTP request to pull new messages to wait for a\n *     response before the connection is broken. (default: 90000)\n */\n/**\n * A Subscription object will give you access to your Google Cloud Pub/Sub\n * subscription.\n *\n * Subscriptions are sometimes retrieved when using various methods:\n *\n * - {module:pubsub#getSubscriptions}\n * - {module:pubsub/topic#getSubscriptions}\n * - {module:pubsub/topic#subscribe}\n *\n * Subscription objects may be created directly with:\n *\n * - {module:pubsub/topic#subscription}\n *\n * All Subscription objects are instances of an\n * [EventEmitter](http://nodejs.org/api/events.html). The subscription will pull\n * for messages automatically as long as there is at least one listener assigned\n * for the `message` event.\n *\n * @alias module:pubsub/subscription\n * @constructor\n *\n * @example\n * var pubsub = gcloud.pubsub({\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * //-\n * // From {module:pubsub#getSubscriptions}:\n * //-\n * pubsub.getSubscriptions(function(err, subscriptions) {\n *   // `subscriptions` is an array of Subscription objects.\n * });\n *\n * //-\n * // From {module:pubsub/topic#getSubscriptions}:\n * //-\n * var topic = pubsub.topic('my-topic');\n * topic.getSubscriptions(function(err, subscriptions) {\n *   // `subscriptions` is an array of Subscription objects.\n * });\n *\n * //-\n * // From {module:pubsub/topic#subscribe}:\n * //-\n * var topic = pubsub.topic('my-topic');\n * topic.subscribe('new-subscription', function(err, subscription) {\n *   // `subscription` is a Subscription object.\n * });\n *\n * //-\n * // From {module:pubsub/topic#subscription}:\n * //-\n * var topic = pubsub.topic('my-topic');\n * var subscription = topic.subscription('my-subscription');\n * // `subscription` is a Subscription object.\n *\n * //-\n * // Once you have obtained a subscription object, you may begin to register\n * // listeners. This will automatically trigger pulling for messages.\n * //-\n *\n * // Register an error handler.\n * subscription.on('error', function(err) {});\n *\n * // Register a listener for `message` events.\n * function onMessage(message) {\n *   // Called every time a message is received.\n *\n *   // message.id = ID of the message.\n *   // message.ackId = ID used to acknowledge the message receival.\n *   // message.data = Contents of the message.\n *\n *   // Ack the message:\n *   // message.ack(callback);\n *\n *   // Skip the message. This is useful with `maxInProgress` option when\n *   // creating your subscription. This doesn't ack the message, but allows\n *   // more messages to be retrieved if your limit was hit.\n *   // message.skip();\n * }\n * subscription.on('message', onMessage);\n *\n * // Remove the listener from receiving `message` events.\n * subscription.removeListener('message', onMessage);\n */\nfunction Subscription(pubsub, options) {\n  this.name = Subscription.formatName_(pubsub.projectId, options.name);\n\n  var methods = {\n    /**\n     * Check if the subscription exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the subscription exists or\n     *     not.\n     *\n     * @example\n     * subscription.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a subscription if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * **`autoCreate` is only available if you accessed this object\n     * through {module:pubsub/topic#subscription}.**\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * subscription.get(function(err, subscription, apiResponse) {\n     *   // `subscription.metadata` has been populated.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the metadata for the subscription.\n     *\n     * @resource [Subscriptions: get API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions/get}\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {?object} callback.metadata - Metadata of the subscription from\n     *     the API.\n     * @param {object} callback.apiResponse - Raw API response.\n     *\n     * @example\n     * subscription.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: {\n      protoOpts: {\n        service: 'Subscriber',\n        method: 'getSubscription'\n      },\n      reqOpts: {\n        subscription: this.name\n      }\n    }\n  };\n\n  var config = {\n    parent: pubsub,\n    id: this.name,\n    methods: methods\n  };\n\n  if (options.topic) {\n    // Only a subscription with knowledge of its topic can be created.\n    config.createMethod = pubsub.subscribe.bind(pubsub, options.topic);\n    delete options.topic;\n\n    /**\n     * Create a subscription.\n     *\n     * **This is only available if you accessed this object through\n     * {module:pubsub/topic#subscription}.**\n     *\n     * @param {object} config - See {module:pubsub#subscribe}.\n     *\n     * @example\n     * subscription.create(function(err, subscription, apiResponse) {\n     *   if (!err) {\n     *     // The subscription was created successfully.\n     *   }\n     * });\n     */\n    config.methods.create = true;\n  }\n\n  GrpcServiceObject.call(this, config);\n  events.EventEmitter.call(this);\n\n  this.autoAck = is.boolean(options.autoAck) ? options.autoAck : false;\n  this.closed = true;\n  this.encoding = options.encoding || 'utf-8';\n  this.inProgressAckIds = {};\n  this.interval = is.number(options.interval) ? options.interval : 10;\n  this.maxInProgress =\n    is.number(options.maxInProgress) ? options.maxInProgress : Infinity;\n  this.messageListeners = 0;\n  this.paused = false;\n\n  if (is.number(options.timeout)) {\n    this.timeout = options.timeout;\n  } else {\n    // The default timeout used in gcloud-node is 60s, but a pull request times\n    // out around 90 seconds. Allow an extra couple of seconds to give the API a\n    // chance to respond on its own before terminating the connection.\n    this.timeout = PUBSUB_API_TIMEOUT + 2000;\n  }\n\n  /**\n   * [IAM (Identity and Access Management)](https://cloud.google.com/pubsub/access_control)\n   * allows you to set permissions on individual resources and offers a wider\n   * range of roles: editor, owner, publisher, subscriber, and viewer. This\n   * gives you greater flexibility and allows you to set more fine-grained\n   * access control.\n   *\n   * *The IAM access control features described in this document are Beta,\n   * including the API methods to get and set IAM policies, and to test IAM\n   * permissions. Google Cloud Pub/Sub's use of IAM features is not covered by\n   * any SLA or deprecation policy, and may be subject to backward-incompatible\n   * changes.*\n   *\n   * @mixes module:pubsub/iam\n   *\n   * @resource [Access Control Overview]{@link https://cloud.google.com/pubsub/access_control}\n   * @resource [What is Cloud IAM?]{@link https://cloud.google.com/iam/}\n   *\n   * @example\n   * //-\n   * // Get the IAM policy for your subscription.\n   * //-\n   * subscription.iam.getPolicy(function(err, policy) {\n   *   console.log(policy);\n   * });\n   */\n  this.iam = new IAM(pubsub, this.name);\n\n  this.listenForEvents_();\n}\n\nmodelo.inherits(Subscription, GrpcServiceObject, events.EventEmitter);\n\n/**\n * Simplify a message from an API response to have three properties, `id`,\n * `data` and `attributes`. `data` is always converted to a string.\n *\n * @private\n */\nSubscription.formatMessage_ = function(msg, encoding) {\n  var innerMessage = msg.message;\n  var message = {\n    ackId: msg.ackId\n  };\n\n  if (innerMessage) {\n    message.id = innerMessage.messageId;\n\n    if (innerMessage.data) {\n      message.data = new Buffer(innerMessage.data, 'base64').toString(encoding);\n\n      try {\n        message.data = JSON.parse(message.data);\n      } catch(e) {}\n    }\n\n    if (innerMessage.attributes) {\n      message.attributes = innerMessage.attributes;\n    }\n  }\n\n  return message;\n};\n\n/**\n * Format the name of a subscription. A subscription's full name is in the\n * format of projects/{projectId}/subscriptions/{subName}.\n *\n * @private\n */\nSubscription.formatName_ = function(projectId, name) {\n  // Simple check if the name is already formatted.\n  if (name.indexOf('/') > -1) {\n    return name;\n  }\n\n  return 'projects/' + projectId + '/subscriptions/' + name;\n};\n\n/**\n * Acknowledge to the backend that the message was retrieved. You must provide\n * either a single ackId or an array of ackIds.\n *\n * @resource [Subscriptions: acknowledge API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions/acknowledge}\n *\n * @throws {Error} If at least one ackId is not provided.\n *\n * @param {string|string[]} ackIds - An ackId or array of ackIds.\n * @param {function=} callback - The callback function.\n *\n * @example\n * subscription.ack('ePHEESyhuE8e...', function(err, apiResponse) {});\n */\nSubscription.prototype.ack = function(ackIds, callback) {\n  var self = this;\n\n  ackIds = arrify(ackIds);\n\n  if (ackIds.length === 0) {\n    throw new Error([\n      'At least one ID must be specified before it can be acknowledged.'\n    ].join(''));\n  }\n\n  callback = callback || util.noop;\n\n  var protoOpts = {\n    service: 'Subscriber',\n    method: 'acknowledge'\n  };\n\n  var reqOpts = {\n    subscription: this.name,\n    ackIds: ackIds\n  };\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    if (!err) {\n      ackIds.forEach(function(ackId) {\n        delete self.inProgressAckIds[ackId];\n      });\n\n      self.refreshPausedStatus_();\n    }\n\n    callback(err, resp);\n  });\n};\n\n/**\n * Add functionality on top of a message returned from the API, including the\n * ability to `ack` and `skip` the message.\n *\n * This also records the message as being \"in progress\". See\n * {module:subscription#refreshPausedStatus_}.\n *\n * @private\n *\n * @param {object} message - A message object.\n * @return {object} message - The original message after being decorated.\n * @param {function} message.ack - Ack the message.\n * @param {function} message.skip - Increate the number of available messages to\n *     simultaneously receive.\n */\nSubscription.prototype.decorateMessage_ = function(message) {\n  var self = this;\n\n  this.inProgressAckIds[message.ackId] = true;\n\n  message.ack = self.ack.bind(self, message.ackId);\n\n  message.skip = function() {\n    delete self.inProgressAckIds[message.ackId];\n    self.refreshPausedStatus_();\n  };\n\n  return message;\n};\n\n/**\n * Delete the subscription. Pull requests from the current subscription will be\n * errored once unsubscription is complete.\n *\n * @resource [Subscriptions: delete API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions/delete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this\n *     request.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * subscription.delete(function(err, apiResponse) {});\n */\nSubscription.prototype.delete = function(callback) {\n  var self = this;\n\n  callback = callback || util.noop;\n\n  var protoOpts = {\n    service: 'Subscriber',\n    method: 'deleteSubscription'\n  };\n\n  var reqOpts = {\n    subscription: this.name\n  };\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    if (err) {\n      callback(err, resp);\n      return;\n    }\n\n    self.closed = true;\n    self.removeAllListeners();\n\n    callback(null, resp);\n  });\n};\n\n/**\n * Pull messages from the subscribed topic. If messages were found, your\n * callback is executed with an array of message objects.\n *\n * Note that messages are pulled automatically once you register your first\n * event listener to the subscription, thus the call to `pull` is handled for\n * you. If you don't want to start pulling, simply don't register a\n * `subscription.on('message', function() {})` event handler.\n *\n * @todo Should not be racing with other pull.\n *\n * @resource [Subscriptions: pull API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions/pull}\n *\n * @param {object=} options - Configuration object.\n * @param {number} options.maxResults - Limit the amount of messages pulled.\n * @param {boolean} options.returnImmediately - If set, the system will respond\n *     immediately. Otherwise, wait until new messages are available. Returns if\n *     timeout is reached.\n * @param {function} callback - The callback function.\n *\n * @example\n * //-\n * // Pull all available messages.\n * //-\n * subscription.pull(function(err, messages) {\n *   // messages = [\n *   //   {\n *   //     ackId: '',     // ID used to acknowledge its receival.\n *   //     id: '',        // Unique message ID.\n *   //     data: '',      // Contents of the message.\n *   //     attributes: {} // Attributes of the message.\n *   //\n *   //     Helper functions:\n *   //     ack(callback): // Ack the message.\n *   //     skip():        // Free up 1 slot on the sub's maxInProgress value.\n *   //   },\n *   //   // ...\n *   // ]\n * });\n *\n * //-\n * // Pull a single message.\n * //-\n * var opts = {\n *   maxResults: 1\n * };\n *\n * subscription.pull(opts, function(err, messages, apiResponse) {});\n */\nSubscription.prototype.pull = function(options, callback) {\n  var self = this;\n  var MAX_EVENTS_LIMIT = 1000;\n\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!is.number(options.maxResults)) {\n    options.maxResults = MAX_EVENTS_LIMIT;\n  }\n\n  var protoOpts = {\n    service: 'Subscriber',\n    method: 'pull',\n    timeout: this.timeout\n  };\n\n  var reqOpts = {\n    subscription: this.name,\n    returnImmediately: !!options.returnImmediately,\n    maxMessages: options.maxResults\n  };\n\n  this.activeRequest_ = this.request(protoOpts, reqOpts, function(err, resp) {\n    self.activeRequest_ = null;\n\n    if (err) {\n      if (err.code === 504) {\n        // Simulate a server timeout where no messages were received.\n        resp = {\n          receivedMessages: []\n        };\n      } else {\n        callback(err, null, resp);\n        return;\n      }\n    }\n\n    var messages = arrify(resp.receivedMessages)\n      .map(function(msg) {\n        return Subscription.formatMessage_(msg, self.encoding);\n      })\n      .map(self.decorateMessage_.bind(self));\n\n    self.refreshPausedStatus_();\n\n    if (self.autoAck && messages.length !== 0) {\n      var ackIds = messages.map(prop('ackId'));\n\n      self.ack(ackIds, function(err) {\n        callback(err, messages, resp);\n      });\n    } else {\n      callback(null, messages, resp);\n    }\n  });\n};\n\n/**\n * Modify the ack deadline for a specific message. This method is useful to\n * indicate that more time is needed to process a message by the subscriber, or\n * to make the message available for redelivery if the processing was\n * interrupted.\n *\n * @resource [Subscriptions: modifyAckDeadline API Documentation]{@link https://cloud.google.com/pubsub/reference/rest/v1/projects.subscriptions/modifyAckDeadline}\n *\n * @param {object} options - The configuration object.\n * @param {string|string[]} options.ackIds - The ack id(s) to change.\n * @param {number} options.seconds - Number of seconds after call is made to\n *     set the deadline of the ack.\n * @param {Function=} callback - The callback function.\n *\n * @example\n * var options = {\n *   ackIds: ['abc'],\n *   seconds: 10 // Expire in 10 seconds from call.\n * };\n *\n * subscription.setAckDeadline(options, function(err, apiResponse) {});\n */\nSubscription.prototype.setAckDeadline = function(options, callback) {\n  callback = callback || util.noop;\n\n  var protoOpts = {\n    service: 'Subscriber',\n    method: 'modifyAckDeadline'\n  };\n\n  var reqOpts = {\n    subscription: this.name,\n    ackIds: arrify(options.ackIds),\n    ackDeadlineSeconds: options.seconds\n  };\n\n  this.request(protoOpts, reqOpts, function(err, resp) {\n    callback(err, resp);\n  });\n};\n\n/**\n * Begin listening for events on the subscription. This method keeps track of\n * how many message listeners are assigned, and then removed, making sure\n * polling is handled automatically.\n *\n * As long as there is one active message listener, the connection is open. As\n * soon as there are no more message listeners, the connection is closed.\n *\n * @private\n *\n * @example\n * subscription.listenForEvents_();\n */\nSubscription.prototype.listenForEvents_ = function() {\n  var self = this;\n\n  this.on('newListener', function(event) {\n    if (event === 'message') {\n      self.messageListeners++;\n      if (self.closed) {\n        self.closed = false;\n        self.startPulling_();\n      }\n    }\n  });\n\n  this.on('removeListener', function(event) {\n    if (event === 'message' && --self.messageListeners === 0) {\n      self.closed = true;\n\n      if (self.activeRequest_ && self.activeRequest_.cancel) {\n        self.activeRequest_.cancel();\n      }\n    }\n  });\n};\n\n/**\n * Update the status of `maxInProgress`. Ã… subscription becomes \"paused\" (not\n * pulling) when the number of messages that have yet to be ack'd or skipped\n * exceeds the user's specified `maxInProgress` value.\n *\n * This will start pulling when that event reverses: we were paused, but one or\n * more messages were just ack'd or skipped, freeing up room for more messages\n * to be consumed.\n *\n * @private\n */\nSubscription.prototype.refreshPausedStatus_ = function() {\n  var isCurrentlyPaused = this.paused;\n  var inProgress = Object.keys(this.inProgressAckIds).length;\n\n  this.paused = inProgress >= this.maxInProgress;\n\n  if (isCurrentlyPaused && !this.paused && this.messageListeners > 0) {\n    this.startPulling_();\n  }\n};\n\n/**\n * Poll the backend for new messages. This runs a loop to ping the API at the\n * provided interval from the subscription's instantiation. If one wasn't\n * provided, the default value is 10 milliseconds.\n *\n * If messages are received, they are emitted on the `message` event.\n *\n * Note: This method is automatically called once a message event handler is\n * assigned to the description.\n *\n * To stop pulling, see {module:pubsub/subscription#close}.\n *\n * @private\n *\n * @example\n * subscription.startPulling_();\n */\nSubscription.prototype.startPulling_ = function() {\n  var self = this;\n\n  if (this.closed || this.paused) {\n    return;\n  }\n\n  var maxResults;\n\n  if (this.maxInProgress < Infinity) {\n    maxResults = this.maxInProgress - Object.keys(this.inProgressAckIds).length;\n  }\n\n  this.pull({\n    returnImmediately: false,\n    maxResults: maxResults\n  }, function(err, messages, apiResponse) {\n    if (err) {\n      self.emit('error', err, apiResponse);\n    }\n\n    if (messages) {\n      messages.forEach(function(message) {\n        self.emit('message', message, apiResponse);\n      });\n    }\n\n    setTimeout(self.startPulling_.bind(self), self.interval);\n  });\n};\n\nmodule.exports = Subscription;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/resource/index.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module resource\n */\n\n'use strict';\n\nvar extend = require('extend');\nvar is = require('is');\nvar nodeutil = require('util');\n\n/**\n * @type {module:resource/project}\n * @private\n */\nvar Project = require('./project.js');\n\n/**\n * @type {module:common/service}\n * @private\n */\nvar Service = require('../common/service.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * [The Cloud Resource Manager](https://cloud.google.com/resource-manager/)\n * provides methods that you can use to programmatically manage your projects\n * in the Google Cloud Platform. With this API, you can do the following:\n *\n *   - Get a list of all projects associated with an account.\n *   - Create new projects.\n *   - Update existing projects.\n *   - Delete projects.\n *   - Recover projects.\n *\n * @alias module:resource\n * @constructor\n *\n * @classdesc\n * <p class=\"notice\">\n *   **This is a Beta release of Cloud Resource Manager.** This feature is not\n *   covered by any SLA or deprecation policy and may be subject to\n *   backward-incompatible changes.\n * </p>\n *\n * The object returned from <code>gcloud.resource</code> gives you complete\n * access to your projects.\n *\n * To learn more about Resource Manager, see\n * [What is the Google Cloud Resource Manager?](https://cloud.google.com/resource-manager)\n *\n * @param {object} options - [Configuration object](#/docs).\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var resource = gcloud.resource();\n */\nfunction Resource(options) {\n  if (!(this instanceof Resource)) {\n    options = util.normalizeArguments(this, options, {\n      projectIdRequired: false\n    });\n    return new Resource(options);\n  }\n\n  var config = {\n    baseUrl: 'https://cloudresourcemanager.googleapis.com/v1beta1',\n    scopes: ['https://www.googleapis.com/auth/cloud-platform'],\n    projectIdRequired: false\n  };\n\n  Service.call(this, config, options);\n\n  this.defaultProjectId_ = options.projectId;\n}\n\nnodeutil.inherits(Resource, Service);\n\n/**\n * Create a project.\n *\n * **This method only works if you are authenticated as yourself, e.g. using the\n * gcloud SDK.**\n *\n * @resource [Projects Overview]{@link https://cloud.google.com/compute/docs/networking#networks}\n * @resource [projects: create API Documentation]{@link https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects/create}\n *\n * @param {string} name - Name of the project.\n * @param {object=} options - See a\n *     [Project resource](https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects#Project).\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:resource/project} callback.project - The created Project\n *     object.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * resource.createProject('new project name', function(err, project) {\n *   if (!err) {\n *     // `project` is a new Project instance.\n *   }\n * });\n */\nResource.prototype.createProject = function(id, options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/projects',\n    json: extend({}, options, {\n      projectId: id\n    })\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var project = self.project(resp.projectId);\n    project.metadata = resp;\n\n    callback(null, project, resp);\n  });\n};\n\n/**\n * Get a list of projects.\n *\n * @resource [Projects Overview]{@link https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects}\n * @resource [projects: list API Documentation]{@link https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects/list}\n *\n * @param {object=} options - Operation search options.\n * @param {boolean} options.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {string} options.filter - An expression for filtering the results.\n * @param {number} options.maxApiCalls - Maximum number of API calls to make.\n * @param {number} options.maxResults - Maximum number of results to return.\n * @param {number} options.pageSize - Maximum number of projects to return.\n * @param {string} options.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {module:resource/project} callback.operations - Project objects from\n *     your account.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * resource.getProjects(function(err, projects) {\n *   // `projects` is an array of `Project` objects.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * function callback(err, projects, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     resource.getProjects(nextQuery, callback);\n *   }\n * }\n *\n * resource.getProjects({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the projects from your account as a readable object stream.\n * //-\n * resource.getProjects()\n *   .on('error', console.error)\n *   .on('data', function(project) {\n *     // `project` is a `Project` object.\n *   })\n *   .on('end', function() {\n *     // All projects retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * resource.getProjects()\n *   .on('data', function(project) {\n *     this.end();\n *   });\n */\nResource.prototype.getProjects = function(options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  this.request({\n    uri: '/projects',\n    qs: options\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    var projects = (resp.projects || []).map(function(project) {\n      var projectInstance = self.project(project.name);\n      projectInstance.metadata = project;\n      return projectInstance;\n    });\n\n    callback(null, projects, nextQuery, resp);\n  });\n};\n\n/**\n * Create a Project object. See {module:resoucemanager/createProject} to create\n * a project.\n *\n * @throws {Error} If an ID is not provided.\n *\n * @param {string} id - The ID of the project (eg: `grape-spaceship-123`).\n * @return {module:resource/project}\n *\n * @example\n * var project = resource.project('grape-spaceship-123');\n */\nResource.prototype.project = function(id) {\n  id = id || this.defaultProjectId_;\n\n  if (!id) {\n    throw new Error('A project ID is required.');\n  }\n\n  return new Project(this, id);\n};\n\n/*! Developer Documentation\n *\n * These methods can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(Resource, ['getProjects']);\n\nmodule.exports = Resource;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/resource/project.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module resource/project\n */\n\n'use strict';\n\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * @param {module:resource} resource - Resource object this project belongs to.\n * @param {string} id - The project's ID.\n */\n/**\n * A Project object allows you to interact with a Google Cloud Platform project.\n *\n * @resource [Projects Overview]{@link https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects}\n * @resource [Project Resource]{@link https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects#Project}\n *\n * @constructor\n * @alias module:resource/project\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var resource = gcloud.resource();\n * var project = resource.project('grape-spaceship-123');\n *\n * //-\n * // If no ID is passed to `resource.project()`, the returned object will refer\n * // to the project originally specified during instantiation of `gcloud`.\n * //\n * // Thus, in this case, these are equivalent:\n * //-\n * var project = resource.project('grape-spaceship-123');\n * var project = resource.project();\n */\nfunction Project(resource, id) {\n  var methods = {\n    /**\n     * Create a project.\n     *\n     * @param {object=} config - See {module:resource#createProject}.\n     *\n     * @example\n     * project.create(function(err, zone, apiResponse) {\n     *   if (!err) {\n     *     // The zone was created successfully.\n     *   }\n     * });\n     */\n    create: true,\n\n    /**\n     * Delete the project.\n     *\n     * **This method only works if you are authenticated as yourself, e.g. using\n     * the gcloud SDK.**\n     *\n     * @resource [projects: delete API Documentation]{@link https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects/delete}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * project.delete(function(err, apiResponse) {\n     *   if (!err) {\n     *     // The project was deleted!\n     *   }\n     * });\n     */\n    delete: true,\n\n    /**\n     * Check if the project exists.\n     *\n     * @param {function} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {boolean} callback.exists - Whether the project exists or not.\n     *\n     * @example\n     * project.exists(function(err, exists) {});\n     */\n    exists: true,\n\n    /**\n     * Get a project if it exists.\n     *\n     * You may optionally use this to \"get or create\" an object by providing an\n     * object with `autoCreate` set to `true`. Any extra configuration that is\n     * normally required for the `create` method must be contained within this\n     * object as well.\n     *\n     * @param {options=} options - Configuration object.\n     * @param {boolean} options.autoCreate - Automatically create the object if\n     *     it does not exist. Default: `false`\n     *\n     * @example\n     * project.get(function(err, project, apiResponse) {\n     *   // `project.metadata` has been populated.\n     * });\n     */\n    get: true,\n\n    /**\n     * Get the metadata for the project.\n     *\n     * @resource [projects: get API Documentation]{@link https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects/get}\n     *\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {?object} callback.metadata - Metadata of the project from the\n     *     API.\n     * @param {object} callback.apiResponse - Raw API response.\n     *\n     * @example\n     * project.getMetadata(function(err, metadata, apiResponse) {});\n     */\n    getMetadata: true,\n\n    /**\n     * Set the project's metadata.\n     *\n     * **This method only works if you are authenticated as yourself, e.g. using\n     * the gcloud SDK.**\n     *\n     * @resource [projects: update API Documentation]{@link https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects/update}\n     * @resource [Project Resource]{@link https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects#Project}\n     *\n     * @param {object} metadata - See a\n     *     [Project resource](https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects#Project).\n     * @param {function=} callback - The callback function.\n     * @param {?error} callback.err - An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse - The full API response.\n     *\n     * @example\n     * var metadata = {\n     *   name: 'New name'\n     * };\n     *\n     * project.setMetadata(metadata, function(err, apiResponse) {\n     *   if (!err) {\n     *     // The project has been successfully updated.\n     *   }\n     * });\n     */\n    setMetadata: {\n      reqOpts: {\n        method: 'PUT'\n      }\n    }\n  };\n\n  ServiceObject.call(this, {\n    parent: resource,\n    baseUrl: '/projects',\n    id: id,\n    createMethod: resource.createProject.bind(resource),\n    methods: methods\n  });\n}\n\nnodeutil.inherits(Project, ServiceObject);\n\n/**\n * Restore a project.\n *\n * **This method only works if you are authenticated as yourself, e.g. using the\n * gcloud SDK.**\n *\n * @resource [projects: undelete API Documentation]{@link https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects/undelete}\n *\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * project.restore(function(err, apiResponse) {\n *   if (!err) {\n *     // Project restored.\n *   }\n * });\n */\nProject.prototype.restore = function(callback) {\n  callback = callback || util.noop;\n\n  this.request({\n    method: 'POST',\n    uri: ':undelete'\n  }, function(err, resp) {\n    callback(err, resp);\n  });\n};\n\nmodule.exports = Project;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/storage/index.js":"/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module storage\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar extend = require('extend');\nvar nodeutil = require('util');\n\n/**\n * @type {module:storage/bucket}\n * @private\n */\nvar Bucket = require('./bucket.js');\n\n/**\n * @type {module:storage/channel}\n * @private\n */\nvar Channel = require('./channel.js');\n\n/**\n * @type {module:common/service}\n * @private\n */\nvar Service = require('../common/service.js');\n\n/**\n * @type {module:common/stream-router}\n * @private\n */\nvar streamRouter = require('../common/stream-router.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documentation\n *\n * Invoke this method to create a new Storage object bound with pre-determined\n * configuration options. For each object that can be created (e.g., a bucket),\n * there is an equivalent static and instance method. While they are classes,\n * they can be instantiated without use of the `new` keyword.\n *\n * @param {object} options - Configuration object.\n */\n/**\n * To access your Cloud Storage buckets, you will use the `bucket` function\n * returned from this `storage` object.\n *\n * The examples below will demonstrate the different usage patterns your app may\n * need to connect to `gcloud` and access your bucket.\n *\n * @alias module:storage\n * @constructor\n *\n * @classdesc\n * The `gcloud.storage` object contains a `bucket` function, which is how you\n * will interact with your Google Cloud Storage bucket.\n *\n * To learn more about Cloud Storage, see the\n * [Google Cloud Storage overview](https://cloud.google.com/storage/docs/overview).\n *\n * <h4>ACLs</h4>\n * Google Cloud Storage uses access control lists (ACLs) to manage object and\n * bucket access. ACLs are the mechanism you use to share files with other users\n * and allow other users to access your buckets and files.\n *\n * To learn more about ACLs, read this overview on\n * [Access Control](https://cloud.google.com/storage/docs/access-control).\n *\n * @param {object} options - [Configuration object](#/docs).\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'my-project'\n * });\n *\n * var gcs = gcloud.storage();\n */\nfunction Storage(options) {\n  if (!(this instanceof Storage)) {\n    options = util.normalizeArguments(this, options);\n    return new Storage(options);\n  }\n\n  var config = {\n    baseUrl: 'https://www.googleapis.com/storage/v1',\n    projectIdRequired: false,\n    scopes: [\n      'https://www.googleapis.com/auth/devstorage.full_control'\n    ]\n  };\n\n  Service.call(this, config, options);\n}\n\nnodeutil.inherits(Storage, Service);\n\n/**\n * Google Cloud Storage uses access control lists (ACLs) to manage object and\n * bucket access. ACLs are the mechanism you use to share objects with other\n * users and allow other users to access your buckets and objects.\n *\n * This object provides constants to refer to the three permission levels that\n * can be granted to an entity:\n *\n *   - `gcs.acl.OWNER_ROLE` - (\"OWNER\")\n *   - `gcs.acl.READER_ROLE` - (\"READER\")\n *   - `gcs.acl.WRITER_ROLE` - (\"WRITER\")\n *\n * @resource [About Access Control Lists]{@link https://cloud.google.com/storage/docs/access-control#About-Access-Control-Lists}\n *\n * @type {object}\n *\n * @example\n * var gcs = gcloud.storage({\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var albums = gcs.bucket('albums');\n *\n * //-\n * // Make all of the files currently in a bucket publicly readable.\n * //-\n * albums.acl.add({\n *   entity: 'allUsers',\n *   role: gcs.acl.READER_ROLE\n * }, function(err, aclObject) {});\n *\n * //-\n * // Make any new objects added to a bucket publicly readable.\n * //-\n * albums.acl.default.add({\n *   entity: 'allUsers',\n *   role: gcs.acl.READER_ROLE\n * }, function(err, aclObject) {});\n *\n * //-\n * // Grant a user ownership permissions to a bucket.\n * //-\n * albums.acl.add({\n *   entity: 'user-useremail@example.com',\n *   role: gcs.acl.OWNER_ROLE\n * }, function(err, aclObject) {});\n */\nStorage.acl = {\n  OWNER_ROLE: 'OWNER',\n  READER_ROLE: 'READER',\n  WRITER_ROLE: 'WRITER'\n};\n\nStorage.prototype.acl = Storage.acl;\n\n/**\n * Get a reference to a Google Cloud Storage bucket.\n *\n * @param {object|string} name - Name of the bucket.\n * @return {module:storage/bucket}\n *\n * @example\n * var gcloud = require('gcloud')({\n *   projectId: 'grape-spaceship-123',\n *   keyFilename: '/path/to/keyfile.json'\n * });\n *\n * var gcs = gcloud.storage();\n *\n * var albums = gcs.bucket('albums');\n * var photos = gcs.bucket('photos');\n */\nStorage.prototype.bucket = function(name) {\n  if (!name) {\n    throw new Error('A bucket name is needed to use Google Cloud Storage.');\n  }\n\n  return new Bucket(this, name);\n};\n\n/**\n * Reference a channel to receive notifications about changes to your bucket.\n *\n * @param {string} id - The ID of the channel.\n * @param {string} resourceId - The resource ID of the channel.\n * @return {module:storage/channel}\n *\n * @example\n * var channel = gcs.channel('id', 'resource-id');\n */\nStorage.prototype.channel = function(id, resourceId) {\n  return new Channel(this, id, resourceId);\n};\n\n/**\n * Create a bucket.\n *\n * Google Cloud Storage uses a flat namespace, so you can't create a bucket with\n * a name that is already in use. For more information, see\n * [Bucket Naming Guidelines](https://cloud.google.com/storage/docs/bucketnaming.html#requirements).\n *\n * @resource [Buckets: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/insert}\n * @resource [Durable Reduced Availability]{@link https://cloud.google.com/storage/docs/durable-reduced-availability}\n * @resource [Nearline]{@link https://cloud.google.com/storage/docs/nearline}\n * @resource [Storage Classes]{@link https://cloud.google.com/storage/docs/storage-classes}\n *\n * @throws {Error} If a name is not provided.\n *\n * @param {string} name - Name of the bucket to create.\n * @param {object=} metadata - Metadata to set for the bucket.\n * @param {boolean=} metadata.dra - Specify the storage class as\n *     [Durable Reduced Availability](https://goo.gl/26lthK).\n * @param {boolean=} metadata.nearline - Specify the storage class as\n *     [Nearline](https://goo.gl/sN5wNh).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:storage/bucket} callback.bucket - The newly created Bucket.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * var callback = function(err, bucket, apiResponse) {\n *   // `bucket` is a Bucket object.\n * };\n *\n * gcs.createBucket('new-bucket', callback);\n *\n * //-\n * // Create a bucket in a specific location and region. <em>See the <a\n * // href=\"https://cloud.google.com/storage/docs/json_api/v1/buckets/insert\">\n * // Official JSON API docs</a> for complete details on the `location` option.\n * // </em>\n * //-\n * var metadata = {\n *   location: 'US-CENTRAL1',\n *   dra: true\n * };\n *\n * gcs.createBucket('new-bucket', metadata, callback);\n *\n * //-\n * // Enable versioning on a new bucket.\n * //-\n * var metadata = {\n *   versioning: {\n *     enabled: true\n *   }\n * };\n *\n * gcs.createBucket('new-bucket', metadata, callback);\n */\nStorage.prototype.createBucket = function(name, metadata, callback) {\n  var self = this;\n\n  if (!name) {\n    throw new Error('A name is required to create a bucket.');\n  }\n\n  if (!callback) {\n    callback = metadata;\n    metadata = {};\n  }\n\n  var body = extend(metadata, {\n    name: name\n  });\n\n  var storageClasses = {\n    dra: 'DURABLE_REDUCED_AVAILABILITY',\n    nearline: 'NEARLINE'\n  };\n\n  Object.keys(storageClasses).forEach(function(storageClass) {\n    if (body[storageClass]) {\n      body.storageClass = storageClasses[storageClass];\n      delete body[storageClass];\n    }\n  });\n\n  this.request({\n    method: 'POST',\n    uri: '/b',\n    qs: {\n      project: this.projectId\n    },\n    json: body\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var bucket = self.bucket(name);\n    bucket.metadata = resp;\n\n    callback(null, bucket, resp);\n  });\n};\n\n/**\n * Get Bucket objects for all of the buckets in your project.\n *\n * @resource [Buckets: list API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/list}\n *\n * @param {object=} query - Query object.\n * @param {boolean} query.autoPaginate - Have pagination handled\n *     automatically. Default: true.\n * @param {number} query.maxApiCalls - Maximum number of API calls to make.\n * @param {number} query.maxResults - Maximum number of items plus prefixes to\n *     return.\n * @param {string} query.pageToken - A previously-returned page token\n *     representing part of the larger set of results to view.\n * @param {function=} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request\n * @param {module:storage/bucket[]} callback.buckets - List of all Buckets.\n * @param {?object} callback.nextQuery - If present, query with this object to\n *     check for more results.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * gcs.getBuckets(function(err, buckets) {\n *   if (!err) {\n *     // buckets is an array of Bucket objects.\n *   }\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * var callback = function(err, buckets, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     gcs.getBuckets(nextQuery, callback);\n *   }\n *\n *   // The `metadata` property is populated for you with the metadata at the\n *   // time of fetching.\n *   buckets[0].metadata;\n *\n *   // However, in cases where you are concerned the metadata could have\n *   // changed, use the `getMetadata` method.\n *   buckets[0].getMetadata(function(err, metadata, apiResponse) {});\n * };\n *\n * gcs.getBuckets({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // Get the buckets from your project as a readable object stream.\n * //-\n * gcs.getBuckets()\n *   .on('error', console.error)\n *   .on('data', function(bucket) {\n *     // bucket is a Bucket object.\n *   })\n *   .on('end', function() {\n *     // All buckets retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * gcs.getBuckets()\n *   .on('data', function(bucket) {\n *     this.end();\n *   });\n */\nStorage.prototype.getBuckets = function(query, callback) {\n  var self = this;\n\n  if (!callback) {\n    callback = query;\n    query = {};\n  }\n\n  query.project = query.project || this.projectId;\n\n  this.request({\n    uri: '/b',\n    qs: query\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var buckets = arrify(resp.items).map(function(bucket) {\n      var bucketInstance = self.bucket(bucket.id);\n      bucketInstance.metadata = bucket;\n      return bucketInstance;\n    });\n\n    var nextQuery = null;\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, query, { pageToken: resp.nextPageToken });\n    }\n\n    callback(null, buckets, nextQuery, resp);\n  });\n};\n\n/*! Developer Documentation\n *\n * This method can be used with either a callback or as a readable object\n * stream. `streamRouter` is used to add this dual behavior.\n */\nstreamRouter.extend(Storage, 'getBuckets');\n\nmodule.exports = Storage;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/storage/channel.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module storage/channel\n */\n\n'use strict';\n\nvar nodeutil = require('util');\n\n/**\n * @type {module:common/service-object}\n * @private\n */\nvar ServiceObject = require('../common/service-object.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/*! Developer Documenation\n *\n * @param {module:storage} storage - The Storage instance.\n */\n/**\n * Create a channel object to interact with a Google Cloud Storage channel.\n *\n * @resource [Object Change Notification]{@link https://cloud.google.com/storage/docs/object-change-notification}\n *\n * @constructor\n * @alias module:storage/bucket\n *\n * @param {string} id - The ID of the channel.\n * @param {string} resourceId - The resource ID of the channel.\n *\n * @example\n * var gcloud = require('gcloud');\n *\n * var gcs = gcloud.storage({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var channel = gcs.channel('id', 'resource-id');\n */\nfunction Channel(storage, id, resourceId) {\n  var config = {\n    parent: storage,\n    baseUrl: '/channels',\n\n    // An ID shouldn't be included in the API requests.\n    // RE: https://github.com/GoogleCloudPlatform/gcloud-node/issues/1145\n    id: '',\n\n    methods: {\n      // Only need `request`.\n    }\n  };\n\n  ServiceObject.call(this, config);\n\n  this.metadata.id = id;\n  this.metadata.resourceId = resourceId;\n}\n\nnodeutil.inherits(Channel, ServiceObject);\n\n/**\n * Stop this channel.\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.apiResponse - The full API response.\n *\n * @example\n * channel.stop(function(err, apiResponse) {\n *   if (!err) {\n *     // Channel stopped successfully.\n *   }\n * });\n */\nChannel.prototype.stop = function(callback) {\n  callback = callback || util.noop;\n\n  this.request({\n    method: 'POST',\n    uri: '/stop',\n    json: this.metadata\n  }, function(err, apiResponse) {\n    callback(err, apiResponse);\n  });\n};\n\nmodule.exports = Channel;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/translate/index.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module translate\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar extend = require('extend');\nvar is = require('is');\nvar prop = require('propprop');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\n/**\n * With [Google Translate](https://cloud.google.com/translate), you can\n * dynamically translate text between thousands of language pairs.\n *\n * The Google Translate API lets websites and programs integrate with Google\n * Translate programmatically.\n *\n * Google Translate API is available as a paid service. See the\n * [Pricing](https://cloud.google.com/translate/v2/pricing.html) and\n * [FAQ](https://cloud.google.com/translate/v2/faq.html) pages for details.\n *\n * **An API key is required for Translate.** See\n * [Identifying your application to Google](https://cloud.google.com/translate/v2/using_rest#auth).\n *\n * @constructor\n * @alias module:translate\n *\n * @classdesc\n * The object returned from `gcloud.translate` lets you translate arbitrary\n * string input into thousands of other languages.\n *\n * To learn more about the Translate API, see\n * [Getting Started](https://cloud.google.com/translate/v2/getting_started).\n *\n * @resource [Getting Started]{@link https://cloud.google.com/translate/v2/getting_started}\n * @resource [Identifying your application to Google]{@link https://cloud.google.com/translate/v2/using_rest#auth}\n *\n * @throws {Error} If an API key is not provided.\n *\n * @param {object} options - [Configuration object](#/docs).\n * @param {string} options.key - An API key.\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var translate = gcloud.translate({\n *   key: 'API Key'\n * });\n */\nfunction Translate(options) {\n  if (!(this instanceof Translate)) {\n    options = util.normalizeArguments(this, options, {\n      projectIdRequired: false\n    });\n    return new Translate(options);\n  }\n\n  if (!options.key) {\n    throw new Error('An API key is required to use the Translate API.');\n  }\n\n  this.options = options;\n  this.key = options.key;\n}\n\n/**\n * Detect the language used in a string or multiple strings.\n *\n * @resource [Detect Language]{@link https://cloud.google.com/translate/v2/using_rest#detect-language}\n *\n * @param {string|string[]} input - The source string input.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object|object[]} callback.results - If a single string input was\n *     given, a single result object is given. Otherwise, it is an array of\n *     result objects.\n * @param {string} callback.results[].language - The language code matched from\n *     the input.\n * @param {number=} callback.results[].confidence - A float 0 - 1. The higher\n *     the number, the higher the confidence in language detection. Note, this\n *     is not always returned from the API.\n * @param {string} callback.input - The original input that this was result was\n *     based on.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * //-\n * // Detect the language from a single string input.\n * //-\n * translate.detect('Hello', function(err, results) {\n *   if (!err) {\n *     // results = {\n *     //   language: 'en',\n *     //   confidence: 1,\n *     //   input: 'Hello'\n *     // }\n *   }\n * });\n *\n * //-\n * // Detect the languages used in multiple strings. Note that the results are\n * // now provied as an array.\n * //-\n * translate.detect([\n *   'Hello',\n *   'Hola'\n * ], function(err, results) {\n *   if (!err) {\n *     // results = [\n *     //   {\n *     //     language: 'en',\n *     //     confidence: 1,\n *     //     input: 'Hello'\n *     //   },\n *     //   {\n *     //     language: 'es',\n *     //     confidence: 1,\n *     //     input: 'Hola'\n *     //   }\n *     // ]\n *   }\n * });\n */\nTranslate.prototype.detect = function(input, callback) {\n  input = arrify(input);\n\n  this.request({\n    uri: '/detect',\n    useQuerystring: true,\n    qs: {\n      q: input\n    }\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var results = resp.data.detections.map(function(detection, index) {\n      var result = extend({}, detection[0], {\n        input: input[index]\n      });\n\n      // Deprecated.\n      delete result.isReliable;\n\n      return result;\n    });\n\n    if (input.length === 1) {\n      results = results[0];\n    }\n\n    callback(null, results, resp);\n  });\n};\n\n/**\n * Get an array of all supported languages.\n *\n * @resource [Discover Supported Languages]{@link https://cloud.google.com/translate/v2/using_rest#supported-languages}\n *\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {string[]} callback.languages - The supported ISO 639-1 language\n *     codes.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * translate.getLanguages(function(err, languages) {\n *   if (!err) {\n *     // languages = [\n *     //   'af',\n *     //   'ar',\n *     //   'az',\n *     //   ...\n *     // ]\n *   }\n * });\n */\nTranslate.prototype.getLanguages = function(callback) {\n  this.request({\n    uri: '/languages'\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var languages = resp.data.languages.map(prop('language'));\n    callback(null, languages, resp);\n  });\n};\n\n/**\n * Translate a string or multiple strings into another language.\n *\n * @resource [Translate Text](https://cloud.google.com/translate/v2/using_rest#Translate)\n *\n * @throws {Error} If `options` is provided as an object without a `to`\n *     property.\n *\n * @param {string|string[]} input - The source string input.\n * @param {string|object=} options - If a string, it is interpreted as the\n *     target ISO 639-1 language code to translate the source input to. (e.g.\n *     `en` for English). If an object, you may also specify the source\n *     language.\n * @param {string} options.from - The ISO 639-1 language code the source input\n *     is written in.\n * @param {string} options.to - The ISO 639-1 language code to translate the\n *     input to.\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object|object[]} callback.translations - If a single string input was\n *     given, a single translation is given. Otherwise, it is an array of\n *     translations.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * //-\n * // Pass a string and a language code to get the translation.\n * //-\n * translate.translate('Hello', 'es', function(err, translation) {\n *   if (!err) {\n *     // translation = 'Hola'\n *   }\n * });\n *\n * //-\n * // The source language is auto-detected by default. To manually set it,\n * // provide an object.\n * //-\n * var options = {\n *   from: 'en',\n *   to: 'es'\n * };\n *\n * translate.translate('Hello', options, function(err, translation) {\n *   if (!err) {\n *     // translation = 'Hola'\n *   }\n * });\n *\n * //-\n * // Translate multiple strings of input. Note that the results are\n * // now provied as an array.\n * //-\n * var input = [\n *   'Hello',\n *   'How are you today?'\n * ];\n *\n * translate.translate(input, 'es', function(err, translations) {\n *   if (!err) {\n *     // translations = [\n *     //   'Hola',\n *     //   'Como estas hoy?'\n *     // ]\n *   }\n * });\n */\nTranslate.prototype.translate = function(input, options, callback) {\n  var query = {\n    q: arrify(input)\n  };\n\n  if (is.string(options)) {\n    query.target = options;\n  } else {\n    if (options.from) {\n      query.source = options.from;\n    }\n\n    if (options.to) {\n      query.target = options.to;\n    }\n  }\n\n  if (!query.target) {\n    throw new Error('A target language is required to perform a translation.');\n  }\n\n  this.request({\n    uri: '',\n    useQuerystring: true,\n    qs: query\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var translations = resp.data.translations.map(prop('translatedText'));\n\n    if (query.q.length === 1) {\n      translations = translations[0];\n    }\n\n    callback(err, translations, resp);\n  });\n};\n\n/**\n * A custom request implementation. Requests to this API use an API key for an\n * application, not a bearer token from a service account. This means we skip\n * the `makeAuthenticatedRequest` portion of the typical request lifecycle, and\n * manually authenticate the request here.\n *\n * @private\n *\n * @param {object} reqOpts - Request options that are passed to `request`.\n * @param {function} callback - The callback function passed to `request`.\n */\nTranslate.prototype.request = function(reqOpts, callback) {\n  var BASE_URL = 'https://www.googleapis.com/language/translate/v2';\n\n  reqOpts.uri = BASE_URL + reqOpts.uri;\n\n  reqOpts = extend(true, {}, reqOpts, {\n    qs: {\n      key: this.key\n    }\n  });\n\n  util.makeRequest(reqOpts, this.options, callback);\n};\n\nmodule.exports = Translate;\n","/home/travis/build/npmtest/node-npmtest-gcloud/node_modules/gcloud/lib/vision/index.js":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module vision\n */\n\n'use strict';\n\nvar arrify = require('arrify');\nvar async = require('async');\nvar rgbHex = require('rgb-hex');\nvar extend = require('extend');\nvar format = require('string-format-obj');\nvar fs = require('fs');\nvar is = require('is');\nvar nodeutil = require('util');\nvar prop = require('propprop');\nvar request = require('request');\n\n/**\n * @type {module:storage/file}\n * @private\n */\nvar File = require('../storage/file.js');\n\n/**\n * @type {module:common/grpc-service}\n * @private\n */\nvar GrpcService = require('../common/grpc-service.js');\n\n/**\n * @type {module:common/service}\n * @private\n */\nvar Service = require('../common/service.js');\n\n/**\n * @type {module:common/util}\n * @private\n */\nvar util = require('../common/util.js');\n\nvar VERY_UNLIKELY = 0;\nvar UNLIKELY = 1;\nvar POSSIBLE = 2;\nvar LIKELY = 3;\nvar VERY_LIKELY = 4;\n\n/**\n * The [Cloud Vision API](https://cloud.google.com/vision/docs) allows easy\n * integration of vision detection features, including image labeling, face and\n * landmark detection, optical character recognition (OCR), and tagging of\n * explicit content.\n *\n * @constructor\n * @alias module:vision\n *\n * @classdesc\n * <p class=\"notice\">\n *   **This is a Beta release of Google Cloud Vision.** This API is not covered\n *   by any SLA or deprecation policy and may be subject to backward-\n *   incompatible changes.\n * </p>\n *\n * To learn more about the Vision API, see\n * [Getting Started](https://cloud.google.com/vision/docs/getting-started).\n *\n * @resource [Getting Started]{@link https://cloud.google.com/vision/docs/getting-started}\n * @resource [Image Best Practices]{@link https://cloud.google.com/vision/docs/image-best-practices}\n *\n * @param {object} options - [Configuration object](#/docs).\n *\n * @example\n * var gcloud = require('gcloud')({\n *   keyFilename: '/path/to/keyfile.json',\n *   projectId: 'grape-spaceship-123'\n * });\n *\n * var vision = gcloud.vision();\n */\nfunction Vision(options) {\n  if (!(this instanceof Vision)) {\n    options = util.normalizeArguments(this, options);\n    return new Vision(options);\n  }\n\n  var config = {\n    baseUrl: 'https://vision.googleapis.com/v1',\n    projectIdRequired: false,\n    scopes: [\n      'https://www.googleapis.com/auth/cloud-platform'\n    ]\n  };\n\n  Service.call(this, config, options);\n}\n\nnodeutil.inherits(Vision, Service);\n\nVision.likelihood = {\n  VERY_UNLIKELY: VERY_UNLIKELY,\n  UNLIKELY: UNLIKELY,\n  POSSIBLE: POSSIBLE,\n  LIKELY: LIKELY,\n  VERY_LIKELY: VERY_LIKELY\n};\n\n/**\n * Run image detection and annotation for an image or batch of images.\n *\n * This is an advanced API method that requires raw\n * [`AnnotateImageRequest`](https://cloud.google.com/vision/reference/rest/v1/images/annotate#AnnotateImageRequest)\n * objects to be provided. If that doesn't sound like what you're looking for,\n * you'll probably appreciate {module:vision#detect}.\n *\n * @resource [images.annotate API Reference]{@link https://cloud.google.com/vision/reference/rest/v1/images/annotate}\n *\n * @param {object|object[]} requests - An `AnnotateImageRequest` or array of\n *     `AnnotateImageRequest`s. See an\n *     [`AnnotateImageRequest`](https://cloud.google.com/vision/reference/rest/v1/images/annotate#AnnotateImageRequest).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object} callback.annotations - See an\n *     [`AnnotateImageResponse`](https://cloud.google.com/vision/reference/rest/v1/images/annotate#AnnotateImageResponse).\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * var annotateImageReq = {\n *   // See the link in the parameters for `AnnotateImageRequest`.\n * };\n *\n * vision.annotate(annotateImageReq, function(err, annotations, apiResponse) {\n *   // annotations = apiResponse.responses\n * });\n */\nVision.prototype.annotate = function(requests, callback) {\n  this.request({\n    method: 'POST',\n    uri: 'images:annotate',\n    json: {\n      requests: arrify(requests)\n    }\n  }, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    callback(null, resp.responses, resp);\n  });\n};\n\n/**\n * Detect properties from an image (or images) of one or more types.\n *\n * <h4>API simplifications</h4>\n *\n * The raw API response will return some values in a range from `VERY_UNLIKELY`\n * to `VERY_LIKELY`. For simplification, any value less than `LIKELY` is\n * converted to `false`.\n *\n *   - **False**\n *   - `VERY_UNLIKELY`\n *   - `UNLIKELY`\n *   - `POSSIBLE`\n *   - **True**\n *   - `LIKELY`\n *   - `VERY_LIKELY`\n *\n * The API will also return many values represented in a `[0,1]` range. We\n * convert these to a `[0,100]` value. E.g, `0.4` is represented as `40`.\n *\n * For the response in the original format, review the `apiResponse` argument\n * your callback receives.\n *\n * @param {string|string[]|module:storage/file|module:storage/file[]} images -\n *     The source image(s) to run the detection on. It can be either a local\n *     image path, a remote image URL, or a gcloud File object.\n * @param {string[]|object=} options - An array of types or a configuration\n *     object.\n * @param {object=} options.imageContext - See an\n *     [`ImageContext`](https://cloud.google.com/vision/reference/rest/v1/images/annotate#ImageContext)\n *     resource.\n * @param {number} options.maxResults - The maximum number of results, per type,\n *     to return in the response.\n * @param {string[]} options.types - An array of feature types to detect from\n *     the provided images. Acceptable values: `faces`, `landmarks`, `labels`,\n *     `logos`, `properties`, `safeSearch`, `text`.\n * @param {boolean=} options.verbose - Use verbose mode, which returns a less-\n *     simplistic representation of the annotation (default: `false`).\n * @param {function} callback - The callback function.\n * @param {?error} callback.err - An error returned while making this request.\n * @param {object|object[]} callback.detections - If a single detection type was\n *     asked for, it will be returned in its raw form; either an object or array\n *     of objects. If multiple detection types were requested, you will receive\n *     an object with keys for each detection type (listed above in\n *     `config.types`). Additionally, if multiple images were provided, you will\n *     receive an array of detection objects, each representing an image. See\n *     the examples below for more information.\n * @param {object[]} callback.detections.errors - It's possible for part of your\n *     request to be completed successfully, while a single feature request was\n *     not successful. Each returned detection will have an `errors` array,\n *     including any of these errors which may have occurred.\n * @param {object} callback.apiResponse - Raw API response.\n *\n * @example\n * var types = [\n *   'face',\n *   'label'\n * ];\n *\n * vision.detect('image.jpg', types, function(err, detections, apiResponse) {\n *   // detections = {\n *   //   faces: [...],\n *   //   labels: [...]\n *   // }\n * });\n *\n * //-\n * // Run feature detection over a remote image.\n * //\n * // *Note: This is not an officially supported feature of the Vision API. Our\n * // library will make a request to the URL given, convert it to base64, and\n * // send that upstream.*\n * //-\n * var img = 'https://upload.wikimedia.org/wikipedia/commons/5/51/Google.png';\n * vision.detect(img, types, function(err, detection, apiResponse) {});\n *\n * //-\n * // Supply multiple images for feature detection.\n * //-\n * var images = [\n *   'image.jpg',\n *   'image-two.jpg'\n * ];\n *\n * var types = [\n *   'face',\n *   'label'\n * ];\n *\n * vision.detect(images, types, function(err, detections, apiResponse) {\n *   // detections = [\n *   //   // Detections for image.jpg:\n *   //   {\n *   //     faces: [...],\n *   //     labels: [...]\n *   //   },\n *   //\n *   //   // Detections for image-two.jpg:\n *   //   {\n *   //     faces: [...],\n *   //     labels: [...]\n *   //   }\n *   // ]\n * });\n *\n * //-\n * // It's possible for part of your request to be completed successfully, while\n * // a single feature request was not successful. Each returned detection will\n * // have an `errors` array, including any of these errors which may have\n * // occurred.\n * //-\n * vision.detect('malformed-image.jpg', types, function(err, detections) {\n *   if (detections.faces.errors.length > 0) {\n *     // Errors occurred while trying to use this image for a face annotation.\n *   }\n * });\n */\nVision.prototype.detect = function(images, options, callback) {\n  var self = this;\n  var isSingleImage = !is.array(images) || images.length === 1;\n\n  if (!is.object(options)) {\n    options = {\n      types: options\n    };\n  }\n\n  var types = arrify(options.types);\n\n  var typeShortNameToFullName = {\n    face: 'FACE_DETECTION',\n    faces: 'FACE_DETECTION',\n\n    label: 'LABEL_DETECTION',\n    labels: 'LABEL_DETECTION',\n\n    landmark: 'LANDMARK_DETECTION',\n    landmarks: 'LANDMARK_DETECTION',\n\n    logo: 'LOGO_DETECTION',\n    logos: 'LOGO_DETECTION',\n\n    properties: 'IMAGE_PROPERTIES',\n\n    safeSearch: 'SAFE_SEARCH_DETECTION',\n\n    text: 'TEXT_DETECTION'\n  };\n\n  var typeShortNameToRespName = {\n    face: 'faceAnnotations',\n    faces: 'faceAnnotations',\n\n    label: 'labelAnnotations',\n    labels: 'labelAnnotations',\n\n    landmark: 'landmarkAnnotations',\n    landmarks: 'landmarkAnnotations',\n\n    logo: 'logoAnnotations',\n    logos: 'logoAnnotations',\n\n    properties: 'imagePropertiesAnnotation',\n\n    safeSearch: 'safeSearchAnnotation',\n\n    text: 'textAnnotations'\n  };\n\n  var typeRespNameToShortName = {\n    errors: 'errors',\n    faceAnnotations: 'faces',\n    imagePropertiesAnnotation: 'properties',\n    labelAnnotations: 'labels',\n    landmarkAnnotations: 'landmarks',\n    logoAnnotations: 'logos',\n    safeSearchAnnotation: 'safeSearch',\n    textAnnotations: 'text'\n  };\n\n  Vision.findImages_(images, function(err, images) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var config = [];\n\n    images.forEach(function(image) {\n      types.forEach(function(type) {\n        var typeName = typeShortNameToFullName[type];\n\n        if (!typeName) {\n          throw new Error('Requested detection feature not found: ' + type);\n        }\n\n        var cfg = {\n          image: image,\n          features: {\n            type: typeName\n          }\n        };\n\n        if (is.object(options.imageContext)) {\n          cfg.imageContext = options.imageContext;\n        }\n\n        if (is.number(options.maxResults)) {\n          cfg.features.maxResults = options.maxResults;\n        }\n\n        config.push(cfg);\n      });\n    });\n\n    self.annotate(config, function(err, annotations, resp) {\n      if (err) {\n        callback(err, null, resp);\n        return;\n      }\n\n      var originalResp = extend(true, {}, resp);\n\n      var detections = images\n        .map(groupDetectionsByImage)\n        .map(assignTypeToEmptyAnnotations)\n        .map(combineErrors)\n        .map(flattenAnnotations)\n        .map(decorateAnnotations);\n\n      // If only a single image was given, expose it from the array.\n      callback(null, isSingleImage ? detections[0] : detections, originalResp);\n\n      function groupDetectionsByImage() {\n        // detections = [\n        //   // Image one:\n        //   [\n        //     {\n        //       faceAnnotations: {},\n        //       labelAnnotations: {},\n        //       ...\n        //     }\n        //   ],\n        //\n        //   // Image two:\n        //   [\n        //     {\n        //       faceAnnotations: {},\n        //       labelAnnotations: {},\n        //       ...\n        //     }\n        //   ]\n        // ]\n        return annotations.splice(0, types.length);\n      }\n\n      function assignTypeToEmptyAnnotations(annotations) {\n        // Before:\n        //   [\n        //     {}, // What annotation type was attempted?\n        //     { labelAnnotations: {...} }\n        //   ]\n        //\n        // After:\n        //   [\n        //     { faceAnnotations: {} },\n        //     { labelAnnotations: {...} }\n        //   ]\n        return annotations.map(function(annotation, index) {\n          var detectionType = types[index];\n          var typeName = typeShortNameToRespName[detectionType];\n\n          if (is.empty(annotation) || annotation.error) {\n            var isPlural = typeName.charAt(typeName.length - 1) === 's';\n            annotation[typeName] = isPlural ? [] : {};\n          }\n\n          return annotation;\n        });\n      }\n\n      function combineErrors(annotations) {\n        // Before:\n        //   [\n        //     {\n        //       faceAnnotations: [],\n        //       error: {...}\n        //     },\n        //     {\n        //       imagePropertiesAnnotation: {},\n        //       error: {...}\n        //     }\n        //   ]\n\n        // After:\n        //   [\n        //     faceAnnotations: [],\n        //     imagePropertiesAnnotation: {},\n        //     errors: [\n        //       {...},\n        //       {...}\n        //     ]\n        //   ]\n        var errors = [];\n\n        annotations.forEach(function(annotation) {\n          var annotationKey = Object.keys(annotation)[0];\n\n          if (annotationKey === 'error') {\n            errors.push(annotation.error);\n            delete annotation.error;\n          }\n\n          return annotation;\n        });\n\n        annotations.push({\n          errors: errors\n        });\n\n        return annotations;\n      }\n\n      function flattenAnnotations(annotations) {\n        return extend.apply(null, annotations);\n      }\n\n      function formatAnnotationBuilder(type) {\n        return function(annotation) {\n          if (is.empty(annotation)) {\n            return annotation;\n          }\n\n          var formatMethodMap = {\n            errors: Vision.formatError_,\n            faceAnnotations: Vision.formatFaceAnnotation_,\n            imagePropertiesAnnotation: Vision.formatImagePropertiesAnnotation_,\n            labelAnnotations: Vision.formatEntityAnnotation_,\n            landmarkAnnotations: Vision.formatEntityAnnotation_,\n            logoAnnotations: Vision.formatEntityAnnotation_,\n            safeSearchAnnotation: Vision.formatSafeSearchAnnotation_,\n            textAnnotations: Vision.formatEntityAnnotation_\n          };\n\n          return formatMethodMap[type](annotation, options);\n        };\n      }\n\n      function decorateAnnotations(annotations) {\n        for (var annotationType in annotations) {\n          if (annotations.hasOwnProperty(annotationType)) {\n            var annotationGroup = arrify(annotations[annotationType]);\n\n            var formattedAnnotationGroup = annotationGroup\n              .map(formatAnnotationBuilder(annotationType));\n\n            // An annotation can be singular, e.g. SafeSearch. It is either\n            // violent or not. Unlike face detection, where there can be\n            // multiple results.\n            //\n            // Be sure the original type (object or array) is preserved and\n            // not wrapped in an array if it wasn't originally.\n            if (!is.array(annotations[annotationType])) {\n              formattedAnnotationGroup = formattedAnnotationGroup[0];\n            }\n\n            delete annotations[annotationType];\n            var typeShortName = typeRespNameToShortName[annotationType];\n            annotations[typeShortName] = formattedAnnotationGroup;\n          }\n        }\n\n        if (types.length === 1) {\n          // Only a single detection type was asked for, so no need to box in\n          // the results. Make them accessible without using a key.\n          var key = Object.keys(annotations)[0];\n          var errors = annotations.errors;\n          annotations = annotations[key];\n          annotations.errors = errors;\n        }\n\n        return annotations;\n      }\n    });\n  });\n};\n\n/**\n * Run face detection against an image.\n *\n * <h4>Parameters</h4>\n *\n * See {module:vision#detect}.\n *\n * @resource [FaceAnnotation JSON respresentation]{@link https://cloud.google.com/vision/reference/rest/v1/images/annotate#FaceAnnotation}\n *\n * @example\n * vision.detectFaces('image.jpg', function(err, faces, apiResponse) {\n *   // faces = [\n *   //   {\n *   //     angles: {\n *   //       pan: -8.1090336,\n *   //       roll: -5.0002542,\n *   //       tilt: 18.012161\n *   //     },\n *   //     bounds: {\n *   //       head: [\n *   //         {\n *   //           x: 1\n *   //         },\n *   //         {\n *   //           x: 295\n *   //         },\n *   //         {\n *   //           x: 295,\n *   //           y: 301\n *   //         },\n *   //         {\n *   //           x: 1,\n *   //           y: 301\n *   //         }\n *   //       ],\n *   //       face: [\n *   //         {\n *   //           x: 28,\n *   //           y: 40\n *   //         },\n *   //         {\n *   //           x: 250,\n *   //           y: 40\n *   //         },\n *   //         {\n *   //           x: 250,\n *   //           y: 262\n *   //         },\n *   //         {\n *   //           x: 28,\n *   //           y: 262\n *   //         }\n *   //       ]\n *   //     },\n *   //     features: {\n *   //       confidence: 34.489909,\n *   //       chin: {\n *   //         center: {\n *   //           x: 143.34183,\n *   //           y: 262.22998,\n *   //           z: -57.388493\n *   //         },\n *   //         left: {\n *   //           x: 63.102425,\n *   //           y: 248.99081,\n *   //           z: 44.207638\n *   //         },\n *   //         right: {\n *   //           x: 241.72728,\n *   //           y: 225.53488,\n *   //           z: 19.758242\n *   //         }\n *   //       },\n *   //       ears: {\n *   //         left: {\n *   //           x: 54.872219,\n *   //           y: 207.23712,\n *   //           z: 97.030685\n *   //         },\n *   //         right: {\n *   //           x: 252.67567,\n *   //           y: 180.43124,\n *   //           z: 70.15992\n *   //         }\n *   //       },\n *   //       eyebrows: {\n *   //         left: {\n *   //           left: {\n *   //             x: 58.790176,\n *   //             y: 113.28249,\n *   //             z: 17.89735\n *   //           },\n *   //           right: {\n *   //             x: 106.14151,\n *   //             y: 98.593758,\n *   //             z: -13.116687\n *   //           },\n *   //           top: {\n *   //             x: 80.248711,\n *   //             y: 94.04303,\n *   //             z: 0.21131183\n *   //           }\n *   //         },\n *   //         right: {\n *   //           left: {\n *   //             x: 148.61565,\n *   //             y: 92.294594,\n *   //             z: -18.804882\n *   //           },\n *   //           right: {\n *   //             x: 204.40808,\n *   //             y: 94.300117,\n *   //             z: -2.0009689\n *   //           },\n *   //           top: {\n *   //             x: 174.70135,\n *   //             y: 81.580917,\n *   //             z: -12.702137\n *   //           }\n *   //         }\n *   //       },\n *   //       eyes: {\n *   //         left: {\n *   //           bottom: {\n *   //             x: 84.883934,\n *   //             y: 134.59479,\n *   //             z: -2.8677137\n *   //           },\n *   //           center: {\n *   //             x: 83.707092,\n *   //             y: 128.34,\n *   //             z: -0.00013388535\n *   //           },\n *   //           left: {\n *   //             x: 72.213913,\n *   //             y: 132.04138,\n *   //             z: 9.6985674\n *   //           },\n *   //           pupil: {\n *   //             x: 86.531624,\n *   //             y: 126.49807,\n *   //             z: -2.2496929\n *   //           },\n *   //           right: {\n *   //             x: 105.28892,\n *   //             y: 125.57655,\n *   //             z: -2.51554\n *   //           },\n *   //           top: {\n *   //             x: 86.706947,\n *   //             y: 119.47144,\n *   //             z: -4.1606765\n *   //           }\n *   //         },\n *   //         right: {\n *   //           bottom: {\n *   //             x: 179.30353,\n *   //             y: 121.03307,\n *   //             z: -14.843414\n *   //           },\n *   //           center: {\n *   //             x: 181.17694,\n *   //             y: 115.16437,\n *   //             z: -12.82961\n *   //           },\n *   //           left: {\n *   //             x: 158.2863,\n *   //             y: 118.491,\n *   //             z: -9.723031\n *   //           },\n *   //           pupil: {\n *   //             x: 175.99976,\n *   //             y: 114.64407,\n *   //             z: -14.53744\n *   //           },\n *   //           right: {\n *   //             x: 194.59413,\n *   //             y: 115.91954,\n *   //             z: -6.952745\n *   //           },\n *   //           top: {\n *   //             x: 173.99446,\n *   //             y: 107.94287,\n *   //             z: -16.050705\n *   //           }\n *   //         }\n *   //       },\n *   //       forehead: {\n *   //         x: 126.53813,\n *   //         y: 93.812057,\n *   //         z: -18.863352\n *   //       },\n *   //       lips: {\n *   //         bottom: {\n *   //           x: 137.28528,\n *   //           y: 219.23564,\n *   //           z: -56.663128\n *   //         },\n *   //         top: {\n *   //           x: 134.74164,\n *   //           y: 192.50438,\n *   //           z: -53.876408\n *   //         }\n *   //       },\n *   //       mouth: {\n *   //         center: {\n *   //           x: 136.43481,\n *   //           y: 204.37952,\n *   //           z: -51.620205\n *   //         },\n *   //         left: {\n *   //           x: 104.53558,\n *   //           y: 214.05037,\n *   //           z: -30.056231\n *   //         },\n *   //         right: {\n *   //           x: 173.79134,\n *   //           y: 204.99333,\n *   //           z: -39.725758\n *   //         }\n *   //       },\n *   //       nose: {\n *   //         bottom: {\n *   //           center: {\n *   //             x: 133.81947,\n *   //             y: 173.16437,\n *   //             z: -48.287724\n *   //           },\n *   //           left: {\n *   //             x: 110.98372,\n *   //             y: 173.61331,\n *   //             z: -29.7784\n *   //           },\n *   //           right: {\n *   //             x: 161.31354,\n *   //             y: 168.24527,\n *   //             z: -36.1628\n *   //           }\n *   //         },\n *   //         tip: {\n *   //           x: 128.14919,\n *   //           y: 153.68129,\n *   //           z: -63.198204\n *   //         },\n *   //         top: {\n *   //           x: 127.83745,\n *   //           y: 110.17557,\n *   //           z: -22.650913\n *   //         }\n *   //       }\n *   //     },\n *   //     confidence: 56.748849,\n *   //     blurry: false,\n *   //     dark: false,\n *   //     happy: false,\n *   //     hat: false,\n *   //     mad: false,\n *   //     sad: false,\n *   //     surprised: false\n *   //   }\n *   // ]\n * });\n *\n * //-\n * // Our library simplifies the response from the API. Use the map below to see\n * // each response name's original name.\n * //-\n * var shortNameToLongNameMap = {\n *   chin: {\n *     center: 'CHIN_GNATHION',\n *     left: 'CHIN_LEFT_GONION',\n *     right: 'CHIN_RIGHT_GONION'\n *   },\n *\n *   ears: {\n *     left: 'LEFT_EAR_TRAGION',\n *     right: 'RIGHT_EAR_TRAGION'\n *   },\n *\n *   eyebrows: {\n *     left: {\n *       left: 'LEFT_OF_LEFT_EYEBROW',\n *       right: 'RIGHT_OF_LEFT_EYEBROW',\n *       top: 'LEFT_EYEBROW_UPPER_MIDPOINT'\n *     },\n *     right: {\n *       left: 'LEFT_OF_RIGHT_EYEBROW',\n *       right: 'RIGHT_OF_RIGHT_EYEBROW',\n *       top: 'RIGHT_EYEBROW_UPPER_MIDPOINT'\n *     }\n *   },\n *\n *   eyes: {\n *     left: {\n *       bottom: 'LEFT_EYE_BOTTOM_BOUNDARY',\n *       center: 'LEFT_EYE',\n *       left: 'LEFT_EYE_LEFT_CORNER',\n *       pupil: 'LEFT_EYE_PUPIL',\n *       right: 'LEFT_EYE_RIGHT_CORNER',\n *       top: 'LEFT_EYE_TOP_BOUNDARY'\n *     },\n *     right: {\n *       bottom: 'RIGHT_EYE_BOTTOM_BOUNDARY',\n *       center: 'RIGHT_EYE',\n *       left: 'RIGHT_EYE_LEFT_CORNER',\n *       pupil: 'RIGHT_EYE_PUPIL',\n *       right: 'RIGHT_EYE_RIGHT_CORNER',\n *       top: 'RIGHT_EYE_TOP_BOUNDARY'\n *     }\n *   },\n *\n *   forehead: 'FOREHEAD_GLABELLA',\n *\n *   lips: {\n *     bottom: 'LOWER_LIP',\n *     top: 'UPPER_LIP'\n *   },\n *\n *   mouth: {\n *     center: 'MOUTH_CENTER',\n *     left: 'MOUTH_LEFT',\n *     right: 'MOUTH_RIGHT'\n *   },\n *\n *   nose: {\n *     bottom: {\n *       center: 'NOSE_BOTTOM_CENTER',\n *       left: 'NOSE_BOTTOM_LEFT',\n *       right: 'NOSE_BOTTOM_RIGHT'\n *     },\n *     tip: 'NOSE_TIP',\n *     top: 'MIDPOINT_BETWEEN_EYES'\n *   }\n * };\n */\nVision.prototype.detectFaces = function(images, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({}, options, {\n    types: ['faces']\n  });\n\n  this.detect(images, options, callback);\n};\n\n/**\n * Annotate an image with descriptive labels.\n *\n * <h4>Parameters</h4>\n *\n * See {module:vision#detect}.\n *\n * @resource [EntityAnnotation JSON representation]{@link https://cloud.google.com/vision/reference/rest/v1/images/annotate#EntityAnnotation}\n *\n * @example\n * vision.detectLabels('image.jpg', function(err, labels, apiResponse) {\n *   // labels = [\n *   //   'classical sculpture',\n *   //   'statue',\n *   //   'landmark',\n *   //   'ancient history',\n *   //   'artwork'\n *   // ]\n * });\n *\n * //-\n * // Activate `verbose` mode for a more detailed response.\n * //-\n * var opts = {\n *   verbose: true\n * };\n *\n * vision.detectLabels('image.jpg', opts, function(err, labels, apiResponse) {\n *   // labels = [\n *   //   {\n *   //     desc: 'classical sculpture',\n *   //     id: '/m/095yjj',\n *   //     score: 98.092282\n *   //   },\n *   //   {\n *   //     desc: 'statue',\n *   //     id: '/m/013_1c',\n *   //     score: 90.66112\n *   //   },\n *   //   // ...\n *   // ]\n * });\n */\nVision.prototype.detectLabels = function(images, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({}, options, {\n    types: ['labels']\n  });\n\n  this.detect(images, options, callback);\n};\n\n/**\n * Detect the landmarks from an image.\n *\n * <h4>Parameters</h4>\n *\n * See {module:vision#detect}.\n *\n * @resource [EntityAnnotation JSON representation]{@link https://cloud.google.com/vision/reference/rest/v1/images/annotate#EntityAnnotation}\n *\n * @example\n * vision.detectLandmarks('image.jpg', function(err, landmarks, apiResponse) {\n *   // landmarks = [\n *   //   'Mount Rushmore'\n *   // ]\n * });\n *\n * //-\n * // Activate `verbose` mode for a more detailed response.\n * //-\n * var image = 'image.jpg';\n *\n * var opts = {\n *   verbose: true\n * };\n *\n * vision.detectLandmarks(image, opts, function(err, landmarks, apiResponse) {\n *   // landmarks = [\n *   //   {\n *   //     desc: 'Mount Rushmore',\n *   //     id: '/m/019dvv',\n *   //     score: 28.651705,\n *   //     bounds: [\n *   //       {\n *   //         x: 79,\n *   //         y: 130\n *   //       },\n *   //       {\n *   //         x: 284,\n *   //         y: 130\n *   //       },\n *   //       {\n *   //         x: 284,\n *   //         y: 226\n *   //       },\n *   //       {\n *   //         x: 79,\n *   //         y: 226\n *   //       }\n *   //     ],\n *   //     locations: [\n *   //       {\n *   //         latitude: 43.878264,\n *   //         longitude: -103.45700740814209\n *   //       }\n *   //     ]\n *   //   }\n *   // ]\n * });\n */\nVision.prototype.detectLandmarks = function(images, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({}, options, {\n    types: ['landmarks']\n  });\n\n  this.detect(images, options, callback);\n};\n\n/**\n * Detect the logos from an image.\n *\n * <h4>Parameters</h4>\n *\n * See {module:vision#detect}.\n *\n * @resource [EntityAnnotation JSON representation]{@link https://cloud.google.com/vision/reference/rest/v1/images/annotate#EntityAnnotation}\n *\n * @example\n * vision.detectLogos('image.jpg', function(err, logos, apiResponse) {\n *   // logos = [\n *   //   'Google'\n *   // ]\n * });\n *\n * //-\n * // Activate `verbose` mode for a more detailed response.\n * //-\n * var options = {\n *   verbose: true\n * };\n *\n * vision.detectLogos('image.jpg', options, function(err, logos, apiResponse) {\n *   // logos = [\n *   //   {\n *   //     desc: 'Google',\n *   //     id: '/m/045c7b',\n *   //     score: 64.35439,\n *   //     bounds: [\n *   //       {\n *   //         x: 11,\n *   //         y: 11\n *   //       },\n *   //       {\n *   //         x: 330,\n *   //         y: 11\n *   //       },\n *   //       {\n *   //         x: 330,\n *   //         y: 72\n *   //       },\n *   //       {\n *   //         x: 11,\n *   //         y: 72\n *   //       }\n *   //     ]\n *   //   }\n *   // ]\n * });\n */\nVision.prototype.detectLogos = function(images, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({}, options, {\n    types: ['logos']\n  });\n\n  this.detect(images, options, callback);\n};\n\n/**\n * Get a set of properties about an image, such as its dominant colors.\n *\n * <h4>Parameters</h4>\n *\n * See {module:vision#detect}.\n *\n * @resource [ImageProperties JSON representation]{@link https://cloud.google.com/vision/reference/rest/v1/images/annotate#ImageProperties}\n *\n * @example\n * vision.detectProperties('image.jpg', function(err, props, apiResponse) {\n *   // props = {\n *   //   colors: [\n *   //     '3b3027',\n *   //     '727d81',\n *   //     '3f2f22',\n *   //     '838e92',\n *   //     '482a16',\n *   //     '5f4f3c',\n *   //     '261b14',\n *   //     'b39b7f',\n *   //     '51473f',\n *   //     '2c1e12'\n *   //   ]\n *   // }\n * });\n *\n * //-\n * // Activate `verbose` mode for a more detailed response.\n * //-\n * var image = 'image.jpg';\n *\n * var options = {\n *   verbose: true\n * };\n *\n * vision.detectProperties(image, options, function(err, props, apiResponse) {\n *   // props = {\n *   //   colors: [\n *   //     {\n *   //       red: 59,\n *   //       green: 48,\n *   //       blue: 39,\n *   //       score: 26.618013,\n *   //       coverage: 15.948276,\n *   //       hex: '3b3027'\n *   //     },\n *   //     {\n *   //       red: 114,\n *   //       green: 125,\n *   //       blue: 129,\n *   //       score: 10.319714,\n *   //       coverage: 8.3977409,\n *   //       hex: '727d81'\n *   //     },\n *   //     // ...\n *   //   ]\n *   // }\n * });\n */\nVision.prototype.detectProperties = function(images, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({}, options, {\n    types: ['properties']\n  });\n\n  this.detect(images, options, callback);\n};\n\n/**\n * Detect the SafeSearch flags from an image.\n *\n * <h4>Parameters</h4>\n *\n * See {module:vision#detect}.\n *\n * @resource [SafeSearch JSON representation]{@link https://cloud.google.com/vision/reference/rest/v1/images/annotate#SafeSearchAnnotation}\n *\n * @example\n * vision.detectSafeSearch('image.jpg', function(err, safeSearch, apiResponse) {\n *   // safeSearch = {\n *   //   adult: false,\n *   //   medical: false,\n *   //   spoof: false,\n *   //   violence: true\n *   // }\n * });\n */\nVision.prototype.detectSafeSearch = function(images, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({}, options, {\n    types: ['safeSearch']\n  });\n\n  this.detect(images, options, callback);\n};\n\n/**\n * Detect the text within an image.\n *\n * <h4>Parameters</h4>\n *\n * See {module:vision#detect}.\n *\n * @example\n * vision.detectText('image.jpg', function(err, text, apiResponse) {\n *   // text = [\n *   //   'This was text found in the image'\n *   // ]\n * });\n *\n * //-\n * // Activate `verbose` mode for a more detailed response.\n * //-\n * var options = {\n *   verbose: true\n * };\n *\n * vision.detectText('image.jpg', options, function(err, text, apiResponse) {\n *   // text = [\n *   //   {\n *   //     desc: 'This was text found in the image',\n *   //     bounds: [\n *   //       {\n *   //          x: 4,\n *   //          y: 5\n *   //       },\n *   //       {\n *   //          x: 493,\n *   //          y: 5\n *   //       },\n *   //       {\n *   //          x: 493,\n *   //          y: 89\n *   //       },\n *   //       {\n *   //          x: 4,\n *   //          y: 89\n *   //       }\n *   //     ]\n *   //   }\n *   // ]\n * });\n */\nVision.prototype.detectText = function(images, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({}, options, {\n    types: ['text']\n  });\n\n  this.detect(images, options, callback);\n};\n\n/**\n * Convert an object with \"likelihood\" values to a boolean-representation, based\n * on the lowest likelihood provided.\n *\n * @private\n *\n * @example\n * Vision.convertToBoolean_(Vision.likelihood.VERY_LIKELY, {\n *   blurry: 'POSSIBLE'\n * });\n * // { blurry: false }\n *\n * Vision.convertToBoolean_(Vision.likelihood.UNLIKELY, {\n *   blurry: 'POSSIBLE'\n * });\n * // { blurry: true }\n */\nVision.convertToBoolean_ = function(baseLikelihood, object) {\n  var convertedObject = {};\n\n  for (var prop in object) {\n    if (object.hasOwnProperty(prop)) {\n      var value = Vision.likelihood[object[prop]];\n      convertedObject[prop] = value >= baseLikelihood;\n    }\n  }\n\n  return convertedObject;\n};\n\n/**\n * Determine the type of image the user is asking to be annotated. If a\n * {module:storage/file}, convert to its \"gs://{bucket}/{file}\" URL. If a remote\n * URL, read the contents and convert to a base64 string. If a file path to a\n * local file, convert to a base64 string.\n *\n * @private\n */\nVision.findImages_ = function(images, callback) {\n  var MAX_PARALLEL_LIMIT = 5;\n  images = arrify(images);\n\n  function findImage(image, callback) {\n    if (image instanceof File) {\n      callback(null, {\n        source: {\n          gcsImageUri: format('gs://{bucketName}/{fileName}', {\n            bucketName: image.bucket.name,\n            fileName: image.name\n          })\n        }\n      });\n\n      return;\n    }\n\n    // File is a URL.\n    if (/^http/.test(image)) {\n      request({\n        method: 'GET',\n        uri: image,\n        encoding: 'base64'\n      }, function(err, resp, body) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        callback(null, { content: body });\n      });\n\n      return;\n    }\n\n    // File exists on disk.\n    fs.readFile(image, { encoding: 'base64' }, function(err, contents) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      callback(null, { content: contents });\n    });\n  }\n\n  async.mapLimit(images, MAX_PARALLEL_LIMIT, findImage, callback);\n};\n\n/**\n * Format a raw entity annotation response from the API.\n *\n * @private\n */\nVision.formatEntityAnnotation_ = function(entityAnnotation, options) {\n  if (!options.verbose) {\n    return entityAnnotation.description;\n  }\n\n  var formattedEntityAnnotation = {\n    desc: entityAnnotation.description\n  };\n\n  if (entityAnnotation.mid) {\n    formattedEntityAnnotation.mid = entityAnnotation.mid;\n  }\n\n  if (entityAnnotation.score) {\n    formattedEntityAnnotation.score = entityAnnotation.score * 100;\n  }\n\n  if (entityAnnotation.boundingPoly) {\n    formattedEntityAnnotation.bounds = entityAnnotation.boundingPoly.vertices;\n  }\n\n  if (is.defined(entityAnnotation.confidence)) {\n    formattedEntityAnnotation.confidence = entityAnnotation.confidence * 100;\n  }\n\n  if (entityAnnotation.locations) {\n    var locations = entityAnnotation.locations;\n    formattedEntityAnnotation.locations = locations.map(prop('latLng'));\n  }\n\n  if (entityAnnotation.properties) {\n    formattedEntityAnnotation.properties = entityAnnotation.properties;\n  }\n\n  return formattedEntityAnnotation;\n};\n\n/**\n * Format a raw error from the API.\n *\n * @private\n */\nVision.formatError_ = function(err) {\n  var httpError = GrpcService.GRPC_ERROR_CODE_TO_HTTP[err.code];\n\n  if (httpError) {\n    err.code = httpError.code;\n  }\n\n  return err;\n};\n\n/**\n * Format a raw face annotation response from the API.\n *\n * @private\n */\nVision.formatFaceAnnotation_ = function(faceAnnotation) {\n  function findLandmark(type) {\n    var landmarks = faceAnnotation.landmarks;\n\n    return landmarks.filter(function(landmark) {\n      return landmark.type === type;\n    })[0].position;\n  }\n\n  var formattedFaceAnnotation = {\n    angles: {\n      pan: faceAnnotation.panAngle,\n      roll: faceAnnotation.rollAngle,\n      tilt: faceAnnotation.tiltAngle\n    },\n\n    bounds: {\n      head: faceAnnotation.boundingPoly.vertices,\n      face: faceAnnotation.fdBoundingPoly.vertices\n    },\n\n    features: {\n      confidence: faceAnnotation.landmarkingConfidence * 100,\n      chin: {\n        center: findLandmark('CHIN_GNATHION'),\n        left: findLandmark('CHIN_LEFT_GONION'),\n        right: findLandmark('CHIN_RIGHT_GONION')\n      },\n      ears: {\n        left: findLandmark('LEFT_EAR_TRAGION'),\n        right: findLandmark('RIGHT_EAR_TRAGION'),\n      },\n      eyebrows: {\n        left: {\n          left: findLandmark('LEFT_OF_LEFT_EYEBROW'),\n          right: findLandmark('RIGHT_OF_LEFT_EYEBROW'),\n          top: findLandmark('LEFT_EYEBROW_UPPER_MIDPOINT')\n        },\n        right: {\n          left: findLandmark('LEFT_OF_RIGHT_EYEBROW'),\n          right: findLandmark('RIGHT_OF_RIGHT_EYEBROW'),\n          top: findLandmark('RIGHT_EYEBROW_UPPER_MIDPOINT')\n        }\n      },\n      eyes: {\n        left: {\n          bottom: findLandmark('LEFT_EYE_BOTTOM_BOUNDARY'),\n          center: findLandmark('LEFT_EYE'),\n          left: findLandmark('LEFT_EYE_LEFT_CORNER'),\n          pupil: findLandmark('LEFT_EYE_PUPIL'),\n          right: findLandmark('LEFT_EYE_RIGHT_CORNER'),\n          top: findLandmark('LEFT_EYE_TOP_BOUNDARY')\n        },\n        right: {\n          bottom: findLandmark('RIGHT_EYE_BOTTOM_BOUNDARY'),\n          center: findLandmark('RIGHT_EYE'),\n          left: findLandmark('RIGHT_EYE_LEFT_CORNER'),\n          pupil: findLandmark('RIGHT_EYE_PUPIL'),\n          right: findLandmark('RIGHT_EYE_RIGHT_CORNER'),\n          top: findLandmark('RIGHT_EYE_TOP_BOUNDARY')\n        }\n      },\n      forehead: findLandmark('FOREHEAD_GLABELLA'),\n      lips: {\n        bottom: findLandmark('LOWER_LIP'),\n        top: findLandmark('UPPER_LIP')\n      },\n      mouth: {\n        center: findLandmark('MOUTH_CENTER'),\n        left: findLandmark('MOUTH_LEFT'),\n        right: findLandmark('MOUTH_RIGHT')\n      },\n      nose: {\n        bottom: {\n          center: findLandmark('NOSE_BOTTOM_CENTER'),\n          left: findLandmark('NOSE_BOTTOM_LEFT'),\n          right: findLandmark('NOSE_BOTTOM_RIGHT')\n        },\n        tip: findLandmark('NOSE_TIP'),\n        top: findLandmark('MIDPOINT_BETWEEN_EYES')\n      }\n    },\n\n    confidence: faceAnnotation.detectionConfidence * 100\n  };\n\n  extend(formattedFaceAnnotation, Vision.convertToBoolean_(LIKELY, {\n    blurry: faceAnnotation.blurredLikelihood,\n    dark: faceAnnotation.underExposedLikelihood,\n    happy: faceAnnotation.joyLikelihood,\n    hat: faceAnnotation.headwearLikelihood,\n    mad: faceAnnotation.angerLikelihood,\n    sad: faceAnnotation.sorrowLikelihood,\n    surprised: faceAnnotation.surpriseLikelihood\n  }));\n\n  return formattedFaceAnnotation;\n};\n\n/**\n * Format a raw image properties annotation response from the API.\n *\n * @private\n */\nVision.formatImagePropertiesAnnotation_ = function(imageAnnotation, options) {\n  var formattedImageAnnotation = {\n    colors: imageAnnotation.dominantColors.colors\n      .map(function(colorObject) {\n        var red = colorObject.color.red;\n        var green = colorObject.color.green;\n        var blue = colorObject.color.blue;\n\n        var hex = rgbHex(red, green, blue);\n\n        if (!options.verbose) {\n          return hex;\n        }\n\n        colorObject.hex = hex;\n\n        colorObject.red = red;\n        colorObject.green = green;\n        colorObject.blue = blue;\n        delete colorObject.color;\n\n        colorObject.coverage = colorObject.pixelFraction *= 100;\n        delete colorObject.pixelFraction;\n\n        colorObject.score *= 100;\n\n        return colorObject;\n      })\n  };\n\n  return formattedImageAnnotation;\n};\n\n/**\n * Format a raw SafeSearch annotation response from the API.\n *\n * @private\n */\nVision.formatSafeSearchAnnotation_ = function(ssAnnotation, options) {\n  if (!options.verbose) {\n    return Vision.convertToBoolean_(LIKELY, ssAnnotation);\n  }\n\n  return ssAnnotation;\n};\n\nmodule.exports = Vision;\n"}